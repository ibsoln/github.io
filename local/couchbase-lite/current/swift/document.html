<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Documents&#8201;&#8212;&#8201;Data Model | Couchbase Docs</title>
<link rel="canonical" href="http://127.0.0.1:5000/couchbase-lite/current/swift/document.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite concepts -- Data model -- Documents">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/swift/document.html">
<meta name="generator" content="Antora 3.0.0-alpha.5">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="http://127.0.0.1:5000/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="http://127.0.0.1:5000/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile Local
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile Local</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list" data-component="couchbase-lite">
          <option value="3.0" data-url="../index.html" selected>3.0</option>
          <option value="2.8" data-url="../../2.8/index.html">2.8</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">New in 3.0</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/kotlin.html">Kotlin</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android/">API References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android-ktx">Kotlin Extensions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../c/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-downloads.html">Download</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/c_fleece.html">Fleece API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/field-level-encryption.html">Field Level Encryption</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/replication.html">Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-c/">API&#160;References</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile-server-diffs.html">N1QL Mobile - Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-net/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-java/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-objc/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#swift:landing-replications.adoc">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-swift/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
      </div>
      <div class="version_items hide" data-version="2.8">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/index.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/android/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-predictive.html">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/android/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/android/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-android/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">C#.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:csharp:query-predictive.adoc">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/csharp/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-net">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/java/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-predictive.html">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/java/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-java/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/objc/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:objc:query-predictive.adoc">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-objc">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/swift/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-predictive.html">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/swift/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/swift/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-swift">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/javascript.html">JavaScript</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/javascript.html">JavaScript</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list" data-component="sync-gateway">
          <option value="3.0" data-url="../../../sync-gateway/current/index.html" selected>3.0</option>
          <option value="2.8" data-url="../../../sync-gateway/2.8/index.html">2.8</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html"><strong><em>New in 3.0</em></strong></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/index.html">Quick Links</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-import-filter.html">Import Filter</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties-legacy.html">Legacy Pre-3.0&#160;BETA Configuration</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-javascript-functions.html">Javascript Functions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-environment-variables.html">Environment Variables</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/secure-sgw-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Cert Authentication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access Control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-to</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign User to Role</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRS for Access Grants</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-Purge Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access-rbac-roles.html">RBAC Role - Endpoint Cross-Reference</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Application</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Inter Syncgateway Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import Filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect Info</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS Level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Pre-2.1 Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
      <div class="version_items hide" data-version="2.8">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/2.8/index.html">Quick Start</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Concepts</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties-legacy.html">Configuration</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">REST API Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::rest-api-client-app.adoc">REST API Client</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Certificate Authentication</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::read-access.adoc">Read Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::write-access.adoc">Write Access</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Couchbase Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Couchbase Lite</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Monitor</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Take Database Offline/Online</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Deploy</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS-level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/2.8/server-integration.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing versus Views</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::pn-supported-os.adoc">Supported OS</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::resolving-conflicts.adoc">Conflict Resolution 1.x Clients</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG-Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Log Rotation pre-2.1</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Sync Gateway Glossary</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Sync Gateway Glossary</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2@">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/pages/document.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="quickstart.html">Swift</a></li>
<li class="crumb"><a href="document.html">Documents</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Documents&#8201;&#8212;&#8201;Data Model</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract pendingDocumentIds()">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite concepts&#8201;&#8212;&#8201;Data model&#8201;&#8212;&#8201;Documents</em><br>
Related Content&#8201;&#8212;&#8201;<a href="database.html" class="page">Databases</a> | <a href="blob.html" class="page">Blobs</a> | <a href="indexing.html" class="page">Indexing</a> |</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Couchbase Lite the term 'document' is refers to an entry in the database; a record, or row in a table if you like.</p>
</div>
<div class="paragraph">
<p>Each document has an ID (primary key in other databases) by which it can be located.
This ID can be automatically generated (as a UUID) or specified programmatically;
the only constraints are that it must be unique within the database, and it can&#8217;t be changed.
The document also has a value which contains the actual application data.
This value is stored as a dictionary collection of key-value (k-v) pairs where the values themselves may comprise different types of data such as numbers, strings, arrays or even nested objects&#8201;&#8212;&#8201;see: <a href="#data-types">Data Types</a></p>
</div>
<div class="paragraph">
<p>The document body is stored in an internal, efficient, binary form (
<a href="https://github.com/couchbaselabs/fleece#readme">Fleece</a>
).<br>
This internal form is easily converted into a manageable native dictionary format for manipulation in applications.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite also provides for the direct handling of JSON data implemented in most cases by the provision of a <code>toJSON()</code> method on appropriate API classes (for example, on MutableDocument, Dictionary, Blob and Array)&#8201;&#8212;&#8201;see <a href="#lbl-json-data">Working with JSON Data</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="constructing-a-document"><a class="anchor" href="#constructing-a-document"></a>Constructing a Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An individual document often represents a single instance of an object in application code.
A document might be considered equivalent to a row in a relational table; with each of the document’s attributes being equivalent to a column.</p>
</div>
<div class="paragraph">
<p>Documents can contain nested structures.
This allows developers to express many-to-many relationships without requiring a reference or junction table; and is naturally expressive of hierarchical data.</p>
</div>
<div class="paragraph">
<p>Most apps will work with one or more documents, persisting them to a local database and optionally syncing the either centrally or to the cloud.</p>
</div>
<div class="paragraph">
<p>In this section we provide an example of how you might create a <code>hotel</code> document, which provides basic contact details and price data.</p>
</div>
<div class="listingblock">
<div class="title">Data Model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">hotel: {
  type: string (value = `hotel`)
  name: string
  address: dictionary {
    street: string
    city: string
    state: string
    country: string
    code: string
  }
  phones: array
  rate: float
}</code></pre>
</div>
</div>
<div id="ex-usage" class="olist arabic">
<ol class="arabic">
<li>
<p>Open or create your database</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML

class SampleCodeTest {
    /<strong>
     For consistency in code snippets:
     1. we will use <code>self.database</code>/ <code>database</code> for database, query, replicator-db related code snippets.
     2. we will use <code>self.otherDB</code> / <code>otherDB</code> for listener-db
     <strong>/

    var database: Database!
    var otherDB: Database!

    /</strong>
     For consistency:
     1. we will use replicator with <code>self.replicator</code> and listener with <code>self.listener</code>
     */
    var replicator: Replicator!
    var listener: URLEndpointListener!

    var replicatorsToPeers = [String: Replicator]()
    var replicatorListenerTokens = [String: Any]()

    // MARK: Database

    func dontTestNewDatabase() throws {
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }

        do {
            try self.database.close()
        }
    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        self.database.EncryptionKey(
    }
#endif

    func dontTestLogging() throws {
        // verbose / replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // verbose / query
        Database.log.console.level = .verbose
        Database.log.console.domains = .query
    }

    func dontTestConsoleLogging() throws {
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>


        Database.log.console.domains = .database

    }

    func dontTestFileLogging() throws {
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
    }

    func dontTestEnableCustomLogging() throws {
        let logger = LogTestLogger(.warning)
        Database.log.custom =  logger <i class="conum" data-value="8"></i><b>(8)</b>
    }

    func dontTestLoadingPrebuilt() throws {
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
    }

    // MARK: Document

    func dontTestInitializer() throws {
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
    }

    func dontTestMutability() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
    }

    func dontTestTypedAcessors() throws {
        let newTask = MutableDocument()

        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")

        print(newTask.toDictionary())  <i class="conum" data-value="9"></i><b>(9)</b>


        print(newTask.toJSON()) <i class="conum" data-value="10"></i><b>(10)</b>


        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestChangeListener() throws {
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
    }

    func dontTestDocumentExpiration() throws {
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try database.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        print(query)
    }

    func dontTestBlob() throws {
#if TARGET_OS_IPHONE
        let newTask = MutableDocument()
        var image: UIImage!

        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)! <i class="conum" data-value="11"></i><b>(11)</b>

        let blob = Blob(contentType: "image/jpeg", data: imageData) <i class="conum" data-value="12"></i><b>(12)</b>
        newTask.setBlob(blob, forKey: "avatar") <i class="conum" data-value="13"></i><b>(13)</b>
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }

        print("\(image)")
#endif
    }

    // MARK: Query

    func dontTestQueryGetAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestIndexing() throws {
        // N1QL and Querybuilder versions
        let config = ValueIndexConfiguration(["type", "name"])
        try database.createIndex(index, withName: "TypeNameIndex")

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(Expression.property("type")),
                                            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
    }

    func dontTestSelectMeta() throws {
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
    }


    func dontTestSelectProps() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        
    }

    func dontTestSelectAll() throws {
        var query: Query

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="14"></i><b>(14)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="15"></i><b>(15)</b>
            for result in change.results! {
                print(result.keys)
                /</strong> Update UI <strong>/
            }
        } <i class="conum" data-value="16"></i><b>(16)</b>


        query.removeChangeListener(withToken: token) <i class="conum" data-value="17"></i><b>(17)</b>


        print("\(query)")
    }

    func dontTestWhere() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
    }

    func dontTestQueryDeletedDocuments() throws {
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.isDeleted)
        print(query)
    }

    func dontTestCollectionOperatorContains() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction.contains(Expression.property("public_likes"),
                                                value: Expression.string("Armani Langworth")))
            )

        do {
            for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
    }

    func dontTestCollectionOperatorIn() throws {
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
        ]

        let query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))

        print(query)
    }


    func dontTestLikeOperator() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="18"></i><b>(18)</b>
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX")))
            )

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
            )

        do {
            for result in try query.execute() {
                print("""
                    There are \(result.int(forKey: "$1")) airports on
                                the \(result.string(forKey: "tz")!)timezone located
                                in \(result.string(forKey: "country")!) and above 300 ft
                """)
            }
        }
    }

    func dontTestOrderBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))

        print("\(query)")
    }

    func dontTestExplainAll() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="19"></i><b>(19)</b>

        print(try query.explain()) <i class="conum" data-value="20"></i><b>(20)</b>
    }

    func dontTestExplainLike() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="21"></i><b>(21)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain())

    }

    func dontTestExplainNoOp() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="22"></i><b>(22)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain());

    }

    func dontTestExplainFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))) <i class="conum" data-value="23"></i><b>(23)</b>

        print(try query.explain());

    }

    func dontTestExplainNoFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="24"></i><b>(24)</b>

        print(try query.explain());

    }


    func dontTestCreateFullTextIndex() throws {
        // Insert documents
        let overviews = ["Handy for the nice beaches in Southport", "Close to Turnpike.", "By Michigan football's Big House"]
        for overview in overviews {
            let doc = MutableDocument()
            doc.setString("overview", forKey: "type")
            doc.setString(overview, forKey: "overview")
            try database.saveDocument(doc)
        }

        // Create index with N1QL
        do {
            let index = FullTextIndexConfiguration(["overview"])
            try database.createIndex(index, withName: "overviewFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestCreateFullTextIndex_Querybuilder() throws {

        // Create index with Querybuilder
        let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("overview")).ignoreAccents(false)
        try database.createIndex(index, withName: "overviewFTSIndex")
    }


    func dontTestFullTextSearch() throws {

        let ftsStr = "SELECT Meta().id FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)"

        let query = database.createQuery(query: ftsStr)

        let rs = try query.execute()
        for result in rs {
            print("document id \(result.string(at: 0)!)")
        }

    }



    func dontTestFullTextSearch_Querybuilder() throws {
        database = self.db

        let whereClause = FullTextFunction.match(indexName: "overviewFTSIndex"), query: "'michigan'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        for result in try query.execute() {
            print("document id \(result.string(at: 0)!)")
        }


    // MARK: toJSON

    func dontTestToJsonArrayObject() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="25"></i><b>(25)</b>
            guard let array = doc.array(forKey: "list") else {
                return
            }

            let json = array.toJSON() <i class="conum" data-value="26"></i><b>(26)</b>
            print(json)
        }
    }

    func dontTestToJsonDictionary() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="27"></i><b>(27)</b>
            guard let dictionary = doc.dictionary(forKey: "dictionary") else {
                return
            }

            let json = dictionary.toJSON() <i class="conum" data-value="28"></i><b>(28)</b>
            print(json)
        }
    }

    func dontTestToJsonDocument() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "doc-id") {
            let json = doc.toJSON()
            print(json)
        }
    }

    func dontTestQueryResultToJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))

        // demonstrate use of JSON string
        let resultSet = try query.execute()
        for result in resultSet {
            let json = result.toJSON()
            print(json)
        }
    }

    func dontTestBlobToJSON() throws {
        // Get a document
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="29"></i><b>(29)</b>
            guard let blob = doc.blob(forKey: "avatar") else {
                return
            }

            let json = blob.toJSON() <i class="conum" data-value="30"></i><b>(30)</b>
            print(json)
        }

        // FIXME: check below function to validate whether the given property dictionary is a valid blob or not
    }

    func dontTestIsBlob() throws {
        let digest = ""

        // tag::[dictionary-isblob]
        if(Blob.isBlob(properties: [Blob.typeProperty: Blob.blobType,
                                    Blob.blobDigestProperty: digest])) { <i class="conum" data-value="31"></i><b>(31)</b>
            print("Yes! I am a blob");
        }
        // end::[dictionary-isblob]
    }
    // -- !!!

    // MARK: Replication

    /</strong> The <code>tag::replication[]</code> example is inlined in swift.adoc <strong>/

    func dontTestEnableReplicatorLogging() throws {
        // Verbose / Replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // Verbose / Network
        Database.log.console.level = .verbose
        Database.log.console.domains = .network
    }

    func dontTestReplicationBasicAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationSessionAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicatorStatus() throws {
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
    }

    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {

        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        let myDocIDs = try self.replicator.pendingDocumentIds() <i class="conum" data-value="32"></i><b>(32)</b>

        if(!myDocIDs.isEmpty) {
            print("There are \(myDocIDs.count) documents pending")
            let thisID = myDocIDs.first!

            self.replicator.addChangeListener { (change) in
                print("Replicator activity level is \(change.status.activity)")
                do {
                    let isPending = try self.replicator.isDocumentPending(thisID)
                    if(!isPending) { <i class="conum" data-value="33"></i><b>(33)</b>
                        print("Doc ID \(thisID) now pushed")
                    }
                } catch {
                    print(error)
                }
            }

            self.replicator.start()
        }
    }

    //  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()

        self.replicator.removeChangeListener(withToken: token)
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
    }

    func dontTestHandlingReplicationError() throws {
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
    }

    func dontTestReplicationResetCheckpoint() throws {
        let doResetCheckpointRequired = Bool.random()


        if doResetCheckpointRequired {
            self.replicator.start(reset: true)  <i class="conum" data-value="34"></i><b>(34)</b>
        } else {
            self.replicator.start()
        }

    }

    func dontTestReplicationPushFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationPullFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    //  Added 2/Feb/21 - Ian Bridge
    //  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        let target = URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        var config =  ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = true
        config.heartbeat = 150 <i class="conum" data-value="35"></i><b>(35)</b>

        config.maxAttempts = 20 <i class="conum" data-value="36"></i><b>(36)</b>

        config.maxAttemptWaitTime = 600 <i class="conum" data-value="37"></i><b>(37)</b>
        self.replicator = Replicator(config: config)

    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /</strong> EE feature: code below might throw a compilation error
         if it's compiled against CBL Swift Community. <strong>/
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()

        try database2.delete()
    }
#endif

    func dontTestCertificatePinning() throws {

        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        var replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")

        Database.prediction.unregisterModel(withName: "ImageClassifier")
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                    .and(
                        prediction.property("probablity")
                            .greaterThanOrEqualTo(Expression.double(0.8))
                    )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
    }

    func dontTestCoreMLPredictiveModel() throws {
        // Load MLModel from <code>ImageClassifier.mlmodel</code>
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
    }

    func dontTestReplicatorConflictResolver() throws {
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestSaveWithConflictHandler() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, <em>) in first })
            new.setData(result)
            return true
        })

    }

    // helper
    func isValidCredentials(</em> u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { (username, password) -&gt; Bool in
            return self.isValidCredentials(username, password: password)
        })

    }

    func dontTestListenerStart() throws {
        try listener.start()

    }

    func dontTestListenerStop() throws {
        listener.stop()

    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
        try TLSIdentity.createIdentity(forServer: true,
                                       attributes: attrs,
                                       expiration: Date().addingTimeInterval(86400),
                                       label: "Server-Cert-Label")
        print("\(identity.expiration)") // to avoid warning
    }

    // MARK: -- URLEndpointListener
    func dontTestTLSIdentityCreate() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-server-cert-label");
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: "couchbaselite-server-cert-label")
        print(identity)
    }

    func dontTestDeleteIdentity() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-client-cert-label")
    }

    func dontTestImportTLSIdentity() throws {

        let path = Bundle.main.path(forResource: "identity/client", ofType: "p12")
        let clientCertData = try NSData(contentsOfFile: path!, options: []) as Data
        let identity = try TLSIdentity.importIdentity(withData: clientCertData,
                                                      password: "123",
                                                      label: "couchbaselite-client-cert-label")
        print(identity)
    }

    // MARK: -- QUERY RESULT SET HANDLING EXAMPLES

    func donTestQuerySyntaxAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))


        print(query)
    }

    func dontTestQueryAccessAll() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Any]()

        let results = try query.execute()
        for row in results {
            let docsProps = row.dictionary(at: 0)! <i class="conum" data-value="38"></i><b>(38)</b>

            let docid = docsProps.string(forKey: "id")
            let name = docsProps.string(forKey: "name")
            let type = docsProps.string(forKey: "type")
            let city = docsProps.string(forKey: "city")

            print("\(docid): \(name), \(type), \(city)")
            let hotel = row.dictionary(at: 0)!  <i class="conum" data-value="39"></i><b>(39)</b>
            guard let hotelId = hotel.string(forKey: "id") else {
                continue
            }

            hotels[hotelId] = hotel
        }

    }



    func dontTestQueryAccessJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String:Hotel]()

        // In this example the Hotel class is defined using Codable
        //
        // class Hotel : Codable {
        //   var id : String = "undefined"
        //   var type : String = "hotel"
        //   var name : String = "undefined"
        //   var city : String = "undefined"
        //   var country : String = "undefined"
        //   var description : String? = ""
        //   var text : String? = ""
        //   ... other class content
        // }

        let results = try query.execute()
        for row in  results {

            // get the result into a JSON String
            let jsonString = row.toJSON() <i class="conum" data-value="40"></i><b>(40)</b>

            let thisJsonObj:Dictionary =
            try (JSONSerialization.jsonObject(
                with: jsonString.data(using: .utf8)!,
                options: .allowFragments)
                 as? [String: Any])! <i class="conum" data-value="41"></i><b>(41)</b>

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="42"></i><b>(42)</b>

            // ALTERNATIVELY unpack in steps
            this_hotel.id = thisJsonObj["id"] as! String
            this_hotel.name = thisJsonObj["name"] as! String
            this_hotel.type = thisJsonObj["type"] as! String
            this_hotel.city = thisJsonObj["city"] as! String
            hotels[this_hotel.id] = this_hotel

        } // end for

    }

    func dontTestQuerySyntaxProps() throws {
        let database = try! Database(name: "hotel")

        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestQueryAccessProps () throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Hotel]()

        for result in try! query.execute() {
            let docID = result.string(forKey: "metaId")!
            print("processing doc: \(docID)")

            let id = result.string(forKey: "id")!
            var hotel = Hotel(id: id)
            hotel.name = result.string(forKey: "name")
            hotel.city = result.string(forKey: "city")
            hotel.type = result.string(forKey: "type")
            hotels[id] = hotel
        } // end for

    }// end func

    func dontTestQueryCount() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
            .from (DataSource.database(database)).groupBy(Expression.property("type"))


        for result in try query.execute() {
            let count = result.int(forKey: "mycount") <i class="conum" data-value="43"></i><b>(43)</b>
            print("There are ", count, " rows")
        }
    }

    func dontTestQueryId () throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))



        let results = try query.execute()
        for result in results {

            print(result.toDictionary())

            let docId = result.string(forKey: "metaId")! <i class="conum" data-value="44"></i><b>(44)</b>
            print("Document Id is -- \(docId)")

            // Now you can get the document using the ID
            let doc = database.document(withID: docId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")


        }
    }

    func query_pagination () throws {
        let offset = 0;
        let limit = 20;
        //
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .limit(Expression.int(limit), offset: Expression.int(offset))

        print(query)
    }

    func dontTestQueryN1QL() throws {

        let database = try Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = 'hotel'") <i class="conum" data-value="45"></i><b>(45)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestQueryN1QLparams() throws {

        let database = try! Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = $type") <i class="conum" data-value="46"></i><b>(46)</b>

        query.parameters = Parameters().setString("hotel", forName: "type") <i class="conum" data-value="47"></i><b>(47)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestProcessResults(results: ResultSet) throws {

        for row in results {
            print(row["thisId"].string!)

            let docsId = row["thisId"].string!

            // Now you can get the document using the ID
            let doc = database.document(withID: docsId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")

        }

    }

    // MARK: -- Listener

    func dontTestListenerSimple() throws {
        let database = try Database(name: "database")
        var config = URLEndpointListenerConfiguration(database: database) <i class="conum" data-value="48"></i><b>(48)</b>
        config.authenticator = ListenerPasswordAuthenticator { username, password in
            return "valid.user" == username &amp;&amp; "valid.password.string" == String(password)
        } <i class="conum" data-value="49"></i><b>(49)</b>

        let listener = URLEndpointListener(config: config) <i class="conum" data-value="50"></i><b>(50)</b>

        try listener.start()  <i class="conum" data-value="51"></i><b>(51)</b>

    }

    func dontTestListenerInitialize() throws {
        let otherDB = try Database(name: "otherDB")

        var config = URLEndpointListenerConfiguration(database: otherDB) <i class="conum" data-value="52"></i><b>(52)</b>

        /</strong> optionally <strong>/ let wsPort: UInt16 = 55991
        /</strong> optionally <strong>/ let wssPort: UInt16 = 55990
        config.port =  wssPort <i class="conum" data-value="53"></i><b>(53)</b>

        config.networkInterface = "10.1.1.10"  <i class="conum" data-value="54"></i><b>(54)</b>

        config.enableDeltaSync = true <i class="conum" data-value="55"></i><b>(55)</b>

        config.disableTLS  = false <i class="conum" data-value="56"></i><b>(56)</b>

        // Set the credentials the server presents the client
        // Use an anonymous self-signed cert
        config.tlsIdentity = nil <i class="conum" data-value="57"></i><b>(57)</b>

        // Configure how the client is to be authenticated
        // Here, use Basic Authentication
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { uname, pword -&gt; Bool in
            return self.isValidCredentials(uname, password: pword)
        }) <i class="conum" data-value="58"></i><b>(58)</b>


        // Initialize the listener
        self.listener = URLEndpointListener(config: config) <i class="conum" data-value="59"></i><b>(59)</b>
        if self.listener == nil {
            fatalError("ListenerError Not Initialized")
            // ... take appropriate actions
        }

        // Start the listener
        try self.listener.start() <i class="conum" data-value="60"></i><b>(60)</b>


        print(wsPort)
    }

    func dontTestReplicatorSimple() throws {

        let tgtUrl = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="61"></i><b>(61)</b>

        var thisConfig = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="62"></i><b>(62)</b>

        thisConfig.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="63"></i><b>(63)</b>

        let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
        thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="64"></i><b>(64)</b>

        self.replicator = Replicator(config: thisConfig) <i class="conum" data-value="65"></i><b>(65)</b>

        self.replicator.start(); <i class="conum" data-value="66"></i><b>(66)</b>

    }


    // MARK: Append

    func dontTestGetURLList() throws {
        let config = URLEndpointListenerConfiguration(database: otherDB)
        let listener = URLEndpointListener(config: config)
        try listener.start()

        if let urls = listener.urls {
            print("URLs are: \(urls)")
        }

    }


    func dontTestListenerConfigDisableTLSUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.disableTLS  = false <i class="conum" data-value="67"></i><b>(67)</b>

        config.disableTLS  = true <i class="conum" data-value="68"></i><b>(68)</b>

    }

    func dontTestListenerConfigTLSIdentity() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        guard let path = Bundle.main.path(forResource: "cert", ofType: "p12") else {
            /</strong> process error <strong>/ return
        }

        guard let certData = try? NSData(contentsOfFile: path) as Data else {
            /</strong> process error <strong>/ return
        } <i class="conum" data-value="69"></i><b>(69)</b>

        let tlsIdentity = try TLSIdentity.importIdentity(withData: certData,
                                                         password: "123",
                                                         label: "Server-Cert-Label") <i class="conum" data-value="70"></i><b>(70)</b>

        let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="71"></i><b>(71)</b>

        let identity = try TLSIdentity.createIdentity(forServer: true, /</strong> isServer <strong>/
                                                      attributes: attrs,
                                                      expiration: Date().addingTimeInterval(86400),
                                                      label: "Server-Cert-Label") <i class="conum" data-value="72"></i><b>(72)</b>

        // Set the credentials the server presents the client
        config.tlsIdentity = tlsIdentity    <i class="conum" data-value="73"></i><b>(73)</b>


        print("To avoid waring: \(identity)")
    }

    func dontTestListenerConfigClientRootCA() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        // Authenticate using Cert Authority

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="74"></i><b>(74)</b>
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="75"></i><b>(75)</b> <i class="conum" data-value="76"></i><b>(76)</b>

    }

    func isValidCertificates(_ certs: [SecCertificate]) -&gt; Bool { return true }

    func dontTestClientAuthLambda() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        // Authenticate self-signed cert using application logic

        config.authenticator = ListenerCertificateAuthenticator { certs -&gt; Bool in <i class="conum" data-value="77"></i><b>(77)</b>
            // Validate the cert
            return self.isValidCertificates(certs)
        } <i class="conum" data-value="78"></i><b>(78)</b>

    }

    func dontTestListenerConfigUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        config.tlsIdentity = nil

        config.enableDeltaSync = true

        let totalConnections = self.listener.status.connectionCount
        let activeConnections = self.listener.status.activeConnectionCount

        self.listener.stop()

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

        config.authenticator = ListenerCertificateAuthenticator { self.isValidCertificates($0) }

        print("to avoid warnings: \(activeConnections)/\(totalConnections) ")
    }

    func dontTestURLEndpointListenerConstructor() throws {
        let enableTLS = Bool.random()
        let wssPort: UInt16 = 4985
        let wsPort: UInt16 = 4984
        let auth = ListenerPasswordAuthenticator { self.isValidCredentials($0, password: $1)}

        var config = URLEndpointListenerConfiguration.init(database: otherDB)
        config.port = enableTLS ? wssPort : wsPort
        config.disableTLS = !enableTLS
        config.authenticator = auth
        self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    func fMyActPeer() {

        guard let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB") else {
            fatalError("Invalid URL")
        }
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="79"></i><b>(79)</b>

        config.replicatorType = .pushAndPull

        // set auto-purge behavior (here we override default)
        config.enableAutoPurge = false <i class="conum" data-value="80"></i><b>(80)</b>

        // Configure Sync Mode
        config.continuous = true

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="81"></i><b>(81)</b>

        // Configure Client Security <i class="conum" data-value="82"></i><b>(82)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: "cbl-user-01",
                                                  password: "secret")

        /</strong> Optionally set custom conflict resolver call back
         config.conflictResolver = LocalWinConflictResolver()  <i class="conum" data-value="83"></i><b>(83)</b>
         <strong>/

        // Apply configuration settings to the replicator
        self.replicator = Replicator.init( config: config) <i class="conum" data-value="84"></i><b>(84)</b>

        // Optionally add a change listener
        // Retain token for use in deletion
        let token = self.replicator.addChangeListener { change in <i class="conum" data-value="85"></i><b>(85)</b>
            if change.status.activity == .stopped {
                print("Replication stopped")
            } else {
                print("Replicator is currently : \(self.replicator.status.activity)")
            }
        }

        // Run the replicator using the config settings
        self.replicator.start()  <i class="conum" data-value="86"></i><b>(86)</b>



        self.replicator.removeChangeListener(withToken: token)
    }


    func dontTestReplicatorStop() {
        let token = self.replicator.addChangeListener { change in }

        // Remove the change listener
        self.replicator.removeChangeListener(withToken: token)

        // Stop the replicator
        self.replicator.stop()

    }

    func dontTestAdditionalListenerConfigs() throws {
        let target = DatabaseEndpoint(database: otherDB)
        var config = ReplicatorConfiguration(database: database, target: target)
        let cert = self.listener.tlsIdentity!.certs[0]
        let validUsername = "cbl-user-01"
        let validPassword = "secret"
        // Configure Server Security -- only accept CA Certs
        config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="87"></i><b>(87)</b>

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="88"></i><b>(88)</b>

        // Return the remote pinned cert (the listener's cert)
        config.pinnedServerCertificate = cert // Get listener cert if pinned

        // Configure Client Security <i class="conum" data-value="89"></i><b>(89)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: validUsername, password: validPassword)


        // Check if Id exists in keychain and if so, use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") { <i class="conum" data-value="90"></i><b>(90)</b>
            print("An identity with label : doco-sync-server already exists in keychain")
            config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity) <i class="conum" data-value="91"></i><b>(91)</b>
        }

    }

    func myGetCert() throws -&gt; TLSIdentity? {
        var osStatus: OSStatus
        let target = DatabaseEndpoint(database: self.otherDB)
        var config = ReplicatorConfiguration(database: self.database, target: target)

        //var thisData : CFData?
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
            print("An identity with label : doco-sync-server already exists in keychain")
            return tlsIdentity
        }

        // FIXME: since old-p2p-tlsid-tlsidentity-with-label[] is removed, this code is not under any tag?
        guard let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") else {
            return nil
        }
        config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity)

        // CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let path = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
              let certData = NSData(contentsOfFile: path)
        else {
            return nil
        }

        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        var result : CFArray?
        osStatus = SecPKCS12Import(certData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;result)
        if osStatus != errSecSuccess {
            print("Failed to import data from provided with error :\(osStatus) ")
            return nil
        }
        let importedItems = result! as NSArray
        let item = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let secIdentity = item[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var privateKey : SecKey?
        osStatus = SecIdentityCopyPrivateKey(secIdentity, &amp;privateKey)
        if osStatus != errSecSuccess {
            print("Failed to import private key from provided with error :\(osStatus) ")
            return nil
        }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let certChain = item[String(kSecImportItemCertChain)] as? [SecCertificate]


        // Return nil, if errors in key, certChain at this stage
        guard let privateKey = privateKey, let certChain = certChain else {
            return nil
        }

        // STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN
#if os(iOS)
        // For iOS, need to save the identity into the KeyChain.
        // Save or Update identity with a label so that it could be cleaned up easily
        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       privateKey
        ]
        osStatus = SecItemAdd(params as CFDictionary, nil)
        if osStatus != errSecSuccess {
            print("Unable to store private key")
            return nil
        }
        // Store all Certs for Id in Keychain:
        var i = 0;
        for cert in certChain {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
            ]
            osStatus = SecItemAdd(params as CFDictionary, nil)
            if osStatus != errSecSuccess {
                print("Unable to store certs")
                return nil
            }
            i=i+1
        }
#else
        let query: [String : Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0]
        ]

        let update: [String: Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0],
            String(kSecAttrLabel):      label
        ]

        osStatus = SecItemUpdate(query as CFDictionary, update as CFDictionary)
        if osStatus != errSecSuccess {
            print("Unable to update certs \(osStatus)")
            return nil
        }
#endif


        // RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
        return try TLSIdentity.identity(withIdentity: secIdentity, certs: [certChain[1]])
    }

    func dontTestDeleteIDFromKeychain() throws {

        try TLSIdentity.deleteIdentity(withLabel: "doco-sync-server")


    }

    func myCaCertPinned() {
        let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint)

        // Get bundled resource and read into localcert
        guard
            let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer"),
            let localCertificate:NSData = NSData(contentsOfFile: pathToCert)
        else { /</strong> process error <strong>/ return }

        // Create certificate
        // using its DER representation as a CFData
        guard
            let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
        else { /</strong> process error <strong>/  return }

        // Add <code>pinnedCert</code> and <code>acceptOnlySelfSignedServerCertificate=false</code>(by default)
        // to <code>ReplicatorConfiguration</code>
        config.pinnedServerCertificate = pinnedCert

    }

    func dontTestOldListenerConfigClientRootCA() throws {
        // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="92"></i><b>(92)</b>
    }


    enum PeerConnectionStatus: UInt8 {
        case stopped = 0;
        case offline
        case connecting
        case idle
        case busy
    }

    func dontTestReplicationStart(_ peer: String,
                                  peerDBName: String,
                                  user: String?,
                                  pass: String?,
                                  handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) throws {
        guard let validUser = user, let validPassword = pass else {
            fatalError("UserCredentialsNotProvided")
            // ... take appropriate actions
        }

        var replicator = self.replicatorsToPeers[peer]

        if replicator == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(peerDBName)") else {
                fatalError("URLInvalid")
                // ... take appropriate actions
            }

            var config = ReplicatorConfiguration.init(database: self.database, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>


            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>


            config.authenticator = BasicAuthenticator(username: validUser, password: validPassword)

            replicator = Replicator.init(config: config)
            self.replicatorsToPeers[peer] = replicator

            let token = registerForEventsForReplicator(replicator!, handler: handler)
            self.replicatorListenerTokens[peer] = token

        }

        replicator?.start()
    }

    func registerForEventsForReplicator(_ replicator: Replicator,
                                        handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) -&gt; ListenerToken {
        return replicator.addChangeListener { change in
            guard change.status.error == nil else {
                handler(.stopped, change.status.error)
                return
            }

            switch change.status.activity {
            case .connecting:
                print("Replicator Connecting to Peer")
            case .idle:
                print("Replicator in Idle state")
            case .busy:
                print("Replicator in busy state")
            case .offline:
                print("Replicator in offline state")
            case .stopped:
                print("Replicator is stopped")
            }

            let progress = change.status.progress
            if progress.completed == progress.total {
                print("All documents synced")
            }
            else {
                print("Documents \(progress.total - progress.completed) still pending sync")
            }

            if let customStatus = PeerConnectionStatus(rawValue: change.status.activity.rawValue) {
                handler(customStatus, nil)
            }
        }
    }

    func startListener() {
        var messageEndpointListener: MessageEndpointListener!

        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)

        print(messageEndpointListener.connections.count)
    }
}

class MyClass {
    var database: Database!
    var replicator: Replicator! <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }
}


/</strong>

 &lt;.&gt; A replication is an asynchronous operation.
 To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
 &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
 You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.



 let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
 let targetEndpoint = URLEndpoint(url: tgtUrl)
 var config = ReplicatorConfiguration(database: database!, target: targetEndpoint) <i class="conum" data-value="93"></i><b>(93)</b>


 <strong>/

// MARK: -- Conflict Resolver Helpers

class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}

class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}

class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}

// MARK: -- PredictiveModel Helpers

// <code>myMLModel</code> is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] { return [:] }
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // <code>myMLModel</code> is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

// MARK: Prediction Model
class TestPredictiveModel: PredictiveModel {

    class var name: String {
        return "Untitled"
    }

    var numberOfCalls = 0

    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        numberOfCalls = numberOfCalls + 1
        return self.doPredict(input: input)
    }

    func doPredict(input: DictionaryObject) -&gt; DictionaryObject? {
        return nil
    }

    func registerModel() {
        Database.prediction.registerModel(self, withName: type(of: self).name)
    }

    func unregisterModel() {
        Database.prediction.unregisterModel(withName: type(of: self).name)
    }

    func reset() {
        numberOfCalls = 0
    }
}

// MARK: -- Custom Logger

class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    // constructor for easiness
    init(_ level: LogLevel) {
        self.level = level
    }

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }
}

struct Hotel: Codable {
    var id: String
    var type: String?
    var name: String?
    var city: String?
}

#if os(macOS)
import SystemConfiguration
// . . .

class SomeClass {
    func SomeFunction() {
        for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
            // do something with this <code>interface</code>
        }
    }

    // . . .
}

#endif

// MARK -- P2p

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        let database = try Database(name: "dbname")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)

        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        return connection
    }

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion()
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
    }

    func stopListener() {
        messageEndpointListener?.closeAll()
    }

    func acceptConnection() {
        let connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection: connection)
    }

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler */
        completion()
    }
}

public class Supporting_Datatypes
{

    func datatype_dictionary()
    {

        let database = try?Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database?.document(withID:"doc1");

        // Getting a dictionary from the document's properties
        let dict = document?.dictionary(forKey: "address");

        // Access a value with a key from the dictionary
        let street = dict?.string(forKey: "street");

        // Iterate dictionary
        for key in dict!.keys {
            print("Key \(key) = \(dict!.value(forKey:key))");
        }

        // Create a mutable copy
        let mutable_dict = dict?.toMutable();
    }

    func datatype_mutable_dictionary()
    {

        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        var mutable_dict = MutableDictionaryObject();
        mutable_dict.setString("1 Main st.", forKey: "street");
        mutable_dict.setString("San Francisco", forKey: "city");

        // Add the dictionary to a document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setDictionary(mutable_dict, forKey: "address");
        try!database.saveDocument(mutable_doc);

    }


    func datatype_array()
    {
        let database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database.document(withID:"doc1");

        // Getting a phones array from the document's properties
        let array = document?.array(forKey: "phones")

        // Get element count
        let count = array!.count;

        // Access an array element by index
        if count &gt;= 0 { let phone = array![1]; }

        // Iterate dictionary
        for (index, element) in array!.enumerated() {
            print("Index \(index) = \(element)");
        }

        // Create a mutable copy
        var mutable_array = array!.toMutable();

    }

    func datatype_mutable_array()
    {
        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        var mutable_array = MutableArrayObject();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

            // Set the array to document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setArray(mutable_array, forKey:"phones");
        try!database.saveDocument(mutable_doc);
    }

} // end class supporting_datatypes



// MARK: -- QUESTIONS

// FIXME: can we use the docsn site to show the interface of the Listener class?
// <a href="https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html" class="bare">https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html</a></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>+
See: <a href="database.html" class="page">Databases</a> for more information</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Initialize a new mutable document</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML

class SampleCodeTest {
    /<strong>
     For consistency in code snippets:
     1. we will use <code>self.database</code>/ <code>database</code> for database, query, replicator-db related code snippets.
     2. we will use <code>self.otherDB</code> / <code>otherDB</code> for listener-db
     <strong>/

    var database: Database!
    var otherDB: Database!

    /</strong>
     For consistency:
     1. we will use replicator with <code>self.replicator</code> and listener with <code>self.listener</code>
     */
    var replicator: Replicator!
    var listener: URLEndpointListener!

    var replicatorsToPeers = [String: Replicator]()
    var replicatorListenerTokens = [String: Any]()

    // MARK: Database

    func dontTestNewDatabase() throws {
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }

        do {
            try self.database.close()
        }
    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        self.database.EncryptionKey(
    }
#endif

    func dontTestLogging() throws {
        // verbose / replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // verbose / query
        Database.log.console.level = .verbose
        Database.log.console.domains = .query
    }

    func dontTestConsoleLogging() throws {
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>


        Database.log.console.domains = .database

    }

    func dontTestFileLogging() throws {
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
    }

    func dontTestEnableCustomLogging() throws {
        let logger = LogTestLogger(.warning)
        Database.log.custom =  logger <i class="conum" data-value="8"></i><b>(8)</b>
    }

    func dontTestLoadingPrebuilt() throws {
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
    }

    // MARK: Document

    func dontTestInitializer() throws {
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
    }

    func dontTestMutability() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
    }

    func dontTestTypedAcessors() throws {
        let newTask = MutableDocument()

        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")

        print(newTask.toDictionary())  <i class="conum" data-value="9"></i><b>(9)</b>


        print(newTask.toJSON()) <i class="conum" data-value="10"></i><b>(10)</b>


        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestChangeListener() throws {
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
    }

    func dontTestDocumentExpiration() throws {
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try database.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        print(query)
    }

    func dontTestBlob() throws {
#if TARGET_OS_IPHONE
        let newTask = MutableDocument()
        var image: UIImage!

        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)! <i class="conum" data-value="11"></i><b>(11)</b>

        let blob = Blob(contentType: "image/jpeg", data: imageData) <i class="conum" data-value="12"></i><b>(12)</b>
        newTask.setBlob(blob, forKey: "avatar") <i class="conum" data-value="13"></i><b>(13)</b>
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }

        print("\(image)")
#endif
    }

    // MARK: Query

    func dontTestQueryGetAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestIndexing() throws {
        // N1QL and Querybuilder versions
        let config = ValueIndexConfiguration(["type", "name"])
        try database.createIndex(index, withName: "TypeNameIndex")

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(Expression.property("type")),
                                            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
    }

    func dontTestSelectMeta() throws {
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
    }


    func dontTestSelectProps() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        
    }

    func dontTestSelectAll() throws {
        var query: Query

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="14"></i><b>(14)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="15"></i><b>(15)</b>
            for result in change.results! {
                print(result.keys)
                /</strong> Update UI <strong>/
            }
        } <i class="conum" data-value="16"></i><b>(16)</b>


        query.removeChangeListener(withToken: token) <i class="conum" data-value="17"></i><b>(17)</b>


        print("\(query)")
    }

    func dontTestWhere() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
    }

    func dontTestQueryDeletedDocuments() throws {
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.isDeleted)
        print(query)
    }

    func dontTestCollectionOperatorContains() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction.contains(Expression.property("public_likes"),
                                                value: Expression.string("Armani Langworth")))
            )

        do {
            for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
    }

    func dontTestCollectionOperatorIn() throws {
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
        ]

        let query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))

        print(query)
    }


    func dontTestLikeOperator() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="18"></i><b>(18)</b>
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX")))
            )

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
            )

        do {
            for result in try query.execute() {
                print("""
                    There are \(result.int(forKey: "$1")) airports on
                                the \(result.string(forKey: "tz")!)timezone located
                                in \(result.string(forKey: "country")!) and above 300 ft
                """)
            }
        }
    }

    func dontTestOrderBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))

        print("\(query)")
    }

    func dontTestExplainAll() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="19"></i><b>(19)</b>

        print(try query.explain()) <i class="conum" data-value="20"></i><b>(20)</b>
    }

    func dontTestExplainLike() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="21"></i><b>(21)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain())

    }

    func dontTestExplainNoOp() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="22"></i><b>(22)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain());

    }

    func dontTestExplainFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))) <i class="conum" data-value="23"></i><b>(23)</b>

        print(try query.explain());

    }

    func dontTestExplainNoFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="24"></i><b>(24)</b>

        print(try query.explain());

    }


    func dontTestCreateFullTextIndex() throws {
        // Insert documents
        let overviews = ["Handy for the nice beaches in Southport", "Close to Turnpike.", "By Michigan football's Big House"]
        for overview in overviews {
            let doc = MutableDocument()
            doc.setString("overview", forKey: "type")
            doc.setString(overview, forKey: "overview")
            try database.saveDocument(doc)
        }

        // Create index with N1QL
        do {
            let index = FullTextIndexConfiguration(["overview"])
            try database.createIndex(index, withName: "overviewFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestCreateFullTextIndex_Querybuilder() throws {

        // Create index with Querybuilder
        let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("overview")).ignoreAccents(false)
        try database.createIndex(index, withName: "overviewFTSIndex")
    }


    func dontTestFullTextSearch() throws {

        let ftsStr = "SELECT Meta().id FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)"

        let query = database.createQuery(query: ftsStr)

        let rs = try query.execute()
        for result in rs {
            print("document id \(result.string(at: 0)!)")
        }

    }



    func dontTestFullTextSearch_Querybuilder() throws {
        database = self.db

        let whereClause = FullTextFunction.match(indexName: "overviewFTSIndex"), query: "'michigan'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        for result in try query.execute() {
            print("document id \(result.string(at: 0)!)")
        }


    // MARK: toJSON

    func dontTestToJsonArrayObject() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="25"></i><b>(25)</b>
            guard let array = doc.array(forKey: "list") else {
                return
            }

            let json = array.toJSON() <i class="conum" data-value="26"></i><b>(26)</b>
            print(json)
        }
    }

    func dontTestToJsonDictionary() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="27"></i><b>(27)</b>
            guard let dictionary = doc.dictionary(forKey: "dictionary") else {
                return
            }

            let json = dictionary.toJSON() <i class="conum" data-value="28"></i><b>(28)</b>
            print(json)
        }
    }

    func dontTestToJsonDocument() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "doc-id") {
            let json = doc.toJSON()
            print(json)
        }
    }

    func dontTestQueryResultToJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))

        // demonstrate use of JSON string
        let resultSet = try query.execute()
        for result in resultSet {
            let json = result.toJSON()
            print(json)
        }
    }

    func dontTestBlobToJSON() throws {
        // Get a document
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="29"></i><b>(29)</b>
            guard let blob = doc.blob(forKey: "avatar") else {
                return
            }

            let json = blob.toJSON() <i class="conum" data-value="30"></i><b>(30)</b>
            print(json)
        }

        // FIXME: check below function to validate whether the given property dictionary is a valid blob or not
    }

    func dontTestIsBlob() throws {
        let digest = ""

        // tag::[dictionary-isblob]
        if(Blob.isBlob(properties: [Blob.typeProperty: Blob.blobType,
                                    Blob.blobDigestProperty: digest])) { <i class="conum" data-value="31"></i><b>(31)</b>
            print("Yes! I am a blob");
        }
        // end::[dictionary-isblob]
    }
    // -- !!!

    // MARK: Replication

    /</strong> The <code>tag::replication[]</code> example is inlined in swift.adoc <strong>/

    func dontTestEnableReplicatorLogging() throws {
        // Verbose / Replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // Verbose / Network
        Database.log.console.level = .verbose
        Database.log.console.domains = .network
    }

    func dontTestReplicationBasicAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationSessionAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicatorStatus() throws {
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
    }

    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {

        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        let myDocIDs = try self.replicator.pendingDocumentIds() <i class="conum" data-value="32"></i><b>(32)</b>

        if(!myDocIDs.isEmpty) {
            print("There are \(myDocIDs.count) documents pending")
            let thisID = myDocIDs.first!

            self.replicator.addChangeListener { (change) in
                print("Replicator activity level is \(change.status.activity)")
                do {
                    let isPending = try self.replicator.isDocumentPending(thisID)
                    if(!isPending) { <i class="conum" data-value="33"></i><b>(33)</b>
                        print("Doc ID \(thisID) now pushed")
                    }
                } catch {
                    print(error)
                }
            }

            self.replicator.start()
        }
    }

    //  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()

        self.replicator.removeChangeListener(withToken: token)
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
    }

    func dontTestHandlingReplicationError() throws {
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
    }

    func dontTestReplicationResetCheckpoint() throws {
        let doResetCheckpointRequired = Bool.random()


        if doResetCheckpointRequired {
            self.replicator.start(reset: true)  <i class="conum" data-value="34"></i><b>(34)</b>
        } else {
            self.replicator.start()
        }

    }

    func dontTestReplicationPushFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationPullFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    //  Added 2/Feb/21 - Ian Bridge
    //  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        let target = URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        var config =  ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = true
        config.heartbeat = 150 <i class="conum" data-value="35"></i><b>(35)</b>

        config.maxAttempts = 20 <i class="conum" data-value="36"></i><b>(36)</b>

        config.maxAttemptWaitTime = 600 <i class="conum" data-value="37"></i><b>(37)</b>
        self.replicator = Replicator(config: config)

    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /</strong> EE feature: code below might throw a compilation error
         if it's compiled against CBL Swift Community. <strong>/
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()

        try database2.delete()
    }
#endif

    func dontTestCertificatePinning() throws {

        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        var replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")

        Database.prediction.unregisterModel(withName: "ImageClassifier")
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                    .and(
                        prediction.property("probablity")
                            .greaterThanOrEqualTo(Expression.double(0.8))
                    )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
    }

    func dontTestCoreMLPredictiveModel() throws {
        // Load MLModel from <code>ImageClassifier.mlmodel</code>
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
    }

    func dontTestReplicatorConflictResolver() throws {
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestSaveWithConflictHandler() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, <em>) in first })
            new.setData(result)
            return true
        })

    }

    // helper
    func isValidCredentials(</em> u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { (username, password) -&gt; Bool in
            return self.isValidCredentials(username, password: password)
        })

    }

    func dontTestListenerStart() throws {
        try listener.start()

    }

    func dontTestListenerStop() throws {
        listener.stop()

    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
        try TLSIdentity.createIdentity(forServer: true,
                                       attributes: attrs,
                                       expiration: Date().addingTimeInterval(86400),
                                       label: "Server-Cert-Label")
        print("\(identity.expiration)") // to avoid warning
    }

    // MARK: -- URLEndpointListener
    func dontTestTLSIdentityCreate() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-server-cert-label");
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: "couchbaselite-server-cert-label")
        print(identity)
    }

    func dontTestDeleteIdentity() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-client-cert-label")
    }

    func dontTestImportTLSIdentity() throws {

        let path = Bundle.main.path(forResource: "identity/client", ofType: "p12")
        let clientCertData = try NSData(contentsOfFile: path!, options: []) as Data
        let identity = try TLSIdentity.importIdentity(withData: clientCertData,
                                                      password: "123",
                                                      label: "couchbaselite-client-cert-label")
        print(identity)
    }

    // MARK: -- QUERY RESULT SET HANDLING EXAMPLES

    func donTestQuerySyntaxAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))


        print(query)
    }

    func dontTestQueryAccessAll() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Any]()

        let results = try query.execute()
        for row in results {
            let docsProps = row.dictionary(at: 0)! <i class="conum" data-value="38"></i><b>(38)</b>

            let docid = docsProps.string(forKey: "id")
            let name = docsProps.string(forKey: "name")
            let type = docsProps.string(forKey: "type")
            let city = docsProps.string(forKey: "city")

            print("\(docid): \(name), \(type), \(city)")
            let hotel = row.dictionary(at: 0)!  <i class="conum" data-value="39"></i><b>(39)</b>
            guard let hotelId = hotel.string(forKey: "id") else {
                continue
            }

            hotels[hotelId] = hotel
        }

    }



    func dontTestQueryAccessJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String:Hotel]()

        // In this example the Hotel class is defined using Codable
        //
        // class Hotel : Codable {
        //   var id : String = "undefined"
        //   var type : String = "hotel"
        //   var name : String = "undefined"
        //   var city : String = "undefined"
        //   var country : String = "undefined"
        //   var description : String? = ""
        //   var text : String? = ""
        //   ... other class content
        // }

        let results = try query.execute()
        for row in  results {

            // get the result into a JSON String
            let jsonString = row.toJSON() <i class="conum" data-value="40"></i><b>(40)</b>

            let thisJsonObj:Dictionary =
            try (JSONSerialization.jsonObject(
                with: jsonString.data(using: .utf8)!,
                options: .allowFragments)
                 as? [String: Any])! <i class="conum" data-value="41"></i><b>(41)</b>

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="42"></i><b>(42)</b>

            // ALTERNATIVELY unpack in steps
            this_hotel.id = thisJsonObj["id"] as! String
            this_hotel.name = thisJsonObj["name"] as! String
            this_hotel.type = thisJsonObj["type"] as! String
            this_hotel.city = thisJsonObj["city"] as! String
            hotels[this_hotel.id] = this_hotel

        } // end for

    }

    func dontTestQuerySyntaxProps() throws {
        let database = try! Database(name: "hotel")

        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestQueryAccessProps () throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Hotel]()

        for result in try! query.execute() {
            let docID = result.string(forKey: "metaId")!
            print("processing doc: \(docID)")

            let id = result.string(forKey: "id")!
            var hotel = Hotel(id: id)
            hotel.name = result.string(forKey: "name")
            hotel.city = result.string(forKey: "city")
            hotel.type = result.string(forKey: "type")
            hotels[id] = hotel
        } // end for

    }// end func

    func dontTestQueryCount() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
            .from (DataSource.database(database)).groupBy(Expression.property("type"))


        for result in try query.execute() {
            let count = result.int(forKey: "mycount") <i class="conum" data-value="43"></i><b>(43)</b>
            print("There are ", count, " rows")
        }
    }

    func dontTestQueryId () throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))



        let results = try query.execute()
        for result in results {

            print(result.toDictionary())

            let docId = result.string(forKey: "metaId")! <i class="conum" data-value="44"></i><b>(44)</b>
            print("Document Id is -- \(docId)")

            // Now you can get the document using the ID
            let doc = database.document(withID: docId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")


        }
    }

    func query_pagination () throws {
        let offset = 0;
        let limit = 20;
        //
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .limit(Expression.int(limit), offset: Expression.int(offset))

        print(query)
    }

    func dontTestQueryN1QL() throws {

        let database = try Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = 'hotel'") <i class="conum" data-value="45"></i><b>(45)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestQueryN1QLparams() throws {

        let database = try! Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = $type") <i class="conum" data-value="46"></i><b>(46)</b>

        query.parameters = Parameters().setString("hotel", forName: "type") <i class="conum" data-value="47"></i><b>(47)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestProcessResults(results: ResultSet) throws {

        for row in results {
            print(row["thisId"].string!)

            let docsId = row["thisId"].string!

            // Now you can get the document using the ID
            let doc = database.document(withID: docsId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")

        }

    }

    // MARK: -- Listener

    func dontTestListenerSimple() throws {
        let database = try Database(name: "database")
        var config = URLEndpointListenerConfiguration(database: database) <i class="conum" data-value="48"></i><b>(48)</b>
        config.authenticator = ListenerPasswordAuthenticator { username, password in
            return "valid.user" == username &amp;&amp; "valid.password.string" == String(password)
        } <i class="conum" data-value="49"></i><b>(49)</b>

        let listener = URLEndpointListener(config: config) <i class="conum" data-value="50"></i><b>(50)</b>

        try listener.start()  <i class="conum" data-value="51"></i><b>(51)</b>

    }

    func dontTestListenerInitialize() throws {
        let otherDB = try Database(name: "otherDB")

        var config = URLEndpointListenerConfiguration(database: otherDB) <i class="conum" data-value="52"></i><b>(52)</b>

        /</strong> optionally <strong>/ let wsPort: UInt16 = 55991
        /</strong> optionally <strong>/ let wssPort: UInt16 = 55990
        config.port =  wssPort <i class="conum" data-value="53"></i><b>(53)</b>

        config.networkInterface = "10.1.1.10"  <i class="conum" data-value="54"></i><b>(54)</b>

        config.enableDeltaSync = true <i class="conum" data-value="55"></i><b>(55)</b>

        config.disableTLS  = false <i class="conum" data-value="56"></i><b>(56)</b>

        // Set the credentials the server presents the client
        // Use an anonymous self-signed cert
        config.tlsIdentity = nil <i class="conum" data-value="57"></i><b>(57)</b>

        // Configure how the client is to be authenticated
        // Here, use Basic Authentication
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { uname, pword -&gt; Bool in
            return self.isValidCredentials(uname, password: pword)
        }) <i class="conum" data-value="58"></i><b>(58)</b>


        // Initialize the listener
        self.listener = URLEndpointListener(config: config) <i class="conum" data-value="59"></i><b>(59)</b>
        if self.listener == nil {
            fatalError("ListenerError Not Initialized")
            // ... take appropriate actions
        }

        // Start the listener
        try self.listener.start() <i class="conum" data-value="60"></i><b>(60)</b>


        print(wsPort)
    }

    func dontTestReplicatorSimple() throws {

        let tgtUrl = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="61"></i><b>(61)</b>

        var thisConfig = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="62"></i><b>(62)</b>

        thisConfig.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="63"></i><b>(63)</b>

        let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
        thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="64"></i><b>(64)</b>

        self.replicator = Replicator(config: thisConfig) <i class="conum" data-value="65"></i><b>(65)</b>

        self.replicator.start(); <i class="conum" data-value="66"></i><b>(66)</b>

    }


    // MARK: Append

    func dontTestGetURLList() throws {
        let config = URLEndpointListenerConfiguration(database: otherDB)
        let listener = URLEndpointListener(config: config)
        try listener.start()

        if let urls = listener.urls {
            print("URLs are: \(urls)")
        }

    }


    func dontTestListenerConfigDisableTLSUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.disableTLS  = false <i class="conum" data-value="67"></i><b>(67)</b>

        config.disableTLS  = true <i class="conum" data-value="68"></i><b>(68)</b>

    }

    func dontTestListenerConfigTLSIdentity() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        guard let path = Bundle.main.path(forResource: "cert", ofType: "p12") else {
            /</strong> process error <strong>/ return
        }

        guard let certData = try? NSData(contentsOfFile: path) as Data else {
            /</strong> process error <strong>/ return
        } <i class="conum" data-value="69"></i><b>(69)</b>

        let tlsIdentity = try TLSIdentity.importIdentity(withData: certData,
                                                         password: "123",
                                                         label: "Server-Cert-Label") <i class="conum" data-value="70"></i><b>(70)</b>

        let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="71"></i><b>(71)</b>

        let identity = try TLSIdentity.createIdentity(forServer: true, /</strong> isServer <strong>/
                                                      attributes: attrs,
                                                      expiration: Date().addingTimeInterval(86400),
                                                      label: "Server-Cert-Label") <i class="conum" data-value="72"></i><b>(72)</b>

        // Set the credentials the server presents the client
        config.tlsIdentity = tlsIdentity    <i class="conum" data-value="73"></i><b>(73)</b>


        print("To avoid waring: \(identity)")
    }

    func dontTestListenerConfigClientRootCA() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        // Authenticate using Cert Authority

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="74"></i><b>(74)</b>
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="75"></i><b>(75)</b> <i class="conum" data-value="76"></i><b>(76)</b>

    }

    func isValidCertificates(_ certs: [SecCertificate]) -&gt; Bool { return true }

    func dontTestClientAuthLambda() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        // Authenticate self-signed cert using application logic

        config.authenticator = ListenerCertificateAuthenticator { certs -&gt; Bool in <i class="conum" data-value="77"></i><b>(77)</b>
            // Validate the cert
            return self.isValidCertificates(certs)
        } <i class="conum" data-value="78"></i><b>(78)</b>

    }

    func dontTestListenerConfigUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        config.tlsIdentity = nil

        config.enableDeltaSync = true

        let totalConnections = self.listener.status.connectionCount
        let activeConnections = self.listener.status.activeConnectionCount

        self.listener.stop()

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

        config.authenticator = ListenerCertificateAuthenticator { self.isValidCertificates($0) }

        print("to avoid warnings: \(activeConnections)/\(totalConnections) ")
    }

    func dontTestURLEndpointListenerConstructor() throws {
        let enableTLS = Bool.random()
        let wssPort: UInt16 = 4985
        let wsPort: UInt16 = 4984
        let auth = ListenerPasswordAuthenticator { self.isValidCredentials($0, password: $1)}

        var config = URLEndpointListenerConfiguration.init(database: otherDB)
        config.port = enableTLS ? wssPort : wsPort
        config.disableTLS = !enableTLS
        config.authenticator = auth
        self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    func fMyActPeer() {

        guard let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB") else {
            fatalError("Invalid URL")
        }
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="79"></i><b>(79)</b>

        config.replicatorType = .pushAndPull

        // set auto-purge behavior (here we override default)
        config.enableAutoPurge = false <i class="conum" data-value="80"></i><b>(80)</b>

        // Configure Sync Mode
        config.continuous = true

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="81"></i><b>(81)</b>

        // Configure Client Security <i class="conum" data-value="82"></i><b>(82)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: "cbl-user-01",
                                                  password: "secret")

        /</strong> Optionally set custom conflict resolver call back
         config.conflictResolver = LocalWinConflictResolver()  <i class="conum" data-value="83"></i><b>(83)</b>
         <strong>/

        // Apply configuration settings to the replicator
        self.replicator = Replicator.init( config: config) <i class="conum" data-value="84"></i><b>(84)</b>

        // Optionally add a change listener
        // Retain token for use in deletion
        let token = self.replicator.addChangeListener { change in <i class="conum" data-value="85"></i><b>(85)</b>
            if change.status.activity == .stopped {
                print("Replication stopped")
            } else {
                print("Replicator is currently : \(self.replicator.status.activity)")
            }
        }

        // Run the replicator using the config settings
        self.replicator.start()  <i class="conum" data-value="86"></i><b>(86)</b>



        self.replicator.removeChangeListener(withToken: token)
    }


    func dontTestReplicatorStop() {
        let token = self.replicator.addChangeListener { change in }

        // Remove the change listener
        self.replicator.removeChangeListener(withToken: token)

        // Stop the replicator
        self.replicator.stop()

    }

    func dontTestAdditionalListenerConfigs() throws {
        let target = DatabaseEndpoint(database: otherDB)
        var config = ReplicatorConfiguration(database: database, target: target)
        let cert = self.listener.tlsIdentity!.certs[0]
        let validUsername = "cbl-user-01"
        let validPassword = "secret"
        // Configure Server Security -- only accept CA Certs
        config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="87"></i><b>(87)</b>

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="88"></i><b>(88)</b>

        // Return the remote pinned cert (the listener's cert)
        config.pinnedServerCertificate = cert // Get listener cert if pinned

        // Configure Client Security <i class="conum" data-value="89"></i><b>(89)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: validUsername, password: validPassword)


        // Check if Id exists in keychain and if so, use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") { <i class="conum" data-value="90"></i><b>(90)</b>
            print("An identity with label : doco-sync-server already exists in keychain")
            config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity) <i class="conum" data-value="91"></i><b>(91)</b>
        }

    }

    func myGetCert() throws -&gt; TLSIdentity? {
        var osStatus: OSStatus
        let target = DatabaseEndpoint(database: self.otherDB)
        var config = ReplicatorConfiguration(database: self.database, target: target)

        //var thisData : CFData?
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
            print("An identity with label : doco-sync-server already exists in keychain")
            return tlsIdentity
        }

        // FIXME: since old-p2p-tlsid-tlsidentity-with-label[] is removed, this code is not under any tag?
        guard let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") else {
            return nil
        }
        config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity)

        // CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let path = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
              let certData = NSData(contentsOfFile: path)
        else {
            return nil
        }

        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        var result : CFArray?
        osStatus = SecPKCS12Import(certData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;result)
        if osStatus != errSecSuccess {
            print("Failed to import data from provided with error :\(osStatus) ")
            return nil
        }
        let importedItems = result! as NSArray
        let item = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let secIdentity = item[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var privateKey : SecKey?
        osStatus = SecIdentityCopyPrivateKey(secIdentity, &amp;privateKey)
        if osStatus != errSecSuccess {
            print("Failed to import private key from provided with error :\(osStatus) ")
            return nil
        }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let certChain = item[String(kSecImportItemCertChain)] as? [SecCertificate]


        // Return nil, if errors in key, certChain at this stage
        guard let privateKey = privateKey, let certChain = certChain else {
            return nil
        }

        // STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN
#if os(iOS)
        // For iOS, need to save the identity into the KeyChain.
        // Save or Update identity with a label so that it could be cleaned up easily
        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       privateKey
        ]
        osStatus = SecItemAdd(params as CFDictionary, nil)
        if osStatus != errSecSuccess {
            print("Unable to store private key")
            return nil
        }
        // Store all Certs for Id in Keychain:
        var i = 0;
        for cert in certChain {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
            ]
            osStatus = SecItemAdd(params as CFDictionary, nil)
            if osStatus != errSecSuccess {
                print("Unable to store certs")
                return nil
            }
            i=i+1
        }
#else
        let query: [String : Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0]
        ]

        let update: [String: Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0],
            String(kSecAttrLabel):      label
        ]

        osStatus = SecItemUpdate(query as CFDictionary, update as CFDictionary)
        if osStatus != errSecSuccess {
            print("Unable to update certs \(osStatus)")
            return nil
        }
#endif


        // RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
        return try TLSIdentity.identity(withIdentity: secIdentity, certs: [certChain[1]])
    }

    func dontTestDeleteIDFromKeychain() throws {

        try TLSIdentity.deleteIdentity(withLabel: "doco-sync-server")


    }

    func myCaCertPinned() {
        let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint)

        // Get bundled resource and read into localcert
        guard
            let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer"),
            let localCertificate:NSData = NSData(contentsOfFile: pathToCert)
        else { /</strong> process error <strong>/ return }

        // Create certificate
        // using its DER representation as a CFData
        guard
            let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
        else { /</strong> process error <strong>/  return }

        // Add <code>pinnedCert</code> and <code>acceptOnlySelfSignedServerCertificate=false</code>(by default)
        // to <code>ReplicatorConfiguration</code>
        config.pinnedServerCertificate = pinnedCert

    }

    func dontTestOldListenerConfigClientRootCA() throws {
        // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="92"></i><b>(92)</b>
    }


    enum PeerConnectionStatus: UInt8 {
        case stopped = 0;
        case offline
        case connecting
        case idle
        case busy
    }

    func dontTestReplicationStart(_ peer: String,
                                  peerDBName: String,
                                  user: String?,
                                  pass: String?,
                                  handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) throws {
        guard let validUser = user, let validPassword = pass else {
            fatalError("UserCredentialsNotProvided")
            // ... take appropriate actions
        }

        var replicator = self.replicatorsToPeers[peer]

        if replicator == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(peerDBName)") else {
                fatalError("URLInvalid")
                // ... take appropriate actions
            }

            var config = ReplicatorConfiguration.init(database: self.database, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>


            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>


            config.authenticator = BasicAuthenticator(username: validUser, password: validPassword)

            replicator = Replicator.init(config: config)
            self.replicatorsToPeers[peer] = replicator

            let token = registerForEventsForReplicator(replicator!, handler: handler)
            self.replicatorListenerTokens[peer] = token

        }

        replicator?.start()
    }

    func registerForEventsForReplicator(_ replicator: Replicator,
                                        handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) -&gt; ListenerToken {
        return replicator.addChangeListener { change in
            guard change.status.error == nil else {
                handler(.stopped, change.status.error)
                return
            }

            switch change.status.activity {
            case .connecting:
                print("Replicator Connecting to Peer")
            case .idle:
                print("Replicator in Idle state")
            case .busy:
                print("Replicator in busy state")
            case .offline:
                print("Replicator in offline state")
            case .stopped:
                print("Replicator is stopped")
            }

            let progress = change.status.progress
            if progress.completed == progress.total {
                print("All documents synced")
            }
            else {
                print("Documents \(progress.total - progress.completed) still pending sync")
            }

            if let customStatus = PeerConnectionStatus(rawValue: change.status.activity.rawValue) {
                handler(customStatus, nil)
            }
        }
    }

    func startListener() {
        var messageEndpointListener: MessageEndpointListener!

        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)

        print(messageEndpointListener.connections.count)
    }
}

class MyClass {
    var database: Database!
    var replicator: Replicator! <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }
}


/</strong>

 &lt;.&gt; A replication is an asynchronous operation.
 To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
 &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
 You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.



 let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
 let targetEndpoint = URLEndpoint(url: tgtUrl)
 var config = ReplicatorConfiguration(database: database!, target: targetEndpoint) <i class="conum" data-value="93"></i><b>(93)</b>


 <strong>/

// MARK: -- Conflict Resolver Helpers

class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}

class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}

class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}

// MARK: -- PredictiveModel Helpers

// <code>myMLModel</code> is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] { return [:] }
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // <code>myMLModel</code> is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

// MARK: Prediction Model
class TestPredictiveModel: PredictiveModel {

    class var name: String {
        return "Untitled"
    }

    var numberOfCalls = 0

    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        numberOfCalls = numberOfCalls + 1
        return self.doPredict(input: input)
    }

    func doPredict(input: DictionaryObject) -&gt; DictionaryObject? {
        return nil
    }

    func registerModel() {
        Database.prediction.registerModel(self, withName: type(of: self).name)
    }

    func unregisterModel() {
        Database.prediction.unregisterModel(withName: type(of: self).name)
    }

    func reset() {
        numberOfCalls = 0
    }
}

// MARK: -- Custom Logger

class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    // constructor for easiness
    init(_ level: LogLevel) {
        self.level = level
    }

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }
}

struct Hotel: Codable {
    var id: String
    var type: String?
    var name: String?
    var city: String?
}

#if os(macOS)
import SystemConfiguration
// . . .

class SomeClass {
    func SomeFunction() {
        for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
            // do something with this <code>interface</code>
        }
    }

    // . . .
}

#endif

// MARK -- P2p

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        let database = try Database(name: "dbname")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)

        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        return connection
    }

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion()
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
    }

    func stopListener() {
        messageEndpointListener?.closeAll()
    }

    func acceptConnection() {
        let connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection: connection)
    }

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler */
        completion()
    }
}

public class Supporting_Datatypes
{

    func datatype_dictionary()
    {

        let database = try?Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database?.document(withID:"doc1");

        // Getting a dictionary from the document's properties
        let dict = document?.dictionary(forKey: "address");

        // Access a value with a key from the dictionary
        let street = dict?.string(forKey: "street");

        // Iterate dictionary
        for key in dict!.keys {
            print("Key \(key) = \(dict!.value(forKey:key))");
        }

        // Create a mutable copy
        let mutable_dict = dict?.toMutable();
    }

    func datatype_mutable_dictionary()
    {

        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        var mutable_dict = MutableDictionaryObject();
        mutable_dict.setString("1 Main st.", forKey: "street");
        mutable_dict.setString("San Francisco", forKey: "city");

        // Add the dictionary to a document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setDictionary(mutable_dict, forKey: "address");
        try!database.saveDocument(mutable_doc);

    }


    func datatype_array()
    {
        let database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database.document(withID:"doc1");

        // Getting a phones array from the document's properties
        let array = document?.array(forKey: "phones")

        // Get element count
        let count = array!.count;

        // Access an array element by index
        if count &gt;= 0 { let phone = array![1]; }

        // Iterate dictionary
        for (index, element) in array!.enumerated() {
            print("Index \(index) = \(element)");
        }

        // Create a mutable copy
        var mutable_array = array!.toMutable();

    }

    func datatype_mutable_array()
    {
        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        var mutable_array = MutableArrayObject();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

            // Set the array to document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setArray(mutable_array, forKey:"phones");
        try!database.saveDocument(mutable_doc);
    }

} // end class supporting_datatypes



// MARK: -- QUESTIONS

// FIXME: can we use the docsn site to show the interface of the Listener class?
// <a href="https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html" class="bare">https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html</a></code></pre>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create and populate a mutable dictionary <code>address</code></p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML

class SampleCodeTest {
    /<strong>
     For consistency in code snippets:
     1. we will use <code>self.database</code>/ <code>database</code> for database, query, replicator-db related code snippets.
     2. we will use <code>self.otherDB</code> / <code>otherDB</code> for listener-db
     <strong>/

    var database: Database!
    var otherDB: Database!

    /</strong>
     For consistency:
     1. we will use replicator with <code>self.replicator</code> and listener with <code>self.listener</code>
     */
    var replicator: Replicator!
    var listener: URLEndpointListener!

    var replicatorsToPeers = [String: Replicator]()
    var replicatorListenerTokens = [String: Any]()

    // MARK: Database

    func dontTestNewDatabase() throws {
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }

        do {
            try self.database.close()
        }
    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        self.database.EncryptionKey(
    }
#endif

    func dontTestLogging() throws {
        // verbose / replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // verbose / query
        Database.log.console.level = .verbose
        Database.log.console.domains = .query
    }

    func dontTestConsoleLogging() throws {
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>


        Database.log.console.domains = .database

    }

    func dontTestFileLogging() throws {
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
    }

    func dontTestEnableCustomLogging() throws {
        let logger = LogTestLogger(.warning)
        Database.log.custom =  logger <i class="conum" data-value="8"></i><b>(8)</b>
    }

    func dontTestLoadingPrebuilt() throws {
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
    }

    // MARK: Document

    func dontTestInitializer() throws {
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
    }

    func dontTestMutability() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
    }

    func dontTestTypedAcessors() throws {
        let newTask = MutableDocument()

        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")

        print(newTask.toDictionary())  <i class="conum" data-value="9"></i><b>(9)</b>


        print(newTask.toJSON()) <i class="conum" data-value="10"></i><b>(10)</b>


        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestChangeListener() throws {
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
    }

    func dontTestDocumentExpiration() throws {
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try database.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        print(query)
    }

    func dontTestBlob() throws {
#if TARGET_OS_IPHONE
        let newTask = MutableDocument()
        var image: UIImage!

        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)! <i class="conum" data-value="11"></i><b>(11)</b>

        let blob = Blob(contentType: "image/jpeg", data: imageData) <i class="conum" data-value="12"></i><b>(12)</b>
        newTask.setBlob(blob, forKey: "avatar") <i class="conum" data-value="13"></i><b>(13)</b>
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }

        print("\(image)")
#endif
    }

    // MARK: Query

    func dontTestQueryGetAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestIndexing() throws {
        // N1QL and Querybuilder versions
        let config = ValueIndexConfiguration(["type", "name"])
        try database.createIndex(index, withName: "TypeNameIndex")

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(Expression.property("type")),
                                            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
    }

    func dontTestSelectMeta() throws {
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
    }


    func dontTestSelectProps() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        
    }

    func dontTestSelectAll() throws {
        var query: Query

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="14"></i><b>(14)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="15"></i><b>(15)</b>
            for result in change.results! {
                print(result.keys)
                /</strong> Update UI <strong>/
            }
        } <i class="conum" data-value="16"></i><b>(16)</b>


        query.removeChangeListener(withToken: token) <i class="conum" data-value="17"></i><b>(17)</b>


        print("\(query)")
    }

    func dontTestWhere() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
    }

    func dontTestQueryDeletedDocuments() throws {
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.isDeleted)
        print(query)
    }

    func dontTestCollectionOperatorContains() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction.contains(Expression.property("public_likes"),
                                                value: Expression.string("Armani Langworth")))
            )

        do {
            for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
    }

    func dontTestCollectionOperatorIn() throws {
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
        ]

        let query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))

        print(query)
    }


    func dontTestLikeOperator() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="18"></i><b>(18)</b>
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX")))
            )

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
            )

        do {
            for result in try query.execute() {
                print("""
                    There are \(result.int(forKey: "$1")) airports on
                                the \(result.string(forKey: "tz")!)timezone located
                                in \(result.string(forKey: "country")!) and above 300 ft
                """)
            }
        }
    }

    func dontTestOrderBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))

        print("\(query)")
    }

    func dontTestExplainAll() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="19"></i><b>(19)</b>

        print(try query.explain()) <i class="conum" data-value="20"></i><b>(20)</b>
    }

    func dontTestExplainLike() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="21"></i><b>(21)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain())

    }

    func dontTestExplainNoOp() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="22"></i><b>(22)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain());

    }

    func dontTestExplainFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))) <i class="conum" data-value="23"></i><b>(23)</b>

        print(try query.explain());

    }

    func dontTestExplainNoFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="24"></i><b>(24)</b>

        print(try query.explain());

    }


    func dontTestCreateFullTextIndex() throws {
        // Insert documents
        let overviews = ["Handy for the nice beaches in Southport", "Close to Turnpike.", "By Michigan football's Big House"]
        for overview in overviews {
            let doc = MutableDocument()
            doc.setString("overview", forKey: "type")
            doc.setString(overview, forKey: "overview")
            try database.saveDocument(doc)
        }

        // Create index with N1QL
        do {
            let index = FullTextIndexConfiguration(["overview"])
            try database.createIndex(index, withName: "overviewFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestCreateFullTextIndex_Querybuilder() throws {

        // Create index with Querybuilder
        let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("overview")).ignoreAccents(false)
        try database.createIndex(index, withName: "overviewFTSIndex")
    }


    func dontTestFullTextSearch() throws {

        let ftsStr = "SELECT Meta().id FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)"

        let query = database.createQuery(query: ftsStr)

        let rs = try query.execute()
        for result in rs {
            print("document id \(result.string(at: 0)!)")
        }

    }



    func dontTestFullTextSearch_Querybuilder() throws {
        database = self.db

        let whereClause = FullTextFunction.match(indexName: "overviewFTSIndex"), query: "'michigan'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        for result in try query.execute() {
            print("document id \(result.string(at: 0)!)")
        }


    // MARK: toJSON

    func dontTestToJsonArrayObject() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="25"></i><b>(25)</b>
            guard let array = doc.array(forKey: "list") else {
                return
            }

            let json = array.toJSON() <i class="conum" data-value="26"></i><b>(26)</b>
            print(json)
        }
    }

    func dontTestToJsonDictionary() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="27"></i><b>(27)</b>
            guard let dictionary = doc.dictionary(forKey: "dictionary") else {
                return
            }

            let json = dictionary.toJSON() <i class="conum" data-value="28"></i><b>(28)</b>
            print(json)
        }
    }

    func dontTestToJsonDocument() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "doc-id") {
            let json = doc.toJSON()
            print(json)
        }
    }

    func dontTestQueryResultToJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))

        // demonstrate use of JSON string
        let resultSet = try query.execute()
        for result in resultSet {
            let json = result.toJSON()
            print(json)
        }
    }

    func dontTestBlobToJSON() throws {
        // Get a document
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="29"></i><b>(29)</b>
            guard let blob = doc.blob(forKey: "avatar") else {
                return
            }

            let json = blob.toJSON() <i class="conum" data-value="30"></i><b>(30)</b>
            print(json)
        }

        // FIXME: check below function to validate whether the given property dictionary is a valid blob or not
    }

    func dontTestIsBlob() throws {
        let digest = ""

        // tag::[dictionary-isblob]
        if(Blob.isBlob(properties: [Blob.typeProperty: Blob.blobType,
                                    Blob.blobDigestProperty: digest])) { <i class="conum" data-value="31"></i><b>(31)</b>
            print("Yes! I am a blob");
        }
        // end::[dictionary-isblob]
    }
    // -- !!!

    // MARK: Replication

    /</strong> The <code>tag::replication[]</code> example is inlined in swift.adoc <strong>/

    func dontTestEnableReplicatorLogging() throws {
        // Verbose / Replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // Verbose / Network
        Database.log.console.level = .verbose
        Database.log.console.domains = .network
    }

    func dontTestReplicationBasicAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationSessionAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicatorStatus() throws {
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
    }

    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {

        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        let myDocIDs = try self.replicator.pendingDocumentIds() <i class="conum" data-value="32"></i><b>(32)</b>

        if(!myDocIDs.isEmpty) {
            print("There are \(myDocIDs.count) documents pending")
            let thisID = myDocIDs.first!

            self.replicator.addChangeListener { (change) in
                print("Replicator activity level is \(change.status.activity)")
                do {
                    let isPending = try self.replicator.isDocumentPending(thisID)
                    if(!isPending) { <i class="conum" data-value="33"></i><b>(33)</b>
                        print("Doc ID \(thisID) now pushed")
                    }
                } catch {
                    print(error)
                }
            }

            self.replicator.start()
        }
    }

    //  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()

        self.replicator.removeChangeListener(withToken: token)
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
    }

    func dontTestHandlingReplicationError() throws {
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
    }

    func dontTestReplicationResetCheckpoint() throws {
        let doResetCheckpointRequired = Bool.random()


        if doResetCheckpointRequired {
            self.replicator.start(reset: true)  <i class="conum" data-value="34"></i><b>(34)</b>
        } else {
            self.replicator.start()
        }

    }

    func dontTestReplicationPushFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationPullFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    //  Added 2/Feb/21 - Ian Bridge
    //  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        let target = URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        var config =  ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = true
        config.heartbeat = 150 <i class="conum" data-value="35"></i><b>(35)</b>

        config.maxAttempts = 20 <i class="conum" data-value="36"></i><b>(36)</b>

        config.maxAttemptWaitTime = 600 <i class="conum" data-value="37"></i><b>(37)</b>
        self.replicator = Replicator(config: config)

    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /</strong> EE feature: code below might throw a compilation error
         if it's compiled against CBL Swift Community. <strong>/
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()

        try database2.delete()
    }
#endif

    func dontTestCertificatePinning() throws {

        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        var replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")

        Database.prediction.unregisterModel(withName: "ImageClassifier")
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                    .and(
                        prediction.property("probablity")
                            .greaterThanOrEqualTo(Expression.double(0.8))
                    )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
    }

    func dontTestCoreMLPredictiveModel() throws {
        // Load MLModel from <code>ImageClassifier.mlmodel</code>
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
    }

    func dontTestReplicatorConflictResolver() throws {
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestSaveWithConflictHandler() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, <em>) in first })
            new.setData(result)
            return true
        })

    }

    // helper
    func isValidCredentials(</em> u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { (username, password) -&gt; Bool in
            return self.isValidCredentials(username, password: password)
        })

    }

    func dontTestListenerStart() throws {
        try listener.start()

    }

    func dontTestListenerStop() throws {
        listener.stop()

    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
        try TLSIdentity.createIdentity(forServer: true,
                                       attributes: attrs,
                                       expiration: Date().addingTimeInterval(86400),
                                       label: "Server-Cert-Label")
        print("\(identity.expiration)") // to avoid warning
    }

    // MARK: -- URLEndpointListener
    func dontTestTLSIdentityCreate() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-server-cert-label");
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: "couchbaselite-server-cert-label")
        print(identity)
    }

    func dontTestDeleteIdentity() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-client-cert-label")
    }

    func dontTestImportTLSIdentity() throws {

        let path = Bundle.main.path(forResource: "identity/client", ofType: "p12")
        let clientCertData = try NSData(contentsOfFile: path!, options: []) as Data
        let identity = try TLSIdentity.importIdentity(withData: clientCertData,
                                                      password: "123",
                                                      label: "couchbaselite-client-cert-label")
        print(identity)
    }

    // MARK: -- QUERY RESULT SET HANDLING EXAMPLES

    func donTestQuerySyntaxAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))


        print(query)
    }

    func dontTestQueryAccessAll() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Any]()

        let results = try query.execute()
        for row in results {
            let docsProps = row.dictionary(at: 0)! <i class="conum" data-value="38"></i><b>(38)</b>

            let docid = docsProps.string(forKey: "id")
            let name = docsProps.string(forKey: "name")
            let type = docsProps.string(forKey: "type")
            let city = docsProps.string(forKey: "city")

            print("\(docid): \(name), \(type), \(city)")
            let hotel = row.dictionary(at: 0)!  <i class="conum" data-value="39"></i><b>(39)</b>
            guard let hotelId = hotel.string(forKey: "id") else {
                continue
            }

            hotels[hotelId] = hotel
        }

    }



    func dontTestQueryAccessJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String:Hotel]()

        // In this example the Hotel class is defined using Codable
        //
        // class Hotel : Codable {
        //   var id : String = "undefined"
        //   var type : String = "hotel"
        //   var name : String = "undefined"
        //   var city : String = "undefined"
        //   var country : String = "undefined"
        //   var description : String? = ""
        //   var text : String? = ""
        //   ... other class content
        // }

        let results = try query.execute()
        for row in  results {

            // get the result into a JSON String
            let jsonString = row.toJSON() <i class="conum" data-value="40"></i><b>(40)</b>

            let thisJsonObj:Dictionary =
            try (JSONSerialization.jsonObject(
                with: jsonString.data(using: .utf8)!,
                options: .allowFragments)
                 as? [String: Any])! <i class="conum" data-value="41"></i><b>(41)</b>

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="42"></i><b>(42)</b>

            // ALTERNATIVELY unpack in steps
            this_hotel.id = thisJsonObj["id"] as! String
            this_hotel.name = thisJsonObj["name"] as! String
            this_hotel.type = thisJsonObj["type"] as! String
            this_hotel.city = thisJsonObj["city"] as! String
            hotels[this_hotel.id] = this_hotel

        } // end for

    }

    func dontTestQuerySyntaxProps() throws {
        let database = try! Database(name: "hotel")

        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestQueryAccessProps () throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Hotel]()

        for result in try! query.execute() {
            let docID = result.string(forKey: "metaId")!
            print("processing doc: \(docID)")

            let id = result.string(forKey: "id")!
            var hotel = Hotel(id: id)
            hotel.name = result.string(forKey: "name")
            hotel.city = result.string(forKey: "city")
            hotel.type = result.string(forKey: "type")
            hotels[id] = hotel
        } // end for

    }// end func

    func dontTestQueryCount() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
            .from (DataSource.database(database)).groupBy(Expression.property("type"))


        for result in try query.execute() {
            let count = result.int(forKey: "mycount") <i class="conum" data-value="43"></i><b>(43)</b>
            print("There are ", count, " rows")
        }
    }

    func dontTestQueryId () throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))



        let results = try query.execute()
        for result in results {

            print(result.toDictionary())

            let docId = result.string(forKey: "metaId")! <i class="conum" data-value="44"></i><b>(44)</b>
            print("Document Id is -- \(docId)")

            // Now you can get the document using the ID
            let doc = database.document(withID: docId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")


        }
    }

    func query_pagination () throws {
        let offset = 0;
        let limit = 20;
        //
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .limit(Expression.int(limit), offset: Expression.int(offset))

        print(query)
    }

    func dontTestQueryN1QL() throws {

        let database = try Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = 'hotel'") <i class="conum" data-value="45"></i><b>(45)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestQueryN1QLparams() throws {

        let database = try! Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = $type") <i class="conum" data-value="46"></i><b>(46)</b>

        query.parameters = Parameters().setString("hotel", forName: "type") <i class="conum" data-value="47"></i><b>(47)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestProcessResults(results: ResultSet) throws {

        for row in results {
            print(row["thisId"].string!)

            let docsId = row["thisId"].string!

            // Now you can get the document using the ID
            let doc = database.document(withID: docsId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")

        }

    }

    // MARK: -- Listener

    func dontTestListenerSimple() throws {
        let database = try Database(name: "database")
        var config = URLEndpointListenerConfiguration(database: database) <i class="conum" data-value="48"></i><b>(48)</b>
        config.authenticator = ListenerPasswordAuthenticator { username, password in
            return "valid.user" == username &amp;&amp; "valid.password.string" == String(password)
        } <i class="conum" data-value="49"></i><b>(49)</b>

        let listener = URLEndpointListener(config: config) <i class="conum" data-value="50"></i><b>(50)</b>

        try listener.start()  <i class="conum" data-value="51"></i><b>(51)</b>

    }

    func dontTestListenerInitialize() throws {
        let otherDB = try Database(name: "otherDB")

        var config = URLEndpointListenerConfiguration(database: otherDB) <i class="conum" data-value="52"></i><b>(52)</b>

        /</strong> optionally <strong>/ let wsPort: UInt16 = 55991
        /</strong> optionally <strong>/ let wssPort: UInt16 = 55990
        config.port =  wssPort <i class="conum" data-value="53"></i><b>(53)</b>

        config.networkInterface = "10.1.1.10"  <i class="conum" data-value="54"></i><b>(54)</b>

        config.enableDeltaSync = true <i class="conum" data-value="55"></i><b>(55)</b>

        config.disableTLS  = false <i class="conum" data-value="56"></i><b>(56)</b>

        // Set the credentials the server presents the client
        // Use an anonymous self-signed cert
        config.tlsIdentity = nil <i class="conum" data-value="57"></i><b>(57)</b>

        // Configure how the client is to be authenticated
        // Here, use Basic Authentication
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { uname, pword -&gt; Bool in
            return self.isValidCredentials(uname, password: pword)
        }) <i class="conum" data-value="58"></i><b>(58)</b>


        // Initialize the listener
        self.listener = URLEndpointListener(config: config) <i class="conum" data-value="59"></i><b>(59)</b>
        if self.listener == nil {
            fatalError("ListenerError Not Initialized")
            // ... take appropriate actions
        }

        // Start the listener
        try self.listener.start() <i class="conum" data-value="60"></i><b>(60)</b>


        print(wsPort)
    }

    func dontTestReplicatorSimple() throws {

        let tgtUrl = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="61"></i><b>(61)</b>

        var thisConfig = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="62"></i><b>(62)</b>

        thisConfig.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="63"></i><b>(63)</b>

        let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
        thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="64"></i><b>(64)</b>

        self.replicator = Replicator(config: thisConfig) <i class="conum" data-value="65"></i><b>(65)</b>

        self.replicator.start(); <i class="conum" data-value="66"></i><b>(66)</b>

    }


    // MARK: Append

    func dontTestGetURLList() throws {
        let config = URLEndpointListenerConfiguration(database: otherDB)
        let listener = URLEndpointListener(config: config)
        try listener.start()

        if let urls = listener.urls {
            print("URLs are: \(urls)")
        }

    }


    func dontTestListenerConfigDisableTLSUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.disableTLS  = false <i class="conum" data-value="67"></i><b>(67)</b>

        config.disableTLS  = true <i class="conum" data-value="68"></i><b>(68)</b>

    }

    func dontTestListenerConfigTLSIdentity() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        guard let path = Bundle.main.path(forResource: "cert", ofType: "p12") else {
            /</strong> process error <strong>/ return
        }

        guard let certData = try? NSData(contentsOfFile: path) as Data else {
            /</strong> process error <strong>/ return
        } <i class="conum" data-value="69"></i><b>(69)</b>

        let tlsIdentity = try TLSIdentity.importIdentity(withData: certData,
                                                         password: "123",
                                                         label: "Server-Cert-Label") <i class="conum" data-value="70"></i><b>(70)</b>

        let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="71"></i><b>(71)</b>

        let identity = try TLSIdentity.createIdentity(forServer: true, /</strong> isServer <strong>/
                                                      attributes: attrs,
                                                      expiration: Date().addingTimeInterval(86400),
                                                      label: "Server-Cert-Label") <i class="conum" data-value="72"></i><b>(72)</b>

        // Set the credentials the server presents the client
        config.tlsIdentity = tlsIdentity    <i class="conum" data-value="73"></i><b>(73)</b>


        print("To avoid waring: \(identity)")
    }

    func dontTestListenerConfigClientRootCA() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        // Authenticate using Cert Authority

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="74"></i><b>(74)</b>
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="75"></i><b>(75)</b> <i class="conum" data-value="76"></i><b>(76)</b>

    }

    func isValidCertificates(_ certs: [SecCertificate]) -&gt; Bool { return true }

    func dontTestClientAuthLambda() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        // Authenticate self-signed cert using application logic

        config.authenticator = ListenerCertificateAuthenticator { certs -&gt; Bool in <i class="conum" data-value="77"></i><b>(77)</b>
            // Validate the cert
            return self.isValidCertificates(certs)
        } <i class="conum" data-value="78"></i><b>(78)</b>

    }

    func dontTestListenerConfigUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        config.tlsIdentity = nil

        config.enableDeltaSync = true

        let totalConnections = self.listener.status.connectionCount
        let activeConnections = self.listener.status.activeConnectionCount

        self.listener.stop()

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

        config.authenticator = ListenerCertificateAuthenticator { self.isValidCertificates($0) }

        print("to avoid warnings: \(activeConnections)/\(totalConnections) ")
    }

    func dontTestURLEndpointListenerConstructor() throws {
        let enableTLS = Bool.random()
        let wssPort: UInt16 = 4985
        let wsPort: UInt16 = 4984
        let auth = ListenerPasswordAuthenticator { self.isValidCredentials($0, password: $1)}

        var config = URLEndpointListenerConfiguration.init(database: otherDB)
        config.port = enableTLS ? wssPort : wsPort
        config.disableTLS = !enableTLS
        config.authenticator = auth
        self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    func fMyActPeer() {

        guard let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB") else {
            fatalError("Invalid URL")
        }
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="79"></i><b>(79)</b>

        config.replicatorType = .pushAndPull

        // set auto-purge behavior (here we override default)
        config.enableAutoPurge = false <i class="conum" data-value="80"></i><b>(80)</b>

        // Configure Sync Mode
        config.continuous = true

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="81"></i><b>(81)</b>

        // Configure Client Security <i class="conum" data-value="82"></i><b>(82)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: "cbl-user-01",
                                                  password: "secret")

        /</strong> Optionally set custom conflict resolver call back
         config.conflictResolver = LocalWinConflictResolver()  <i class="conum" data-value="83"></i><b>(83)</b>
         <strong>/

        // Apply configuration settings to the replicator
        self.replicator = Replicator.init( config: config) <i class="conum" data-value="84"></i><b>(84)</b>

        // Optionally add a change listener
        // Retain token for use in deletion
        let token = self.replicator.addChangeListener { change in <i class="conum" data-value="85"></i><b>(85)</b>
            if change.status.activity == .stopped {
                print("Replication stopped")
            } else {
                print("Replicator is currently : \(self.replicator.status.activity)")
            }
        }

        // Run the replicator using the config settings
        self.replicator.start()  <i class="conum" data-value="86"></i><b>(86)</b>



        self.replicator.removeChangeListener(withToken: token)
    }


    func dontTestReplicatorStop() {
        let token = self.replicator.addChangeListener { change in }

        // Remove the change listener
        self.replicator.removeChangeListener(withToken: token)

        // Stop the replicator
        self.replicator.stop()

    }

    func dontTestAdditionalListenerConfigs() throws {
        let target = DatabaseEndpoint(database: otherDB)
        var config = ReplicatorConfiguration(database: database, target: target)
        let cert = self.listener.tlsIdentity!.certs[0]
        let validUsername = "cbl-user-01"
        let validPassword = "secret"
        // Configure Server Security -- only accept CA Certs
        config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="87"></i><b>(87)</b>

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="88"></i><b>(88)</b>

        // Return the remote pinned cert (the listener's cert)
        config.pinnedServerCertificate = cert // Get listener cert if pinned

        // Configure Client Security <i class="conum" data-value="89"></i><b>(89)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: validUsername, password: validPassword)


        // Check if Id exists in keychain and if so, use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") { <i class="conum" data-value="90"></i><b>(90)</b>
            print("An identity with label : doco-sync-server already exists in keychain")
            config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity) <i class="conum" data-value="91"></i><b>(91)</b>
        }

    }

    func myGetCert() throws -&gt; TLSIdentity? {
        var osStatus: OSStatus
        let target = DatabaseEndpoint(database: self.otherDB)
        var config = ReplicatorConfiguration(database: self.database, target: target)

        //var thisData : CFData?
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
            print("An identity with label : doco-sync-server already exists in keychain")
            return tlsIdentity
        }

        // FIXME: since old-p2p-tlsid-tlsidentity-with-label[] is removed, this code is not under any tag?
        guard let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") else {
            return nil
        }
        config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity)

        // CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let path = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
              let certData = NSData(contentsOfFile: path)
        else {
            return nil
        }

        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        var result : CFArray?
        osStatus = SecPKCS12Import(certData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;result)
        if osStatus != errSecSuccess {
            print("Failed to import data from provided with error :\(osStatus) ")
            return nil
        }
        let importedItems = result! as NSArray
        let item = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let secIdentity = item[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var privateKey : SecKey?
        osStatus = SecIdentityCopyPrivateKey(secIdentity, &amp;privateKey)
        if osStatus != errSecSuccess {
            print("Failed to import private key from provided with error :\(osStatus) ")
            return nil
        }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let certChain = item[String(kSecImportItemCertChain)] as? [SecCertificate]


        // Return nil, if errors in key, certChain at this stage
        guard let privateKey = privateKey, let certChain = certChain else {
            return nil
        }

        // STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN
#if os(iOS)
        // For iOS, need to save the identity into the KeyChain.
        // Save or Update identity with a label so that it could be cleaned up easily
        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       privateKey
        ]
        osStatus = SecItemAdd(params as CFDictionary, nil)
        if osStatus != errSecSuccess {
            print("Unable to store private key")
            return nil
        }
        // Store all Certs for Id in Keychain:
        var i = 0;
        for cert in certChain {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
            ]
            osStatus = SecItemAdd(params as CFDictionary, nil)
            if osStatus != errSecSuccess {
                print("Unable to store certs")
                return nil
            }
            i=i+1
        }
#else
        let query: [String : Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0]
        ]

        let update: [String: Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0],
            String(kSecAttrLabel):      label
        ]

        osStatus = SecItemUpdate(query as CFDictionary, update as CFDictionary)
        if osStatus != errSecSuccess {
            print("Unable to update certs \(osStatus)")
            return nil
        }
#endif


        // RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
        return try TLSIdentity.identity(withIdentity: secIdentity, certs: [certChain[1]])
    }

    func dontTestDeleteIDFromKeychain() throws {

        try TLSIdentity.deleteIdentity(withLabel: "doco-sync-server")


    }

    func myCaCertPinned() {
        let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint)

        // Get bundled resource and read into localcert
        guard
            let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer"),
            let localCertificate:NSData = NSData(contentsOfFile: pathToCert)
        else { /</strong> process error <strong>/ return }

        // Create certificate
        // using its DER representation as a CFData
        guard
            let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
        else { /</strong> process error <strong>/  return }

        // Add <code>pinnedCert</code> and <code>acceptOnlySelfSignedServerCertificate=false</code>(by default)
        // to <code>ReplicatorConfiguration</code>
        config.pinnedServerCertificate = pinnedCert

    }

    func dontTestOldListenerConfigClientRootCA() throws {
        // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="92"></i><b>(92)</b>
    }


    enum PeerConnectionStatus: UInt8 {
        case stopped = 0;
        case offline
        case connecting
        case idle
        case busy
    }

    func dontTestReplicationStart(_ peer: String,
                                  peerDBName: String,
                                  user: String?,
                                  pass: String?,
                                  handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) throws {
        guard let validUser = user, let validPassword = pass else {
            fatalError("UserCredentialsNotProvided")
            // ... take appropriate actions
        }

        var replicator = self.replicatorsToPeers[peer]

        if replicator == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(peerDBName)") else {
                fatalError("URLInvalid")
                // ... take appropriate actions
            }

            var config = ReplicatorConfiguration.init(database: self.database, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>


            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>


            config.authenticator = BasicAuthenticator(username: validUser, password: validPassword)

            replicator = Replicator.init(config: config)
            self.replicatorsToPeers[peer] = replicator

            let token = registerForEventsForReplicator(replicator!, handler: handler)
            self.replicatorListenerTokens[peer] = token

        }

        replicator?.start()
    }

    func registerForEventsForReplicator(_ replicator: Replicator,
                                        handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) -&gt; ListenerToken {
        return replicator.addChangeListener { change in
            guard change.status.error == nil else {
                handler(.stopped, change.status.error)
                return
            }

            switch change.status.activity {
            case .connecting:
                print("Replicator Connecting to Peer")
            case .idle:
                print("Replicator in Idle state")
            case .busy:
                print("Replicator in busy state")
            case .offline:
                print("Replicator in offline state")
            case .stopped:
                print("Replicator is stopped")
            }

            let progress = change.status.progress
            if progress.completed == progress.total {
                print("All documents synced")
            }
            else {
                print("Documents \(progress.total - progress.completed) still pending sync")
            }

            if let customStatus = PeerConnectionStatus(rawValue: change.status.activity.rawValue) {
                handler(customStatus, nil)
            }
        }
    }

    func startListener() {
        var messageEndpointListener: MessageEndpointListener!

        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)

        print(messageEndpointListener.connections.count)
    }
}

class MyClass {
    var database: Database!
    var replicator: Replicator! <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }
}


/</strong>

 &lt;.&gt; A replication is an asynchronous operation.
 To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
 &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
 You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.



 let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
 let targetEndpoint = URLEndpoint(url: tgtUrl)
 var config = ReplicatorConfiguration(database: database!, target: targetEndpoint) <i class="conum" data-value="93"></i><b>(93)</b>


 <strong>/

// MARK: -- Conflict Resolver Helpers

class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}

class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}

class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}

// MARK: -- PredictiveModel Helpers

// <code>myMLModel</code> is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] { return [:] }
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // <code>myMLModel</code> is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

// MARK: Prediction Model
class TestPredictiveModel: PredictiveModel {

    class var name: String {
        return "Untitled"
    }

    var numberOfCalls = 0

    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        numberOfCalls = numberOfCalls + 1
        return self.doPredict(input: input)
    }

    func doPredict(input: DictionaryObject) -&gt; DictionaryObject? {
        return nil
    }

    func registerModel() {
        Database.prediction.registerModel(self, withName: type(of: self).name)
    }

    func unregisterModel() {
        Database.prediction.unregisterModel(withName: type(of: self).name)
    }

    func reset() {
        numberOfCalls = 0
    }
}

// MARK: -- Custom Logger

class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    // constructor for easiness
    init(_ level: LogLevel) {
        self.level = level
    }

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }
}

struct Hotel: Codable {
    var id: String
    var type: String?
    var name: String?
    var city: String?
}

#if os(macOS)
import SystemConfiguration
// . . .

class SomeClass {
    func SomeFunction() {
        for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
            // do something with this <code>interface</code>
        }
    }

    // . . .
}

#endif

// MARK -- P2p

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        let database = try Database(name: "dbname")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)

        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        return connection
    }

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion()
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
    }

    func stopListener() {
        messageEndpointListener?.closeAll()
    }

    func acceptConnection() {
        let connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection: connection)
    }

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler */
        completion()
    }
}

public class Supporting_Datatypes
{

    func datatype_dictionary()
    {

        let database = try?Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database?.document(withID:"doc1");

        // Getting a dictionary from the document's properties
        let dict = document?.dictionary(forKey: "address");

        // Access a value with a key from the dictionary
        let street = dict?.string(forKey: "street");

        // Iterate dictionary
        for key in dict!.keys {
            print("Key \(key) = \(dict!.value(forKey:key))");
        }

        // Create a mutable copy
        let mutable_dict = dict?.toMutable();
    }

    func datatype_mutable_dictionary()
    {

        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        var mutable_dict = MutableDictionaryObject();
        mutable_dict.setString("1 Main st.", forKey: "street");
        mutable_dict.setString("San Francisco", forKey: "city");

        // Add the dictionary to a document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setDictionary(mutable_dict, forKey: "address");
        try!database.saveDocument(mutable_doc);

    }


    func datatype_array()
    {
        let database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database.document(withID:"doc1");

        // Getting a phones array from the document's properties
        let array = document?.array(forKey: "phones")

        // Get element count
        let count = array!.count;

        // Access an array element by index
        if count &gt;= 0 { let phone = array![1]; }

        // Iterate dictionary
        for (index, element) in array!.enumerated() {
            print("Index \(index) = \(element)");
        }

        // Create a mutable copy
        var mutable_array = array!.toMutable();

    }

    func datatype_mutable_array()
    {
        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        var mutable_array = MutableArrayObject();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

            // Set the array to document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setArray(mutable_array, forKey:"phones");
        try!database.saveDocument(mutable_doc);
    }

} // end class supporting_datatypes



// MARK: -- QUESTIONS

// FIXME: can we use the docsn site to show the interface of the Listener class?
// <a href="https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html" class="bare">https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html</a></code></pre>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create and populate a mutable array <code>phones</code></p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML

class SampleCodeTest {
    /<strong>
     For consistency in code snippets:
     1. we will use <code>self.database</code>/ <code>database</code> for database, query, replicator-db related code snippets.
     2. we will use <code>self.otherDB</code> / <code>otherDB</code> for listener-db
     <strong>/

    var database: Database!
    var otherDB: Database!

    /</strong>
     For consistency:
     1. we will use replicator with <code>self.replicator</code> and listener with <code>self.listener</code>
     */
    var replicator: Replicator!
    var listener: URLEndpointListener!

    var replicatorsToPeers = [String: Replicator]()
    var replicatorListenerTokens = [String: Any]()

    // MARK: Database

    func dontTestNewDatabase() throws {
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }

        do {
            try self.database.close()
        }
    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        self.database.EncryptionKey(
    }
#endif

    func dontTestLogging() throws {
        // verbose / replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // verbose / query
        Database.log.console.level = .verbose
        Database.log.console.domains = .query
    }

    func dontTestConsoleLogging() throws {
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>


        Database.log.console.domains = .database

    }

    func dontTestFileLogging() throws {
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
    }

    func dontTestEnableCustomLogging() throws {
        let logger = LogTestLogger(.warning)
        Database.log.custom =  logger <i class="conum" data-value="8"></i><b>(8)</b>
    }

    func dontTestLoadingPrebuilt() throws {
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
    }

    // MARK: Document

    func dontTestInitializer() throws {
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
    }

    func dontTestMutability() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
    }

    func dontTestTypedAcessors() throws {
        let newTask = MutableDocument()

        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")

        print(newTask.toDictionary())  <i class="conum" data-value="9"></i><b>(9)</b>


        print(newTask.toJSON()) <i class="conum" data-value="10"></i><b>(10)</b>


        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestChangeListener() throws {
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
    }

    func dontTestDocumentExpiration() throws {
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try database.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        print(query)
    }

    func dontTestBlob() throws {
#if TARGET_OS_IPHONE
        let newTask = MutableDocument()
        var image: UIImage!

        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)! <i class="conum" data-value="11"></i><b>(11)</b>

        let blob = Blob(contentType: "image/jpeg", data: imageData) <i class="conum" data-value="12"></i><b>(12)</b>
        newTask.setBlob(blob, forKey: "avatar") <i class="conum" data-value="13"></i><b>(13)</b>
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }

        print("\(image)")
#endif
    }

    // MARK: Query

    func dontTestQueryGetAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestIndexing() throws {
        // N1QL and Querybuilder versions
        let config = ValueIndexConfiguration(["type", "name"])
        try database.createIndex(index, withName: "TypeNameIndex")

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(Expression.property("type")),
                                            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
    }

    func dontTestSelectMeta() throws {
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
    }


    func dontTestSelectProps() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        
    }

    func dontTestSelectAll() throws {
        var query: Query

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="14"></i><b>(14)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="15"></i><b>(15)</b>
            for result in change.results! {
                print(result.keys)
                /</strong> Update UI <strong>/
            }
        } <i class="conum" data-value="16"></i><b>(16)</b>


        query.removeChangeListener(withToken: token) <i class="conum" data-value="17"></i><b>(17)</b>


        print("\(query)")
    }

    func dontTestWhere() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
    }

    func dontTestQueryDeletedDocuments() throws {
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.isDeleted)
        print(query)
    }

    func dontTestCollectionOperatorContains() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction.contains(Expression.property("public_likes"),
                                                value: Expression.string("Armani Langworth")))
            )

        do {
            for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
    }

    func dontTestCollectionOperatorIn() throws {
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
        ]

        let query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))

        print(query)
    }


    func dontTestLikeOperator() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="18"></i><b>(18)</b>
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX")))
            )

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
            )

        do {
            for result in try query.execute() {
                print("""
                    There are \(result.int(forKey: "$1")) airports on
                                the \(result.string(forKey: "tz")!)timezone located
                                in \(result.string(forKey: "country")!) and above 300 ft
                """)
            }
        }
    }

    func dontTestOrderBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))

        print("\(query)")
    }

    func dontTestExplainAll() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="19"></i><b>(19)</b>

        print(try query.explain()) <i class="conum" data-value="20"></i><b>(20)</b>
    }

    func dontTestExplainLike() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="21"></i><b>(21)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain())

    }

    func dontTestExplainNoOp() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="22"></i><b>(22)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain());

    }

    func dontTestExplainFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))) <i class="conum" data-value="23"></i><b>(23)</b>

        print(try query.explain());

    }

    func dontTestExplainNoFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="24"></i><b>(24)</b>

        print(try query.explain());

    }


    func dontTestCreateFullTextIndex() throws {
        // Insert documents
        let overviews = ["Handy for the nice beaches in Southport", "Close to Turnpike.", "By Michigan football's Big House"]
        for overview in overviews {
            let doc = MutableDocument()
            doc.setString("overview", forKey: "type")
            doc.setString(overview, forKey: "overview")
            try database.saveDocument(doc)
        }

        // Create index with N1QL
        do {
            let index = FullTextIndexConfiguration(["overview"])
            try database.createIndex(index, withName: "overviewFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestCreateFullTextIndex_Querybuilder() throws {

        // Create index with Querybuilder
        let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("overview")).ignoreAccents(false)
        try database.createIndex(index, withName: "overviewFTSIndex")
    }


    func dontTestFullTextSearch() throws {

        let ftsStr = "SELECT Meta().id FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)"

        let query = database.createQuery(query: ftsStr)

        let rs = try query.execute()
        for result in rs {
            print("document id \(result.string(at: 0)!)")
        }

    }



    func dontTestFullTextSearch_Querybuilder() throws {
        database = self.db

        let whereClause = FullTextFunction.match(indexName: "overviewFTSIndex"), query: "'michigan'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        for result in try query.execute() {
            print("document id \(result.string(at: 0)!)")
        }


    // MARK: toJSON

    func dontTestToJsonArrayObject() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="25"></i><b>(25)</b>
            guard let array = doc.array(forKey: "list") else {
                return
            }

            let json = array.toJSON() <i class="conum" data-value="26"></i><b>(26)</b>
            print(json)
        }
    }

    func dontTestToJsonDictionary() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="27"></i><b>(27)</b>
            guard let dictionary = doc.dictionary(forKey: "dictionary") else {
                return
            }

            let json = dictionary.toJSON() <i class="conum" data-value="28"></i><b>(28)</b>
            print(json)
        }
    }

    func dontTestToJsonDocument() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "doc-id") {
            let json = doc.toJSON()
            print(json)
        }
    }

    func dontTestQueryResultToJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))

        // demonstrate use of JSON string
        let resultSet = try query.execute()
        for result in resultSet {
            let json = result.toJSON()
            print(json)
        }
    }

    func dontTestBlobToJSON() throws {
        // Get a document
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="29"></i><b>(29)</b>
            guard let blob = doc.blob(forKey: "avatar") else {
                return
            }

            let json = blob.toJSON() <i class="conum" data-value="30"></i><b>(30)</b>
            print(json)
        }

        // FIXME: check below function to validate whether the given property dictionary is a valid blob or not
    }

    func dontTestIsBlob() throws {
        let digest = ""

        // tag::[dictionary-isblob]
        if(Blob.isBlob(properties: [Blob.typeProperty: Blob.blobType,
                                    Blob.blobDigestProperty: digest])) { <i class="conum" data-value="31"></i><b>(31)</b>
            print("Yes! I am a blob");
        }
        // end::[dictionary-isblob]
    }
    // -- !!!

    // MARK: Replication

    /</strong> The <code>tag::replication[]</code> example is inlined in swift.adoc <strong>/

    func dontTestEnableReplicatorLogging() throws {
        // Verbose / Replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // Verbose / Network
        Database.log.console.level = .verbose
        Database.log.console.domains = .network
    }

    func dontTestReplicationBasicAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationSessionAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicatorStatus() throws {
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
    }

    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {

        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        let myDocIDs = try self.replicator.pendingDocumentIds() <i class="conum" data-value="32"></i><b>(32)</b>

        if(!myDocIDs.isEmpty) {
            print("There are \(myDocIDs.count) documents pending")
            let thisID = myDocIDs.first!

            self.replicator.addChangeListener { (change) in
                print("Replicator activity level is \(change.status.activity)")
                do {
                    let isPending = try self.replicator.isDocumentPending(thisID)
                    if(!isPending) { <i class="conum" data-value="33"></i><b>(33)</b>
                        print("Doc ID \(thisID) now pushed")
                    }
                } catch {
                    print(error)
                }
            }

            self.replicator.start()
        }
    }

    //  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()

        self.replicator.removeChangeListener(withToken: token)
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
    }

    func dontTestHandlingReplicationError() throws {
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
    }

    func dontTestReplicationResetCheckpoint() throws {
        let doResetCheckpointRequired = Bool.random()


        if doResetCheckpointRequired {
            self.replicator.start(reset: true)  <i class="conum" data-value="34"></i><b>(34)</b>
        } else {
            self.replicator.start()
        }

    }

    func dontTestReplicationPushFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationPullFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    //  Added 2/Feb/21 - Ian Bridge
    //  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        let target = URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        var config =  ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = true
        config.heartbeat = 150 <i class="conum" data-value="35"></i><b>(35)</b>

        config.maxAttempts = 20 <i class="conum" data-value="36"></i><b>(36)</b>

        config.maxAttemptWaitTime = 600 <i class="conum" data-value="37"></i><b>(37)</b>
        self.replicator = Replicator(config: config)

    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /</strong> EE feature: code below might throw a compilation error
         if it's compiled against CBL Swift Community. <strong>/
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()

        try database2.delete()
    }
#endif

    func dontTestCertificatePinning() throws {

        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        var replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")

        Database.prediction.unregisterModel(withName: "ImageClassifier")
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                    .and(
                        prediction.property("probablity")
                            .greaterThanOrEqualTo(Expression.double(0.8))
                    )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
    }

    func dontTestCoreMLPredictiveModel() throws {
        // Load MLModel from <code>ImageClassifier.mlmodel</code>
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
    }

    func dontTestReplicatorConflictResolver() throws {
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestSaveWithConflictHandler() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, <em>) in first })
            new.setData(result)
            return true
        })

    }

    // helper
    func isValidCredentials(</em> u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { (username, password) -&gt; Bool in
            return self.isValidCredentials(username, password: password)
        })

    }

    func dontTestListenerStart() throws {
        try listener.start()

    }

    func dontTestListenerStop() throws {
        listener.stop()

    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
        try TLSIdentity.createIdentity(forServer: true,
                                       attributes: attrs,
                                       expiration: Date().addingTimeInterval(86400),
                                       label: "Server-Cert-Label")
        print("\(identity.expiration)") // to avoid warning
    }

    // MARK: -- URLEndpointListener
    func dontTestTLSIdentityCreate() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-server-cert-label");
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: "couchbaselite-server-cert-label")
        print(identity)
    }

    func dontTestDeleteIdentity() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-client-cert-label")
    }

    func dontTestImportTLSIdentity() throws {

        let path = Bundle.main.path(forResource: "identity/client", ofType: "p12")
        let clientCertData = try NSData(contentsOfFile: path!, options: []) as Data
        let identity = try TLSIdentity.importIdentity(withData: clientCertData,
                                                      password: "123",
                                                      label: "couchbaselite-client-cert-label")
        print(identity)
    }

    // MARK: -- QUERY RESULT SET HANDLING EXAMPLES

    func donTestQuerySyntaxAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))


        print(query)
    }

    func dontTestQueryAccessAll() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Any]()

        let results = try query.execute()
        for row in results {
            let docsProps = row.dictionary(at: 0)! <i class="conum" data-value="38"></i><b>(38)</b>

            let docid = docsProps.string(forKey: "id")
            let name = docsProps.string(forKey: "name")
            let type = docsProps.string(forKey: "type")
            let city = docsProps.string(forKey: "city")

            print("\(docid): \(name), \(type), \(city)")
            let hotel = row.dictionary(at: 0)!  <i class="conum" data-value="39"></i><b>(39)</b>
            guard let hotelId = hotel.string(forKey: "id") else {
                continue
            }

            hotels[hotelId] = hotel
        }

    }



    func dontTestQueryAccessJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String:Hotel]()

        // In this example the Hotel class is defined using Codable
        //
        // class Hotel : Codable {
        //   var id : String = "undefined"
        //   var type : String = "hotel"
        //   var name : String = "undefined"
        //   var city : String = "undefined"
        //   var country : String = "undefined"
        //   var description : String? = ""
        //   var text : String? = ""
        //   ... other class content
        // }

        let results = try query.execute()
        for row in  results {

            // get the result into a JSON String
            let jsonString = row.toJSON() <i class="conum" data-value="40"></i><b>(40)</b>

            let thisJsonObj:Dictionary =
            try (JSONSerialization.jsonObject(
                with: jsonString.data(using: .utf8)!,
                options: .allowFragments)
                 as? [String: Any])! <i class="conum" data-value="41"></i><b>(41)</b>

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="42"></i><b>(42)</b>

            // ALTERNATIVELY unpack in steps
            this_hotel.id = thisJsonObj["id"] as! String
            this_hotel.name = thisJsonObj["name"] as! String
            this_hotel.type = thisJsonObj["type"] as! String
            this_hotel.city = thisJsonObj["city"] as! String
            hotels[this_hotel.id] = this_hotel

        } // end for

    }

    func dontTestQuerySyntaxProps() throws {
        let database = try! Database(name: "hotel")

        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestQueryAccessProps () throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Hotel]()

        for result in try! query.execute() {
            let docID = result.string(forKey: "metaId")!
            print("processing doc: \(docID)")

            let id = result.string(forKey: "id")!
            var hotel = Hotel(id: id)
            hotel.name = result.string(forKey: "name")
            hotel.city = result.string(forKey: "city")
            hotel.type = result.string(forKey: "type")
            hotels[id] = hotel
        } // end for

    }// end func

    func dontTestQueryCount() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
            .from (DataSource.database(database)).groupBy(Expression.property("type"))


        for result in try query.execute() {
            let count = result.int(forKey: "mycount") <i class="conum" data-value="43"></i><b>(43)</b>
            print("There are ", count, " rows")
        }
    }

    func dontTestQueryId () throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))



        let results = try query.execute()
        for result in results {

            print(result.toDictionary())

            let docId = result.string(forKey: "metaId")! <i class="conum" data-value="44"></i><b>(44)</b>
            print("Document Id is -- \(docId)")

            // Now you can get the document using the ID
            let doc = database.document(withID: docId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")


        }
    }

    func query_pagination () throws {
        let offset = 0;
        let limit = 20;
        //
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .limit(Expression.int(limit), offset: Expression.int(offset))

        print(query)
    }

    func dontTestQueryN1QL() throws {

        let database = try Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = 'hotel'") <i class="conum" data-value="45"></i><b>(45)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestQueryN1QLparams() throws {

        let database = try! Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = $type") <i class="conum" data-value="46"></i><b>(46)</b>

        query.parameters = Parameters().setString("hotel", forName: "type") <i class="conum" data-value="47"></i><b>(47)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestProcessResults(results: ResultSet) throws {

        for row in results {
            print(row["thisId"].string!)

            let docsId = row["thisId"].string!

            // Now you can get the document using the ID
            let doc = database.document(withID: docsId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")

        }

    }

    // MARK: -- Listener

    func dontTestListenerSimple() throws {
        let database = try Database(name: "database")
        var config = URLEndpointListenerConfiguration(database: database) <i class="conum" data-value="48"></i><b>(48)</b>
        config.authenticator = ListenerPasswordAuthenticator { username, password in
            return "valid.user" == username &amp;&amp; "valid.password.string" == String(password)
        } <i class="conum" data-value="49"></i><b>(49)</b>

        let listener = URLEndpointListener(config: config) <i class="conum" data-value="50"></i><b>(50)</b>

        try listener.start()  <i class="conum" data-value="51"></i><b>(51)</b>

    }

    func dontTestListenerInitialize() throws {
        let otherDB = try Database(name: "otherDB")

        var config = URLEndpointListenerConfiguration(database: otherDB) <i class="conum" data-value="52"></i><b>(52)</b>

        /</strong> optionally <strong>/ let wsPort: UInt16 = 55991
        /</strong> optionally <strong>/ let wssPort: UInt16 = 55990
        config.port =  wssPort <i class="conum" data-value="53"></i><b>(53)</b>

        config.networkInterface = "10.1.1.10"  <i class="conum" data-value="54"></i><b>(54)</b>

        config.enableDeltaSync = true <i class="conum" data-value="55"></i><b>(55)</b>

        config.disableTLS  = false <i class="conum" data-value="56"></i><b>(56)</b>

        // Set the credentials the server presents the client
        // Use an anonymous self-signed cert
        config.tlsIdentity = nil <i class="conum" data-value="57"></i><b>(57)</b>

        // Configure how the client is to be authenticated
        // Here, use Basic Authentication
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { uname, pword -&gt; Bool in
            return self.isValidCredentials(uname, password: pword)
        }) <i class="conum" data-value="58"></i><b>(58)</b>


        // Initialize the listener
        self.listener = URLEndpointListener(config: config) <i class="conum" data-value="59"></i><b>(59)</b>
        if self.listener == nil {
            fatalError("ListenerError Not Initialized")
            // ... take appropriate actions
        }

        // Start the listener
        try self.listener.start() <i class="conum" data-value="60"></i><b>(60)</b>


        print(wsPort)
    }

    func dontTestReplicatorSimple() throws {

        let tgtUrl = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="61"></i><b>(61)</b>

        var thisConfig = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="62"></i><b>(62)</b>

        thisConfig.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="63"></i><b>(63)</b>

        let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
        thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="64"></i><b>(64)</b>

        self.replicator = Replicator(config: thisConfig) <i class="conum" data-value="65"></i><b>(65)</b>

        self.replicator.start(); <i class="conum" data-value="66"></i><b>(66)</b>

    }


    // MARK: Append

    func dontTestGetURLList() throws {
        let config = URLEndpointListenerConfiguration(database: otherDB)
        let listener = URLEndpointListener(config: config)
        try listener.start()

        if let urls = listener.urls {
            print("URLs are: \(urls)")
        }

    }


    func dontTestListenerConfigDisableTLSUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.disableTLS  = false <i class="conum" data-value="67"></i><b>(67)</b>

        config.disableTLS  = true <i class="conum" data-value="68"></i><b>(68)</b>

    }

    func dontTestListenerConfigTLSIdentity() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        guard let path = Bundle.main.path(forResource: "cert", ofType: "p12") else {
            /</strong> process error <strong>/ return
        }

        guard let certData = try? NSData(contentsOfFile: path) as Data else {
            /</strong> process error <strong>/ return
        } <i class="conum" data-value="69"></i><b>(69)</b>

        let tlsIdentity = try TLSIdentity.importIdentity(withData: certData,
                                                         password: "123",
                                                         label: "Server-Cert-Label") <i class="conum" data-value="70"></i><b>(70)</b>

        let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="71"></i><b>(71)</b>

        let identity = try TLSIdentity.createIdentity(forServer: true, /</strong> isServer <strong>/
                                                      attributes: attrs,
                                                      expiration: Date().addingTimeInterval(86400),
                                                      label: "Server-Cert-Label") <i class="conum" data-value="72"></i><b>(72)</b>

        // Set the credentials the server presents the client
        config.tlsIdentity = tlsIdentity    <i class="conum" data-value="73"></i><b>(73)</b>


        print("To avoid waring: \(identity)")
    }

    func dontTestListenerConfigClientRootCA() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        // Authenticate using Cert Authority

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="74"></i><b>(74)</b>
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="75"></i><b>(75)</b> <i class="conum" data-value="76"></i><b>(76)</b>

    }

    func isValidCertificates(_ certs: [SecCertificate]) -&gt; Bool { return true }

    func dontTestClientAuthLambda() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        // Authenticate self-signed cert using application logic

        config.authenticator = ListenerCertificateAuthenticator { certs -&gt; Bool in <i class="conum" data-value="77"></i><b>(77)</b>
            // Validate the cert
            return self.isValidCertificates(certs)
        } <i class="conum" data-value="78"></i><b>(78)</b>

    }

    func dontTestListenerConfigUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        config.tlsIdentity = nil

        config.enableDeltaSync = true

        let totalConnections = self.listener.status.connectionCount
        let activeConnections = self.listener.status.activeConnectionCount

        self.listener.stop()

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

        config.authenticator = ListenerCertificateAuthenticator { self.isValidCertificates($0) }

        print("to avoid warnings: \(activeConnections)/\(totalConnections) ")
    }

    func dontTestURLEndpointListenerConstructor() throws {
        let enableTLS = Bool.random()
        let wssPort: UInt16 = 4985
        let wsPort: UInt16 = 4984
        let auth = ListenerPasswordAuthenticator { self.isValidCredentials($0, password: $1)}

        var config = URLEndpointListenerConfiguration.init(database: otherDB)
        config.port = enableTLS ? wssPort : wsPort
        config.disableTLS = !enableTLS
        config.authenticator = auth
        self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    func fMyActPeer() {

        guard let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB") else {
            fatalError("Invalid URL")
        }
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="79"></i><b>(79)</b>

        config.replicatorType = .pushAndPull

        // set auto-purge behavior (here we override default)
        config.enableAutoPurge = false <i class="conum" data-value="80"></i><b>(80)</b>

        // Configure Sync Mode
        config.continuous = true

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="81"></i><b>(81)</b>

        // Configure Client Security <i class="conum" data-value="82"></i><b>(82)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: "cbl-user-01",
                                                  password: "secret")

        /</strong> Optionally set custom conflict resolver call back
         config.conflictResolver = LocalWinConflictResolver()  <i class="conum" data-value="83"></i><b>(83)</b>
         <strong>/

        // Apply configuration settings to the replicator
        self.replicator = Replicator.init( config: config) <i class="conum" data-value="84"></i><b>(84)</b>

        // Optionally add a change listener
        // Retain token for use in deletion
        let token = self.replicator.addChangeListener { change in <i class="conum" data-value="85"></i><b>(85)</b>
            if change.status.activity == .stopped {
                print("Replication stopped")
            } else {
                print("Replicator is currently : \(self.replicator.status.activity)")
            }
        }

        // Run the replicator using the config settings
        self.replicator.start()  <i class="conum" data-value="86"></i><b>(86)</b>



        self.replicator.removeChangeListener(withToken: token)
    }


    func dontTestReplicatorStop() {
        let token = self.replicator.addChangeListener { change in }

        // Remove the change listener
        self.replicator.removeChangeListener(withToken: token)

        // Stop the replicator
        self.replicator.stop()

    }

    func dontTestAdditionalListenerConfigs() throws {
        let target = DatabaseEndpoint(database: otherDB)
        var config = ReplicatorConfiguration(database: database, target: target)
        let cert = self.listener.tlsIdentity!.certs[0]
        let validUsername = "cbl-user-01"
        let validPassword = "secret"
        // Configure Server Security -- only accept CA Certs
        config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="87"></i><b>(87)</b>

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="88"></i><b>(88)</b>

        // Return the remote pinned cert (the listener's cert)
        config.pinnedServerCertificate = cert // Get listener cert if pinned

        // Configure Client Security <i class="conum" data-value="89"></i><b>(89)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: validUsername, password: validPassword)


        // Check if Id exists in keychain and if so, use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") { <i class="conum" data-value="90"></i><b>(90)</b>
            print("An identity with label : doco-sync-server already exists in keychain")
            config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity) <i class="conum" data-value="91"></i><b>(91)</b>
        }

    }

    func myGetCert() throws -&gt; TLSIdentity? {
        var osStatus: OSStatus
        let target = DatabaseEndpoint(database: self.otherDB)
        var config = ReplicatorConfiguration(database: self.database, target: target)

        //var thisData : CFData?
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
            print("An identity with label : doco-sync-server already exists in keychain")
            return tlsIdentity
        }

        // FIXME: since old-p2p-tlsid-tlsidentity-with-label[] is removed, this code is not under any tag?
        guard let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") else {
            return nil
        }
        config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity)

        // CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let path = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
              let certData = NSData(contentsOfFile: path)
        else {
            return nil
        }

        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        var result : CFArray?
        osStatus = SecPKCS12Import(certData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;result)
        if osStatus != errSecSuccess {
            print("Failed to import data from provided with error :\(osStatus) ")
            return nil
        }
        let importedItems = result! as NSArray
        let item = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let secIdentity = item[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var privateKey : SecKey?
        osStatus = SecIdentityCopyPrivateKey(secIdentity, &amp;privateKey)
        if osStatus != errSecSuccess {
            print("Failed to import private key from provided with error :\(osStatus) ")
            return nil
        }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let certChain = item[String(kSecImportItemCertChain)] as? [SecCertificate]


        // Return nil, if errors in key, certChain at this stage
        guard let privateKey = privateKey, let certChain = certChain else {
            return nil
        }

        // STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN
#if os(iOS)
        // For iOS, need to save the identity into the KeyChain.
        // Save or Update identity with a label so that it could be cleaned up easily
        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       privateKey
        ]
        osStatus = SecItemAdd(params as CFDictionary, nil)
        if osStatus != errSecSuccess {
            print("Unable to store private key")
            return nil
        }
        // Store all Certs for Id in Keychain:
        var i = 0;
        for cert in certChain {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
            ]
            osStatus = SecItemAdd(params as CFDictionary, nil)
            if osStatus != errSecSuccess {
                print("Unable to store certs")
                return nil
            }
            i=i+1
        }
#else
        let query: [String : Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0]
        ]

        let update: [String: Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0],
            String(kSecAttrLabel):      label
        ]

        osStatus = SecItemUpdate(query as CFDictionary, update as CFDictionary)
        if osStatus != errSecSuccess {
            print("Unable to update certs \(osStatus)")
            return nil
        }
#endif


        // RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
        return try TLSIdentity.identity(withIdentity: secIdentity, certs: [certChain[1]])
    }

    func dontTestDeleteIDFromKeychain() throws {

        try TLSIdentity.deleteIdentity(withLabel: "doco-sync-server")


    }

    func myCaCertPinned() {
        let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint)

        // Get bundled resource and read into localcert
        guard
            let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer"),
            let localCertificate:NSData = NSData(contentsOfFile: pathToCert)
        else { /</strong> process error <strong>/ return }

        // Create certificate
        // using its DER representation as a CFData
        guard
            let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
        else { /</strong> process error <strong>/  return }

        // Add <code>pinnedCert</code> and <code>acceptOnlySelfSignedServerCertificate=false</code>(by default)
        // to <code>ReplicatorConfiguration</code>
        config.pinnedServerCertificate = pinnedCert

    }

    func dontTestOldListenerConfigClientRootCA() throws {
        // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="92"></i><b>(92)</b>
    }


    enum PeerConnectionStatus: UInt8 {
        case stopped = 0;
        case offline
        case connecting
        case idle
        case busy
    }

    func dontTestReplicationStart(_ peer: String,
                                  peerDBName: String,
                                  user: String?,
                                  pass: String?,
                                  handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) throws {
        guard let validUser = user, let validPassword = pass else {
            fatalError("UserCredentialsNotProvided")
            // ... take appropriate actions
        }

        var replicator = self.replicatorsToPeers[peer]

        if replicator == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(peerDBName)") else {
                fatalError("URLInvalid")
                // ... take appropriate actions
            }

            var config = ReplicatorConfiguration.init(database: self.database, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>


            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>


            config.authenticator = BasicAuthenticator(username: validUser, password: validPassword)

            replicator = Replicator.init(config: config)
            self.replicatorsToPeers[peer] = replicator

            let token = registerForEventsForReplicator(replicator!, handler: handler)
            self.replicatorListenerTokens[peer] = token

        }

        replicator?.start()
    }

    func registerForEventsForReplicator(_ replicator: Replicator,
                                        handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) -&gt; ListenerToken {
        return replicator.addChangeListener { change in
            guard change.status.error == nil else {
                handler(.stopped, change.status.error)
                return
            }

            switch change.status.activity {
            case .connecting:
                print("Replicator Connecting to Peer")
            case .idle:
                print("Replicator in Idle state")
            case .busy:
                print("Replicator in busy state")
            case .offline:
                print("Replicator in offline state")
            case .stopped:
                print("Replicator is stopped")
            }

            let progress = change.status.progress
            if progress.completed == progress.total {
                print("All documents synced")
            }
            else {
                print("Documents \(progress.total - progress.completed) still pending sync")
            }

            if let customStatus = PeerConnectionStatus(rawValue: change.status.activity.rawValue) {
                handler(customStatus, nil)
            }
        }
    }

    func startListener() {
        var messageEndpointListener: MessageEndpointListener!

        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)

        print(messageEndpointListener.connections.count)
    }
}

class MyClass {
    var database: Database!
    var replicator: Replicator! <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }
}


/</strong>

 &lt;.&gt; A replication is an asynchronous operation.
 To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
 &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
 You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.



 let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
 let targetEndpoint = URLEndpoint(url: tgtUrl)
 var config = ReplicatorConfiguration(database: database!, target: targetEndpoint) <i class="conum" data-value="93"></i><b>(93)</b>


 <strong>/

// MARK: -- Conflict Resolver Helpers

class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}

class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}

class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}

// MARK: -- PredictiveModel Helpers

// <code>myMLModel</code> is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] { return [:] }
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // <code>myMLModel</code> is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

// MARK: Prediction Model
class TestPredictiveModel: PredictiveModel {

    class var name: String {
        return "Untitled"
    }

    var numberOfCalls = 0

    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        numberOfCalls = numberOfCalls + 1
        return self.doPredict(input: input)
    }

    func doPredict(input: DictionaryObject) -&gt; DictionaryObject? {
        return nil
    }

    func registerModel() {
        Database.prediction.registerModel(self, withName: type(of: self).name)
    }

    func unregisterModel() {
        Database.prediction.unregisterModel(withName: type(of: self).name)
    }

    func reset() {
        numberOfCalls = 0
    }
}

// MARK: -- Custom Logger

class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    // constructor for easiness
    init(_ level: LogLevel) {
        self.level = level
    }

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }
}

struct Hotel: Codable {
    var id: String
    var type: String?
    var name: String?
    var city: String?
}

#if os(macOS)
import SystemConfiguration
// . . .

class SomeClass {
    func SomeFunction() {
        for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
            // do something with this <code>interface</code>
        }
    }

    // . . .
}

#endif

// MARK -- P2p

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        let database = try Database(name: "dbname")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)

        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        return connection
    }

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion()
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
    }

    func stopListener() {
        messageEndpointListener?.closeAll()
    }

    func acceptConnection() {
        let connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection: connection)
    }

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler */
        completion()
    }
}

public class Supporting_Datatypes
{

    func datatype_dictionary()
    {

        let database = try?Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database?.document(withID:"doc1");

        // Getting a dictionary from the document's properties
        let dict = document?.dictionary(forKey: "address");

        // Access a value with a key from the dictionary
        let street = dict?.string(forKey: "street");

        // Iterate dictionary
        for key in dict!.keys {
            print("Key \(key) = \(dict!.value(forKey:key))");
        }

        // Create a mutable copy
        let mutable_dict = dict?.toMutable();
    }

    func datatype_mutable_dictionary()
    {

        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        var mutable_dict = MutableDictionaryObject();
        mutable_dict.setString("1 Main st.", forKey: "street");
        mutable_dict.setString("San Francisco", forKey: "city");

        // Add the dictionary to a document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setDictionary(mutable_dict, forKey: "address");
        try!database.saveDocument(mutable_doc);

    }


    func datatype_array()
    {
        let database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database.document(withID:"doc1");

        // Getting a phones array from the document's properties
        let array = document?.array(forKey: "phones")

        // Get element count
        let count = array!.count;

        // Access an array element by index
        if count &gt;= 0 { let phone = array![1]; }

        // Iterate dictionary
        for (index, element) in array!.enumerated() {
            print("Index \(index) = \(element)");
        }

        // Create a mutable copy
        var mutable_array = array!.toMutable();

    }

    func datatype_mutable_array()
    {
        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        var mutable_array = MutableArrayObject();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

            // Set the array to document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setArray(mutable_array, forKey:"phones");
        try!database.saveDocument(mutable_doc);
    }

} // end class supporting_datatypes



// MARK: -- QUESTIONS

// FIXME: can we use the docsn site to show the interface of the Listener class?
// <a href="https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html" class="bare">https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html</a></code></pre>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Populate your hotel document</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML

class SampleCodeTest {
    /<strong>
     For consistency in code snippets:
     1. we will use <code>self.database</code>/ <code>database</code> for database, query, replicator-db related code snippets.
     2. we will use <code>self.otherDB</code> / <code>otherDB</code> for listener-db
     <strong>/

    var database: Database!
    var otherDB: Database!

    /</strong>
     For consistency:
     1. we will use replicator with <code>self.replicator</code> and listener with <code>self.listener</code>
     */
    var replicator: Replicator!
    var listener: URLEndpointListener!

    var replicatorsToPeers = [String: Replicator]()
    var replicatorListenerTokens = [String: Any]()

    // MARK: Database

    func dontTestNewDatabase() throws {
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }

        do {
            try self.database.close()
        }
    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        self.database.EncryptionKey(
    }
#endif

    func dontTestLogging() throws {
        // verbose / replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // verbose / query
        Database.log.console.level = .verbose
        Database.log.console.domains = .query
    }

    func dontTestConsoleLogging() throws {
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>


        Database.log.console.domains = .database

    }

    func dontTestFileLogging() throws {
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
    }

    func dontTestEnableCustomLogging() throws {
        let logger = LogTestLogger(.warning)
        Database.log.custom =  logger <i class="conum" data-value="8"></i><b>(8)</b>
    }

    func dontTestLoadingPrebuilt() throws {
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
    }

    // MARK: Document

    func dontTestInitializer() throws {
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
    }

    func dontTestMutability() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
    }

    func dontTestTypedAcessors() throws {
        let newTask = MutableDocument()

        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")

        print(newTask.toDictionary())  <i class="conum" data-value="9"></i><b>(9)</b>


        print(newTask.toJSON()) <i class="conum" data-value="10"></i><b>(10)</b>


        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestChangeListener() throws {
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
    }

    func dontTestDocumentExpiration() throws {
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try database.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        print(query)
    }

    func dontTestBlob() throws {
#if TARGET_OS_IPHONE
        let newTask = MutableDocument()
        var image: UIImage!

        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)! <i class="conum" data-value="11"></i><b>(11)</b>

        let blob = Blob(contentType: "image/jpeg", data: imageData) <i class="conum" data-value="12"></i><b>(12)</b>
        newTask.setBlob(blob, forKey: "avatar") <i class="conum" data-value="13"></i><b>(13)</b>
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }

        print("\(image)")
#endif
    }

    // MARK: Query

    func dontTestQueryGetAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestIndexing() throws {
        // N1QL and Querybuilder versions
        let config = ValueIndexConfiguration(["type", "name"])
        try database.createIndex(index, withName: "TypeNameIndex")

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(Expression.property("type")),
                                            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
    }

    func dontTestSelectMeta() throws {
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
    }


    func dontTestSelectProps() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        
    }

    func dontTestSelectAll() throws {
        var query: Query

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="14"></i><b>(14)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="15"></i><b>(15)</b>
            for result in change.results! {
                print(result.keys)
                /</strong> Update UI <strong>/
            }
        } <i class="conum" data-value="16"></i><b>(16)</b>


        query.removeChangeListener(withToken: token) <i class="conum" data-value="17"></i><b>(17)</b>


        print("\(query)")
    }

    func dontTestWhere() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
    }

    func dontTestQueryDeletedDocuments() throws {
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.isDeleted)
        print(query)
    }

    func dontTestCollectionOperatorContains() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction.contains(Expression.property("public_likes"),
                                                value: Expression.string("Armani Langworth")))
            )

        do {
            for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
    }

    func dontTestCollectionOperatorIn() throws {
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
        ]

        let query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))

        print(query)
    }


    func dontTestLikeOperator() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="18"></i><b>(18)</b>
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX")))
            )

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
            )

        do {
            for result in try query.execute() {
                print("""
                    There are \(result.int(forKey: "$1")) airports on
                                the \(result.string(forKey: "tz")!)timezone located
                                in \(result.string(forKey: "country")!) and above 300 ft
                """)
            }
        }
    }

    func dontTestOrderBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))

        print("\(query)")
    }

    func dontTestExplainAll() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="19"></i><b>(19)</b>

        print(try query.explain()) <i class="conum" data-value="20"></i><b>(20)</b>
    }

    func dontTestExplainLike() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="21"></i><b>(21)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain())

    }

    func dontTestExplainNoOp() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="22"></i><b>(22)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain());

    }

    func dontTestExplainFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))) <i class="conum" data-value="23"></i><b>(23)</b>

        print(try query.explain());

    }

    func dontTestExplainNoFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="24"></i><b>(24)</b>

        print(try query.explain());

    }


    func dontTestCreateFullTextIndex() throws {
        // Insert documents
        let overviews = ["Handy for the nice beaches in Southport", "Close to Turnpike.", "By Michigan football's Big House"]
        for overview in overviews {
            let doc = MutableDocument()
            doc.setString("overview", forKey: "type")
            doc.setString(overview, forKey: "overview")
            try database.saveDocument(doc)
        }

        // Create index with N1QL
        do {
            let index = FullTextIndexConfiguration(["overview"])
            try database.createIndex(index, withName: "overviewFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestCreateFullTextIndex_Querybuilder() throws {

        // Create index with Querybuilder
        let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("overview")).ignoreAccents(false)
        try database.createIndex(index, withName: "overviewFTSIndex")
    }


    func dontTestFullTextSearch() throws {

        let ftsStr = "SELECT Meta().id FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)"

        let query = database.createQuery(query: ftsStr)

        let rs = try query.execute()
        for result in rs {
            print("document id \(result.string(at: 0)!)")
        }

    }



    func dontTestFullTextSearch_Querybuilder() throws {
        database = self.db

        let whereClause = FullTextFunction.match(indexName: "overviewFTSIndex"), query: "'michigan'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        for result in try query.execute() {
            print("document id \(result.string(at: 0)!)")
        }


    // MARK: toJSON

    func dontTestToJsonArrayObject() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="25"></i><b>(25)</b>
            guard let array = doc.array(forKey: "list") else {
                return
            }

            let json = array.toJSON() <i class="conum" data-value="26"></i><b>(26)</b>
            print(json)
        }
    }

    func dontTestToJsonDictionary() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="27"></i><b>(27)</b>
            guard let dictionary = doc.dictionary(forKey: "dictionary") else {
                return
            }

            let json = dictionary.toJSON() <i class="conum" data-value="28"></i><b>(28)</b>
            print(json)
        }
    }

    func dontTestToJsonDocument() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "doc-id") {
            let json = doc.toJSON()
            print(json)
        }
    }

    func dontTestQueryResultToJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))

        // demonstrate use of JSON string
        let resultSet = try query.execute()
        for result in resultSet {
            let json = result.toJSON()
            print(json)
        }
    }

    func dontTestBlobToJSON() throws {
        // Get a document
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="29"></i><b>(29)</b>
            guard let blob = doc.blob(forKey: "avatar") else {
                return
            }

            let json = blob.toJSON() <i class="conum" data-value="30"></i><b>(30)</b>
            print(json)
        }

        // FIXME: check below function to validate whether the given property dictionary is a valid blob or not
    }

    func dontTestIsBlob() throws {
        let digest = ""

        // tag::[dictionary-isblob]
        if(Blob.isBlob(properties: [Blob.typeProperty: Blob.blobType,
                                    Blob.blobDigestProperty: digest])) { <i class="conum" data-value="31"></i><b>(31)</b>
            print("Yes! I am a blob");
        }
        // end::[dictionary-isblob]
    }
    // -- !!!

    // MARK: Replication

    /</strong> The <code>tag::replication[]</code> example is inlined in swift.adoc <strong>/

    func dontTestEnableReplicatorLogging() throws {
        // Verbose / Replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // Verbose / Network
        Database.log.console.level = .verbose
        Database.log.console.domains = .network
    }

    func dontTestReplicationBasicAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationSessionAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicatorStatus() throws {
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
    }

    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {

        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        let myDocIDs = try self.replicator.pendingDocumentIds() <i class="conum" data-value="32"></i><b>(32)</b>

        if(!myDocIDs.isEmpty) {
            print("There are \(myDocIDs.count) documents pending")
            let thisID = myDocIDs.first!

            self.replicator.addChangeListener { (change) in
                print("Replicator activity level is \(change.status.activity)")
                do {
                    let isPending = try self.replicator.isDocumentPending(thisID)
                    if(!isPending) { <i class="conum" data-value="33"></i><b>(33)</b>
                        print("Doc ID \(thisID) now pushed")
                    }
                } catch {
                    print(error)
                }
            }

            self.replicator.start()
        }
    }

    //  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()

        self.replicator.removeChangeListener(withToken: token)
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
    }

    func dontTestHandlingReplicationError() throws {
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
    }

    func dontTestReplicationResetCheckpoint() throws {
        let doResetCheckpointRequired = Bool.random()


        if doResetCheckpointRequired {
            self.replicator.start(reset: true)  <i class="conum" data-value="34"></i><b>(34)</b>
        } else {
            self.replicator.start()
        }

    }

    func dontTestReplicationPushFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationPullFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    //  Added 2/Feb/21 - Ian Bridge
    //  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        let target = URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        var config =  ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = true
        config.heartbeat = 150 <i class="conum" data-value="35"></i><b>(35)</b>

        config.maxAttempts = 20 <i class="conum" data-value="36"></i><b>(36)</b>

        config.maxAttemptWaitTime = 600 <i class="conum" data-value="37"></i><b>(37)</b>
        self.replicator = Replicator(config: config)

    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /</strong> EE feature: code below might throw a compilation error
         if it's compiled against CBL Swift Community. <strong>/
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()

        try database2.delete()
    }
#endif

    func dontTestCertificatePinning() throws {

        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        var replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")

        Database.prediction.unregisterModel(withName: "ImageClassifier")
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                    .and(
                        prediction.property("probablity")
                            .greaterThanOrEqualTo(Expression.double(0.8))
                    )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
    }

    func dontTestCoreMLPredictiveModel() throws {
        // Load MLModel from <code>ImageClassifier.mlmodel</code>
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
    }

    func dontTestReplicatorConflictResolver() throws {
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestSaveWithConflictHandler() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, <em>) in first })
            new.setData(result)
            return true
        })

    }

    // helper
    func isValidCredentials(</em> u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { (username, password) -&gt; Bool in
            return self.isValidCredentials(username, password: password)
        })

    }

    func dontTestListenerStart() throws {
        try listener.start()

    }

    func dontTestListenerStop() throws {
        listener.stop()

    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
        try TLSIdentity.createIdentity(forServer: true,
                                       attributes: attrs,
                                       expiration: Date().addingTimeInterval(86400),
                                       label: "Server-Cert-Label")
        print("\(identity.expiration)") // to avoid warning
    }

    // MARK: -- URLEndpointListener
    func dontTestTLSIdentityCreate() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-server-cert-label");
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: "couchbaselite-server-cert-label")
        print(identity)
    }

    func dontTestDeleteIdentity() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-client-cert-label")
    }

    func dontTestImportTLSIdentity() throws {

        let path = Bundle.main.path(forResource: "identity/client", ofType: "p12")
        let clientCertData = try NSData(contentsOfFile: path!, options: []) as Data
        let identity = try TLSIdentity.importIdentity(withData: clientCertData,
                                                      password: "123",
                                                      label: "couchbaselite-client-cert-label")
        print(identity)
    }

    // MARK: -- QUERY RESULT SET HANDLING EXAMPLES

    func donTestQuerySyntaxAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))


        print(query)
    }

    func dontTestQueryAccessAll() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Any]()

        let results = try query.execute()
        for row in results {
            let docsProps = row.dictionary(at: 0)! <i class="conum" data-value="38"></i><b>(38)</b>

            let docid = docsProps.string(forKey: "id")
            let name = docsProps.string(forKey: "name")
            let type = docsProps.string(forKey: "type")
            let city = docsProps.string(forKey: "city")

            print("\(docid): \(name), \(type), \(city)")
            let hotel = row.dictionary(at: 0)!  <i class="conum" data-value="39"></i><b>(39)</b>
            guard let hotelId = hotel.string(forKey: "id") else {
                continue
            }

            hotels[hotelId] = hotel
        }

    }



    func dontTestQueryAccessJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String:Hotel]()

        // In this example the Hotel class is defined using Codable
        //
        // class Hotel : Codable {
        //   var id : String = "undefined"
        //   var type : String = "hotel"
        //   var name : String = "undefined"
        //   var city : String = "undefined"
        //   var country : String = "undefined"
        //   var description : String? = ""
        //   var text : String? = ""
        //   ... other class content
        // }

        let results = try query.execute()
        for row in  results {

            // get the result into a JSON String
            let jsonString = row.toJSON() <i class="conum" data-value="40"></i><b>(40)</b>

            let thisJsonObj:Dictionary =
            try (JSONSerialization.jsonObject(
                with: jsonString.data(using: .utf8)!,
                options: .allowFragments)
                 as? [String: Any])! <i class="conum" data-value="41"></i><b>(41)</b>

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="42"></i><b>(42)</b>

            // ALTERNATIVELY unpack in steps
            this_hotel.id = thisJsonObj["id"] as! String
            this_hotel.name = thisJsonObj["name"] as! String
            this_hotel.type = thisJsonObj["type"] as! String
            this_hotel.city = thisJsonObj["city"] as! String
            hotels[this_hotel.id] = this_hotel

        } // end for

    }

    func dontTestQuerySyntaxProps() throws {
        let database = try! Database(name: "hotel")

        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestQueryAccessProps () throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Hotel]()

        for result in try! query.execute() {
            let docID = result.string(forKey: "metaId")!
            print("processing doc: \(docID)")

            let id = result.string(forKey: "id")!
            var hotel = Hotel(id: id)
            hotel.name = result.string(forKey: "name")
            hotel.city = result.string(forKey: "city")
            hotel.type = result.string(forKey: "type")
            hotels[id] = hotel
        } // end for

    }// end func

    func dontTestQueryCount() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
            .from (DataSource.database(database)).groupBy(Expression.property("type"))


        for result in try query.execute() {
            let count = result.int(forKey: "mycount") <i class="conum" data-value="43"></i><b>(43)</b>
            print("There are ", count, " rows")
        }
    }

    func dontTestQueryId () throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))



        let results = try query.execute()
        for result in results {

            print(result.toDictionary())

            let docId = result.string(forKey: "metaId")! <i class="conum" data-value="44"></i><b>(44)</b>
            print("Document Id is -- \(docId)")

            // Now you can get the document using the ID
            let doc = database.document(withID: docId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")


        }
    }

    func query_pagination () throws {
        let offset = 0;
        let limit = 20;
        //
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .limit(Expression.int(limit), offset: Expression.int(offset))

        print(query)
    }

    func dontTestQueryN1QL() throws {

        let database = try Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = 'hotel'") <i class="conum" data-value="45"></i><b>(45)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestQueryN1QLparams() throws {

        let database = try! Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = $type") <i class="conum" data-value="46"></i><b>(46)</b>

        query.parameters = Parameters().setString("hotel", forName: "type") <i class="conum" data-value="47"></i><b>(47)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestProcessResults(results: ResultSet) throws {

        for row in results {
            print(row["thisId"].string!)

            let docsId = row["thisId"].string!

            // Now you can get the document using the ID
            let doc = database.document(withID: docsId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")

        }

    }

    // MARK: -- Listener

    func dontTestListenerSimple() throws {
        let database = try Database(name: "database")
        var config = URLEndpointListenerConfiguration(database: database) <i class="conum" data-value="48"></i><b>(48)</b>
        config.authenticator = ListenerPasswordAuthenticator { username, password in
            return "valid.user" == username &amp;&amp; "valid.password.string" == String(password)
        } <i class="conum" data-value="49"></i><b>(49)</b>

        let listener = URLEndpointListener(config: config) <i class="conum" data-value="50"></i><b>(50)</b>

        try listener.start()  <i class="conum" data-value="51"></i><b>(51)</b>

    }

    func dontTestListenerInitialize() throws {
        let otherDB = try Database(name: "otherDB")

        var config = URLEndpointListenerConfiguration(database: otherDB) <i class="conum" data-value="52"></i><b>(52)</b>

        /</strong> optionally <strong>/ let wsPort: UInt16 = 55991
        /</strong> optionally <strong>/ let wssPort: UInt16 = 55990
        config.port =  wssPort <i class="conum" data-value="53"></i><b>(53)</b>

        config.networkInterface = "10.1.1.10"  <i class="conum" data-value="54"></i><b>(54)</b>

        config.enableDeltaSync = true <i class="conum" data-value="55"></i><b>(55)</b>

        config.disableTLS  = false <i class="conum" data-value="56"></i><b>(56)</b>

        // Set the credentials the server presents the client
        // Use an anonymous self-signed cert
        config.tlsIdentity = nil <i class="conum" data-value="57"></i><b>(57)</b>

        // Configure how the client is to be authenticated
        // Here, use Basic Authentication
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { uname, pword -&gt; Bool in
            return self.isValidCredentials(uname, password: pword)
        }) <i class="conum" data-value="58"></i><b>(58)</b>


        // Initialize the listener
        self.listener = URLEndpointListener(config: config) <i class="conum" data-value="59"></i><b>(59)</b>
        if self.listener == nil {
            fatalError("ListenerError Not Initialized")
            // ... take appropriate actions
        }

        // Start the listener
        try self.listener.start() <i class="conum" data-value="60"></i><b>(60)</b>


        print(wsPort)
    }

    func dontTestReplicatorSimple() throws {

        let tgtUrl = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="61"></i><b>(61)</b>

        var thisConfig = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="62"></i><b>(62)</b>

        thisConfig.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="63"></i><b>(63)</b>

        let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
        thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="64"></i><b>(64)</b>

        self.replicator = Replicator(config: thisConfig) <i class="conum" data-value="65"></i><b>(65)</b>

        self.replicator.start(); <i class="conum" data-value="66"></i><b>(66)</b>

    }


    // MARK: Append

    func dontTestGetURLList() throws {
        let config = URLEndpointListenerConfiguration(database: otherDB)
        let listener = URLEndpointListener(config: config)
        try listener.start()

        if let urls = listener.urls {
            print("URLs are: \(urls)")
        }

    }


    func dontTestListenerConfigDisableTLSUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.disableTLS  = false <i class="conum" data-value="67"></i><b>(67)</b>

        config.disableTLS  = true <i class="conum" data-value="68"></i><b>(68)</b>

    }

    func dontTestListenerConfigTLSIdentity() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        guard let path = Bundle.main.path(forResource: "cert", ofType: "p12") else {
            /</strong> process error <strong>/ return
        }

        guard let certData = try? NSData(contentsOfFile: path) as Data else {
            /</strong> process error <strong>/ return
        } <i class="conum" data-value="69"></i><b>(69)</b>

        let tlsIdentity = try TLSIdentity.importIdentity(withData: certData,
                                                         password: "123",
                                                         label: "Server-Cert-Label") <i class="conum" data-value="70"></i><b>(70)</b>

        let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="71"></i><b>(71)</b>

        let identity = try TLSIdentity.createIdentity(forServer: true, /</strong> isServer <strong>/
                                                      attributes: attrs,
                                                      expiration: Date().addingTimeInterval(86400),
                                                      label: "Server-Cert-Label") <i class="conum" data-value="72"></i><b>(72)</b>

        // Set the credentials the server presents the client
        config.tlsIdentity = tlsIdentity    <i class="conum" data-value="73"></i><b>(73)</b>


        print("To avoid waring: \(identity)")
    }

    func dontTestListenerConfigClientRootCA() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        // Authenticate using Cert Authority

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="74"></i><b>(74)</b>
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="75"></i><b>(75)</b> <i class="conum" data-value="76"></i><b>(76)</b>

    }

    func isValidCertificates(_ certs: [SecCertificate]) -&gt; Bool { return true }

    func dontTestClientAuthLambda() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        // Authenticate self-signed cert using application logic

        config.authenticator = ListenerCertificateAuthenticator { certs -&gt; Bool in <i class="conum" data-value="77"></i><b>(77)</b>
            // Validate the cert
            return self.isValidCertificates(certs)
        } <i class="conum" data-value="78"></i><b>(78)</b>

    }

    func dontTestListenerConfigUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        config.tlsIdentity = nil

        config.enableDeltaSync = true

        let totalConnections = self.listener.status.connectionCount
        let activeConnections = self.listener.status.activeConnectionCount

        self.listener.stop()

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

        config.authenticator = ListenerCertificateAuthenticator { self.isValidCertificates($0) }

        print("to avoid warnings: \(activeConnections)/\(totalConnections) ")
    }

    func dontTestURLEndpointListenerConstructor() throws {
        let enableTLS = Bool.random()
        let wssPort: UInt16 = 4985
        let wsPort: UInt16 = 4984
        let auth = ListenerPasswordAuthenticator { self.isValidCredentials($0, password: $1)}

        var config = URLEndpointListenerConfiguration.init(database: otherDB)
        config.port = enableTLS ? wssPort : wsPort
        config.disableTLS = !enableTLS
        config.authenticator = auth
        self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    func fMyActPeer() {

        guard let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB") else {
            fatalError("Invalid URL")
        }
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="79"></i><b>(79)</b>

        config.replicatorType = .pushAndPull

        // set auto-purge behavior (here we override default)
        config.enableAutoPurge = false <i class="conum" data-value="80"></i><b>(80)</b>

        // Configure Sync Mode
        config.continuous = true

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="81"></i><b>(81)</b>

        // Configure Client Security <i class="conum" data-value="82"></i><b>(82)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: "cbl-user-01",
                                                  password: "secret")

        /</strong> Optionally set custom conflict resolver call back
         config.conflictResolver = LocalWinConflictResolver()  <i class="conum" data-value="83"></i><b>(83)</b>
         <strong>/

        // Apply configuration settings to the replicator
        self.replicator = Replicator.init( config: config) <i class="conum" data-value="84"></i><b>(84)</b>

        // Optionally add a change listener
        // Retain token for use in deletion
        let token = self.replicator.addChangeListener { change in <i class="conum" data-value="85"></i><b>(85)</b>
            if change.status.activity == .stopped {
                print("Replication stopped")
            } else {
                print("Replicator is currently : \(self.replicator.status.activity)")
            }
        }

        // Run the replicator using the config settings
        self.replicator.start()  <i class="conum" data-value="86"></i><b>(86)</b>



        self.replicator.removeChangeListener(withToken: token)
    }


    func dontTestReplicatorStop() {
        let token = self.replicator.addChangeListener { change in }

        // Remove the change listener
        self.replicator.removeChangeListener(withToken: token)

        // Stop the replicator
        self.replicator.stop()

    }

    func dontTestAdditionalListenerConfigs() throws {
        let target = DatabaseEndpoint(database: otherDB)
        var config = ReplicatorConfiguration(database: database, target: target)
        let cert = self.listener.tlsIdentity!.certs[0]
        let validUsername = "cbl-user-01"
        let validPassword = "secret"
        // Configure Server Security -- only accept CA Certs
        config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="87"></i><b>(87)</b>

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="88"></i><b>(88)</b>

        // Return the remote pinned cert (the listener's cert)
        config.pinnedServerCertificate = cert // Get listener cert if pinned

        // Configure Client Security <i class="conum" data-value="89"></i><b>(89)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: validUsername, password: validPassword)


        // Check if Id exists in keychain and if so, use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") { <i class="conum" data-value="90"></i><b>(90)</b>
            print("An identity with label : doco-sync-server already exists in keychain")
            config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity) <i class="conum" data-value="91"></i><b>(91)</b>
        }

    }

    func myGetCert() throws -&gt; TLSIdentity? {
        var osStatus: OSStatus
        let target = DatabaseEndpoint(database: self.otherDB)
        var config = ReplicatorConfiguration(database: self.database, target: target)

        //var thisData : CFData?
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
            print("An identity with label : doco-sync-server already exists in keychain")
            return tlsIdentity
        }

        // FIXME: since old-p2p-tlsid-tlsidentity-with-label[] is removed, this code is not under any tag?
        guard let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") else {
            return nil
        }
        config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity)

        // CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let path = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
              let certData = NSData(contentsOfFile: path)
        else {
            return nil
        }

        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        var result : CFArray?
        osStatus = SecPKCS12Import(certData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;result)
        if osStatus != errSecSuccess {
            print("Failed to import data from provided with error :\(osStatus) ")
            return nil
        }
        let importedItems = result! as NSArray
        let item = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let secIdentity = item[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var privateKey : SecKey?
        osStatus = SecIdentityCopyPrivateKey(secIdentity, &amp;privateKey)
        if osStatus != errSecSuccess {
            print("Failed to import private key from provided with error :\(osStatus) ")
            return nil
        }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let certChain = item[String(kSecImportItemCertChain)] as? [SecCertificate]


        // Return nil, if errors in key, certChain at this stage
        guard let privateKey = privateKey, let certChain = certChain else {
            return nil
        }

        // STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN
#if os(iOS)
        // For iOS, need to save the identity into the KeyChain.
        // Save or Update identity with a label so that it could be cleaned up easily
        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       privateKey
        ]
        osStatus = SecItemAdd(params as CFDictionary, nil)
        if osStatus != errSecSuccess {
            print("Unable to store private key")
            return nil
        }
        // Store all Certs for Id in Keychain:
        var i = 0;
        for cert in certChain {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
            ]
            osStatus = SecItemAdd(params as CFDictionary, nil)
            if osStatus != errSecSuccess {
                print("Unable to store certs")
                return nil
            }
            i=i+1
        }
#else
        let query: [String : Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0]
        ]

        let update: [String: Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0],
            String(kSecAttrLabel):      label
        ]

        osStatus = SecItemUpdate(query as CFDictionary, update as CFDictionary)
        if osStatus != errSecSuccess {
            print("Unable to update certs \(osStatus)")
            return nil
        }
#endif


        // RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
        return try TLSIdentity.identity(withIdentity: secIdentity, certs: [certChain[1]])
    }

    func dontTestDeleteIDFromKeychain() throws {

        try TLSIdentity.deleteIdentity(withLabel: "doco-sync-server")


    }

    func myCaCertPinned() {
        let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint)

        // Get bundled resource and read into localcert
        guard
            let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer"),
            let localCertificate:NSData = NSData(contentsOfFile: pathToCert)
        else { /</strong> process error <strong>/ return }

        // Create certificate
        // using its DER representation as a CFData
        guard
            let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
        else { /</strong> process error <strong>/  return }

        // Add <code>pinnedCert</code> and <code>acceptOnlySelfSignedServerCertificate=false</code>(by default)
        // to <code>ReplicatorConfiguration</code>
        config.pinnedServerCertificate = pinnedCert

    }

    func dontTestOldListenerConfigClientRootCA() throws {
        // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="92"></i><b>(92)</b>
    }


    enum PeerConnectionStatus: UInt8 {
        case stopped = 0;
        case offline
        case connecting
        case idle
        case busy
    }

    func dontTestReplicationStart(_ peer: String,
                                  peerDBName: String,
                                  user: String?,
                                  pass: String?,
                                  handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) throws {
        guard let validUser = user, let validPassword = pass else {
            fatalError("UserCredentialsNotProvided")
            // ... take appropriate actions
        }

        var replicator = self.replicatorsToPeers[peer]

        if replicator == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(peerDBName)") else {
                fatalError("URLInvalid")
                // ... take appropriate actions
            }

            var config = ReplicatorConfiguration.init(database: self.database, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>


            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>


            config.authenticator = BasicAuthenticator(username: validUser, password: validPassword)

            replicator = Replicator.init(config: config)
            self.replicatorsToPeers[peer] = replicator

            let token = registerForEventsForReplicator(replicator!, handler: handler)
            self.replicatorListenerTokens[peer] = token

        }

        replicator?.start()
    }

    func registerForEventsForReplicator(_ replicator: Replicator,
                                        handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) -&gt; ListenerToken {
        return replicator.addChangeListener { change in
            guard change.status.error == nil else {
                handler(.stopped, change.status.error)
                return
            }

            switch change.status.activity {
            case .connecting:
                print("Replicator Connecting to Peer")
            case .idle:
                print("Replicator in Idle state")
            case .busy:
                print("Replicator in busy state")
            case .offline:
                print("Replicator in offline state")
            case .stopped:
                print("Replicator is stopped")
            }

            let progress = change.status.progress
            if progress.completed == progress.total {
                print("All documents synced")
            }
            else {
                print("Documents \(progress.total - progress.completed) still pending sync")
            }

            if let customStatus = PeerConnectionStatus(rawValue: change.status.activity.rawValue) {
                handler(customStatus, nil)
            }
        }
    }

    func startListener() {
        var messageEndpointListener: MessageEndpointListener!

        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)

        print(messageEndpointListener.connections.count)
    }
}

class MyClass {
    var database: Database!
    var replicator: Replicator! <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }
}


/</strong>

 &lt;.&gt; A replication is an asynchronous operation.
 To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
 &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
 You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.



 let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
 let targetEndpoint = URLEndpoint(url: tgtUrl)
 var config = ReplicatorConfiguration(database: database!, target: targetEndpoint) <i class="conum" data-value="93"></i><b>(93)</b>


 <strong>/

// MARK: -- Conflict Resolver Helpers

class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}

class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}

class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}

// MARK: -- PredictiveModel Helpers

// <code>myMLModel</code> is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] { return [:] }
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // <code>myMLModel</code> is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

// MARK: Prediction Model
class TestPredictiveModel: PredictiveModel {

    class var name: String {
        return "Untitled"
    }

    var numberOfCalls = 0

    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        numberOfCalls = numberOfCalls + 1
        return self.doPredict(input: input)
    }

    func doPredict(input: DictionaryObject) -&gt; DictionaryObject? {
        return nil
    }

    func registerModel() {
        Database.prediction.registerModel(self, withName: type(of: self).name)
    }

    func unregisterModel() {
        Database.prediction.unregisterModel(withName: type(of: self).name)
    }

    func reset() {
        numberOfCalls = 0
    }
}

// MARK: -- Custom Logger

class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    // constructor for easiness
    init(_ level: LogLevel) {
        self.level = level
    }

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }
}

struct Hotel: Codable {
    var id: String
    var type: String?
    var name: String?
    var city: String?
}

#if os(macOS)
import SystemConfiguration
// . . .

class SomeClass {
    func SomeFunction() {
        for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
            // do something with this <code>interface</code>
        }
    }

    // . . .
}

#endif

// MARK -- P2p

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        let database = try Database(name: "dbname")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)

        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        return connection
    }

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion()
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
    }

    func stopListener() {
        messageEndpointListener?.closeAll()
    }

    func acceptConnection() {
        let connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection: connection)
    }

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler */
        completion()
    }
}

public class Supporting_Datatypes
{

    func datatype_dictionary()
    {

        let database = try?Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database?.document(withID:"doc1");

        // Getting a dictionary from the document's properties
        let dict = document?.dictionary(forKey: "address");

        // Access a value with a key from the dictionary
        let street = dict?.string(forKey: "street");

        // Iterate dictionary
        for key in dict!.keys {
            print("Key \(key) = \(dict!.value(forKey:key))");
        }

        // Create a mutable copy
        let mutable_dict = dict?.toMutable();
    }

    func datatype_mutable_dictionary()
    {

        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        var mutable_dict = MutableDictionaryObject();
        mutable_dict.setString("1 Main st.", forKey: "street");
        mutable_dict.setString("San Francisco", forKey: "city");

        // Add the dictionary to a document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setDictionary(mutable_dict, forKey: "address");
        try!database.saveDocument(mutable_doc);

    }


    func datatype_array()
    {
        let database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database.document(withID:"doc1");

        // Getting a phones array from the document's properties
        let array = document?.array(forKey: "phones")

        // Get element count
        let count = array!.count;

        // Access an array element by index
        if count &gt;= 0 { let phone = array![1]; }

        // Iterate dictionary
        for (index, element) in array!.enumerated() {
            print("Index \(index) = \(element)");
        }

        // Create a mutable copy
        var mutable_array = array!.toMutable();

    }

    func datatype_mutable_array()
    {
        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        var mutable_array = MutableArrayObject();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

            // Set the array to document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setArray(mutable_array, forKey:"phones");
        try!database.saveDocument(mutable_doc);
    }

} // end class supporting_datatypes



// MARK: -- QUESTIONS

// FIXME: can we use the docsn site to show the interface of the Listener class?
// <a href="https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html" class="bare">https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html</a></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add hotel name (string)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add average room rate (float)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Add document type (string)<br>
Couchbase recommend using a <code>type</code> attribute to define each logical document type.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Add address (dictionary)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Add phone numbers (array)</td>
</tr>
</table>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save the new document to database</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML

class SampleCodeTest {
    /<strong>
     For consistency in code snippets:
     1. we will use <code>self.database</code>/ <code>database</code> for database, query, replicator-db related code snippets.
     2. we will use <code>self.otherDB</code> / <code>otherDB</code> for listener-db
     <strong>/

    var database: Database!
    var otherDB: Database!

    /</strong>
     For consistency:
     1. we will use replicator with <code>self.replicator</code> and listener with <code>self.listener</code>
     */
    var replicator: Replicator!
    var listener: URLEndpointListener!

    var replicatorsToPeers = [String: Replicator]()
    var replicatorListenerTokens = [String: Any]()

    // MARK: Database

    func dontTestNewDatabase() throws {
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }

        do {
            try self.database.close()
        }
    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        self.database.EncryptionKey(
    }
#endif

    func dontTestLogging() throws {
        // verbose / replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // verbose / query
        Database.log.console.level = .verbose
        Database.log.console.domains = .query
    }

    func dontTestConsoleLogging() throws {
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>


        Database.log.console.domains = .database

    }

    func dontTestFileLogging() throws {
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
    }

    func dontTestEnableCustomLogging() throws {
        let logger = LogTestLogger(.warning)
        Database.log.custom =  logger <i class="conum" data-value="8"></i><b>(8)</b>
    }

    func dontTestLoadingPrebuilt() throws {
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
    }

    // MARK: Document

    func dontTestInitializer() throws {
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
    }

    func dontTestMutability() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
    }

    func dontTestTypedAcessors() throws {
        let newTask = MutableDocument()

        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")

        print(newTask.toDictionary())  <i class="conum" data-value="9"></i><b>(9)</b>


        print(newTask.toJSON()) <i class="conum" data-value="10"></i><b>(10)</b>


        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestChangeListener() throws {
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
    }

    func dontTestDocumentExpiration() throws {
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try database.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        print(query)
    }

    func dontTestBlob() throws {
#if TARGET_OS_IPHONE
        let newTask = MutableDocument()
        var image: UIImage!

        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)! <i class="conum" data-value="11"></i><b>(11)</b>

        let blob = Blob(contentType: "image/jpeg", data: imageData) <i class="conum" data-value="12"></i><b>(12)</b>
        newTask.setBlob(blob, forKey: "avatar") <i class="conum" data-value="13"></i><b>(13)</b>
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }

        print("\(image)")
#endif
    }

    // MARK: Query

    func dontTestQueryGetAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestIndexing() throws {
        // N1QL and Querybuilder versions
        let config = ValueIndexConfiguration(["type", "name"])
        try database.createIndex(index, withName: "TypeNameIndex")

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(Expression.property("type")),
                                            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
    }

    func dontTestSelectMeta() throws {
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
    }


    func dontTestSelectProps() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        
    }

    func dontTestSelectAll() throws {
        var query: Query

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="14"></i><b>(14)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="15"></i><b>(15)</b>
            for result in change.results! {
                print(result.keys)
                /</strong> Update UI <strong>/
            }
        } <i class="conum" data-value="16"></i><b>(16)</b>


        query.removeChangeListener(withToken: token) <i class="conum" data-value="17"></i><b>(17)</b>


        print("\(query)")
    }

    func dontTestWhere() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
    }

    func dontTestQueryDeletedDocuments() throws {
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.isDeleted)
        print(query)
    }

    func dontTestCollectionOperatorContains() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction.contains(Expression.property("public_likes"),
                                                value: Expression.string("Armani Langworth")))
            )

        do {
            for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
    }

    func dontTestCollectionOperatorIn() throws {
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
        ]

        let query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))

        print(query)
    }


    func dontTestLikeOperator() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="18"></i><b>(18)</b>
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX")))
            )

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
            )

        do {
            for result in try query.execute() {
                print("""
                    There are \(result.int(forKey: "$1")) airports on
                                the \(result.string(forKey: "tz")!)timezone located
                                in \(result.string(forKey: "country")!) and above 300 ft
                """)
            }
        }
    }

    func dontTestOrderBy() throws {
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))

        print("\(query)")
    }

    func dontTestExplainAll() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="19"></i><b>(19)</b>

        print(try query.explain()) <i class="conum" data-value="20"></i><b>(20)</b>
    }

    func dontTestExplainLike() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="21"></i><b>(21)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain())

    }

    func dontTestExplainNoOp() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="22"></i><b>(22)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%"))));

        print(try query.explain());

    }

    func dontTestExplainFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))) <i class="conum" data-value="23"></i><b>(23)</b>

        print(try query.explain());

    }

    func dontTestExplainNoFunction() throws {
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="24"></i><b>(24)</b>

        print(try query.explain());

    }


    func dontTestCreateFullTextIndex() throws {
        // Insert documents
        let overviews = ["Handy for the nice beaches in Southport", "Close to Turnpike.", "By Michigan football's Big House"]
        for overview in overviews {
            let doc = MutableDocument()
            doc.setString("overview", forKey: "type")
            doc.setString(overview, forKey: "overview")
            try database.saveDocument(doc)
        }

        // Create index with N1QL
        do {
            let index = FullTextIndexConfiguration(["overview"])
            try database.createIndex(index, withName: "overviewFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
    }

    func dontTestCreateFullTextIndex_Querybuilder() throws {

        // Create index with Querybuilder
        let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("overview")).ignoreAccents(false)
        try database.createIndex(index, withName: "overviewFTSIndex")
    }


    func dontTestFullTextSearch() throws {

        let ftsStr = "SELECT Meta().id FROM _ WHERE MATCH(overviewFTSIndex, 'Michigan') ORDER BY RANK(overviewFTSIndex)"

        let query = database.createQuery(query: ftsStr)

        let rs = try query.execute()
        for result in rs {
            print("document id \(result.string(at: 0)!)")
        }

    }



    func dontTestFullTextSearch_Querybuilder() throws {
        database = self.db

        let whereClause = FullTextFunction.match(indexName: "overviewFTSIndex"), query: "'michigan'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        for result in try query.execute() {
            print("document id \(result.string(at: 0)!)")
        }


    // MARK: toJSON

    func dontTestToJsonArrayObject() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="25"></i><b>(25)</b>
            guard let array = doc.array(forKey: "list") else {
                return
            }

            let json = array.toJSON() <i class="conum" data-value="26"></i><b>(26)</b>
            print(json)
        }
    }

    func dontTestToJsonDictionary() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="27"></i><b>(27)</b>
            guard let dictionary = doc.dictionary(forKey: "dictionary") else {
                return
            }

            let json = dictionary.toJSON() <i class="conum" data-value="28"></i><b>(28)</b>
            print(json)
        }
    }

    func dontTestToJsonDocument() throws {
        // demonstrate use of JSON string
        if let doc = database.document(withID: "doc-id") {
            let json = doc.toJSON()
            print(json)
        }
    }

    func dontTestQueryResultToJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))

        // demonstrate use of JSON string
        let resultSet = try query.execute()
        for result in resultSet {
            let json = result.toJSON()
            print(json)
        }
    }

    func dontTestBlobToJSON() throws {
        // Get a document
        if let doc = database.document(withID: "1000") {<i class="conum" data-value="29"></i><b>(29)</b>
            guard let blob = doc.blob(forKey: "avatar") else {
                return
            }

            let json = blob.toJSON() <i class="conum" data-value="30"></i><b>(30)</b>
            print(json)
        }

        // FIXME: check below function to validate whether the given property dictionary is a valid blob or not
    }

    func dontTestIsBlob() throws {
        let digest = ""

        // tag::[dictionary-isblob]
        if(Blob.isBlob(properties: [Blob.typeProperty: Blob.blobType,
                                    Blob.blobDigestProperty: digest])) { <i class="conum" data-value="31"></i><b>(31)</b>
            print("Yes! I am a blob");
        }
        // end::[dictionary-isblob]
    }
    // -- !!!

    // MARK: Replication

    /</strong> The <code>tag::replication[]</code> example is inlined in swift.adoc <strong>/

    func dontTestEnableReplicatorLogging() throws {
        // Verbose / Replicator
        Database.log.console.level = .verbose
        Database.log.console.domains = .replicator

        // Verbose / Network
        Database.log.console.level = .verbose
        Database.log.console.domains = .network
    }

    func dontTestReplicationBasicAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationSessionAuthentication() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicatorStatus() throws {
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
    }

    //  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {

        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        let myDocIDs = try self.replicator.pendingDocumentIds() <i class="conum" data-value="32"></i><b>(32)</b>

        if(!myDocIDs.isEmpty) {
            print("There are \(myDocIDs.count) documents pending")
            let thisID = myDocIDs.first!

            self.replicator.addChangeListener { (change) in
                print("Replicator activity level is \(change.status.activity)")
                do {
                    let isPending = try self.replicator.isDocumentPending(thisID)
                    if(!isPending) { <i class="conum" data-value="33"></i><b>(33)</b>
                        print("Doc ID \(thisID) now pushed")
                    }
                } catch {
                    print(error)
                }
            }

            self.replicator.start()
        }
    }

    //  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()

        self.replicator.removeChangeListener(withToken: token)
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
    }

    func dontTestHandlingReplicationError() throws {
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
    }

    func dontTestReplicationResetCheckpoint() throws {
        let doResetCheckpointRequired = Bool.random()


        if doResetCheckpointRequired {
            self.replicator.start(reset: true)  <i class="conum" data-value="34"></i><b>(34)</b>
        } else {
            self.replicator.start()
        }

    }

    func dontTestReplicationPushFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestReplicationPullFilter() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    //  Added 2/Feb/21 - Ian Bridge
    //  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        let target = URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        var config =  ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = true
        config.heartbeat = 150 <i class="conum" data-value="35"></i><b>(35)</b>

        config.maxAttempts = 20 <i class="conum" data-value="36"></i><b>(36)</b>

        config.maxAttemptWaitTime = 600 <i class="conum" data-value="37"></i><b>(37)</b>
        self.replicator = Replicator(config: config)

    }

#if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /</strong> EE feature: code below might throw a compilation error
         if it's compiled against CBL Swift Community. <strong>/
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()

        try database2.delete()
    }
#endif

    func dontTestCertificatePinning() throws {

        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        var replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")

        Database.prediction.unregisterModel(withName: "ImageClassifier")
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = Function.prediction(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                    .and(
                        prediction.property("probablity")
                            .greaterThanOrEqualTo(Expression.double(0.8))
                    )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
    }

    func dontTestCoreMLPredictiveModel() throws {
        // Load MLModel from <code>ImageClassifier.mlmodel</code>
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
    }

    func dontTestReplicatorConflictResolver() throws {
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        var config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }

    func dontTestSaveWithConflictHandler() throws {
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, <em>) in first })
            new.setData(result)
            return true
        })

    }

    // helper
    func isValidCredentials(</em> u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { (username, password) -&gt; Bool in
            return self.isValidCredentials(username, password: password)
        })

    }

    func dontTestListenerStart() throws {
        try listener.start()

    }

    func dontTestListenerStop() throws {
        listener.stop()

    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
        try TLSIdentity.createIdentity(forServer: true,
                                       attributes: attrs,
                                       expiration: Date().addingTimeInterval(86400),
                                       label: "Server-Cert-Label")
        print("\(identity.expiration)") // to avoid warning
    }

    // MARK: -- URLEndpointListener
    func dontTestTLSIdentityCreate() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-server-cert-label");
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: "couchbaselite-server-cert-label")
        print(identity)
    }

    func dontTestDeleteIdentity() throws {
        try TLSIdentity.deleteIdentity(withLabel: "couchbaselite-client-cert-label")
    }

    func dontTestImportTLSIdentity() throws {

        let path = Bundle.main.path(forResource: "identity/client", ofType: "p12")
        let clientCertData = try NSData(contentsOfFile: path!, options: []) as Data
        let identity = try TLSIdentity.importIdentity(withData: clientCertData,
                                                      password: "123",
                                                      label: "couchbaselite-client-cert-label")
        print(identity)
    }

    // MARK: -- QUERY RESULT SET HANDLING EXAMPLES

    func donTestQuerySyntaxAll() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))


        print(query)
    }

    func dontTestQueryAccessAll() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Any]()

        let results = try query.execute()
        for row in results {
            let docsProps = row.dictionary(at: 0)! <i class="conum" data-value="38"></i><b>(38)</b>

            let docid = docsProps.string(forKey: "id")
            let name = docsProps.string(forKey: "name")
            let type = docsProps.string(forKey: "type")
            let city = docsProps.string(forKey: "city")

            print("\(docid): \(name), \(type), \(city)")
            let hotel = row.dictionary(at: 0)!  <i class="conum" data-value="39"></i><b>(39)</b>
            guard let hotelId = hotel.string(forKey: "id") else {
                continue
            }

            hotels[hotelId] = hotel
        }

    }



    func dontTestQueryAccessJSON() throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String:Hotel]()

        // In this example the Hotel class is defined using Codable
        //
        // class Hotel : Codable {
        //   var id : String = "undefined"
        //   var type : String = "hotel"
        //   var name : String = "undefined"
        //   var city : String = "undefined"
        //   var country : String = "undefined"
        //   var description : String? = ""
        //   var text : String? = ""
        //   ... other class content
        // }

        let results = try query.execute()
        for row in  results {

            // get the result into a JSON String
            let jsonString = row.toJSON() <i class="conum" data-value="40"></i><b>(40)</b>

            let thisJsonObj:Dictionary =
            try (JSONSerialization.jsonObject(
                with: jsonString.data(using: .utf8)!,
                options: .allowFragments)
                 as? [String: Any])! <i class="conum" data-value="41"></i><b>(41)</b>

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="42"></i><b>(42)</b>

            // ALTERNATIVELY unpack in steps
            this_hotel.id = thisJsonObj["id"] as! String
            this_hotel.name = thisJsonObj["name"] as! String
            this_hotel.type = thisJsonObj["type"] as! String
            this_hotel.city = thisJsonObj["city"] as! String
            hotels[this_hotel.id] = this_hotel

        } // end for

    }

    func dontTestQuerySyntaxProps() throws {
        let database = try! Database(name: "hotel")

        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
            .from(DataSource.database(database))

        print(query)
    }

    func dontTestQueryAccessProps () throws {
        let query = QueryBuilder.select(SelectResult.all()).from(DataSource.database(database))
        var hotels = [String: Hotel]()

        for result in try! query.execute() {
            let docID = result.string(forKey: "metaId")!
            print("processing doc: \(docID)")

            let id = result.string(forKey: "id")!
            var hotel = Hotel(id: id)
            hotel.name = result.string(forKey: "name")
            hotel.city = result.string(forKey: "city")
            hotel.type = result.string(forKey: "type")
            hotels[id] = hotel
        } // end for

    }// end func

    func dontTestQueryCount() throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder
            .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
            .from (DataSource.database(database)).groupBy(Expression.property("type"))


        for result in try query.execute() {
            let count = result.int(forKey: "mycount") <i class="conum" data-value="43"></i><b>(43)</b>
            print("There are ", count, " rows")
        }
    }

    func dontTestQueryId () throws {
        let database = try Database(name: "hotel")
        let query = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(database))



        let results = try query.execute()
        for result in results {

            print(result.toDictionary())

            let docId = result.string(forKey: "metaId")! <i class="conum" data-value="44"></i><b>(44)</b>
            print("Document Id is -- \(docId)")

            // Now you can get the document using the ID
            let doc = database.document(withID: docId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")


        }
    }

    func query_pagination () throws {
        let offset = 0;
        let limit = 20;
        //
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .limit(Expression.int(limit), offset: Expression.int(offset))

        print(query)
    }

    func dontTestQueryN1QL() throws {

        let database = try Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = 'hotel'") <i class="conum" data-value="45"></i><b>(45)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestQueryN1QLparams() throws {

        let database = try! Database(name: "hotel")

        let query = try database.createQuery("SELECT META().id AS thisId FROM _ WHERE type = $type") <i class="conum" data-value="46"></i><b>(46)</b>

        query.parameters = Parameters().setString("hotel", forName: "type") <i class="conum" data-value="47"></i><b>(47)</b>

        let results: ResultSet = try query.execute()


        print(results.allResults().count)
    }

    func dontTestProcessResults(results: ResultSet) throws {

        for row in results {
            print(row["thisId"].string!)

            let docsId = row["thisId"].string!

            // Now you can get the document using the ID
            let doc = database.document(withID: docsId)!

            let hotelId = doc.string(forKey: "id")!

            let name = doc.string(forKey: "name")

            let city = doc.string(forKey: "city")

            let type = doc.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: \(hotelId), \(name), \(city), \(type)")

        }

    }

    // MARK: -- Listener

    func dontTestListenerSimple() throws {
        let database = try Database(name: "database")
        var config = URLEndpointListenerConfiguration(database: database) <i class="conum" data-value="48"></i><b>(48)</b>
        config.authenticator = ListenerPasswordAuthenticator { username, password in
            return "valid.user" == username &amp;&amp; "valid.password.string" == String(password)
        } <i class="conum" data-value="49"></i><b>(49)</b>

        let listener = URLEndpointListener(config: config) <i class="conum" data-value="50"></i><b>(50)</b>

        try listener.start()  <i class="conum" data-value="51"></i><b>(51)</b>

    }

    func dontTestListenerInitialize() throws {
        let otherDB = try Database(name: "otherDB")

        var config = URLEndpointListenerConfiguration(database: otherDB) <i class="conum" data-value="52"></i><b>(52)</b>

        /</strong> optionally <strong>/ let wsPort: UInt16 = 55991
        /</strong> optionally <strong>/ let wssPort: UInt16 = 55990
        config.port =  wssPort <i class="conum" data-value="53"></i><b>(53)</b>

        config.networkInterface = "10.1.1.10"  <i class="conum" data-value="54"></i><b>(54)</b>

        config.enableDeltaSync = true <i class="conum" data-value="55"></i><b>(55)</b>

        config.disableTLS  = false <i class="conum" data-value="56"></i><b>(56)</b>

        // Set the credentials the server presents the client
        // Use an anonymous self-signed cert
        config.tlsIdentity = nil <i class="conum" data-value="57"></i><b>(57)</b>

        // Configure how the client is to be authenticated
        // Here, use Basic Authentication
        config.authenticator = ListenerPasswordAuthenticator(authenticator: { uname, pword -&gt; Bool in
            return self.isValidCredentials(uname, password: pword)
        }) <i class="conum" data-value="58"></i><b>(58)</b>


        // Initialize the listener
        self.listener = URLEndpointListener(config: config) <i class="conum" data-value="59"></i><b>(59)</b>
        if self.listener == nil {
            fatalError("ListenerError Not Initialized")
            // ... take appropriate actions
        }

        // Start the listener
        try self.listener.start() <i class="conum" data-value="60"></i><b>(60)</b>


        print(wsPort)
    }

    func dontTestReplicatorSimple() throws {

        let tgtUrl = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="61"></i><b>(61)</b>

        var thisConfig = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="62"></i><b>(62)</b>

        thisConfig.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="63"></i><b>(63)</b>

        let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
        thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="64"></i><b>(64)</b>

        self.replicator = Replicator(config: thisConfig) <i class="conum" data-value="65"></i><b>(65)</b>

        self.replicator.start(); <i class="conum" data-value="66"></i><b>(66)</b>

    }


    // MARK: Append

    func dontTestGetURLList() throws {
        let config = URLEndpointListenerConfiguration(database: otherDB)
        let listener = URLEndpointListener(config: config)
        try listener.start()

        if let urls = listener.urls {
            print("URLs are: \(urls)")
        }

    }


    func dontTestListenerConfigDisableTLSUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        config.disableTLS  = false <i class="conum" data-value="67"></i><b>(67)</b>

        config.disableTLS  = true <i class="conum" data-value="68"></i><b>(68)</b>

    }

    func dontTestListenerConfigTLSIdentity() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        guard let path = Bundle.main.path(forResource: "cert", ofType: "p12") else {
            /</strong> process error <strong>/ return
        }

        guard let certData = try? NSData(contentsOfFile: path) as Data else {
            /</strong> process error <strong>/ return
        } <i class="conum" data-value="69"></i><b>(69)</b>

        let tlsIdentity = try TLSIdentity.importIdentity(withData: certData,
                                                         password: "123",
                                                         label: "Server-Cert-Label") <i class="conum" data-value="70"></i><b>(70)</b>

        let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="71"></i><b>(71)</b>

        let identity = try TLSIdentity.createIdentity(forServer: true, /</strong> isServer <strong>/
                                                      attributes: attrs,
                                                      expiration: Date().addingTimeInterval(86400),
                                                      label: "Server-Cert-Label") <i class="conum" data-value="72"></i><b>(72)</b>

        // Set the credentials the server presents the client
        config.tlsIdentity = tlsIdentity    <i class="conum" data-value="73"></i><b>(73)</b>


        print("To avoid waring: \(identity)")
    }

    func dontTestListenerConfigClientRootCA() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        // Authenticate using Cert Authority

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="74"></i><b>(74)</b>
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="75"></i><b>(75)</b> <i class="conum" data-value="76"></i><b>(76)</b>

    }

    func isValidCertificates(_ certs: [SecCertificate]) -&gt; Bool { return true }

    func dontTestClientAuthLambda() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)

        // Authenticate self-signed cert using application logic

        config.authenticator = ListenerCertificateAuthenticator { certs -&gt; Bool in <i class="conum" data-value="77"></i><b>(77)</b>
            // Validate the cert
            return self.isValidCertificates(certs)
        } <i class="conum" data-value="78"></i><b>(78)</b>

    }

    func dontTestListenerConfigUpdate() throws {
        var config = URLEndpointListenerConfiguration(database: otherDB)
        let cert = self.listener.tlsIdentity!.certs[0]

        config.tlsIdentity = nil

        config.enableDeltaSync = true

        let totalConnections = self.listener.status.connectionCount
        let activeConnections = self.listener.status.activeConnectionCount

        self.listener.stop()

        // cert is a pre-populated object of type:SecCertificate representing a certificate
        let rootCertData = SecCertificateCopyData(cert) as Data
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        config.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

        config.authenticator = ListenerCertificateAuthenticator { self.isValidCertificates($0) }

        print("to avoid warnings: \(activeConnections)/\(totalConnections) ")
    }

    func dontTestURLEndpointListenerConstructor() throws {
        let enableTLS = Bool.random()
        let wssPort: UInt16 = 4985
        let wsPort: UInt16 = 4984
        let auth = ListenerPasswordAuthenticator { self.isValidCredentials($0, password: $1)}

        var config = URLEndpointListenerConfiguration.init(database: otherDB)
        config.port = enableTLS ? wssPort : wsPort
        config.disableTLS = !enableTLS
        config.authenticator = auth
        self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    func fMyActPeer() {

        guard let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB") else {
            fatalError("Invalid URL")
        }
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint) <i class="conum" data-value="79"></i><b>(79)</b>

        config.replicatorType = .pushAndPull

        // set auto-purge behavior (here we override default)
        config.enableAutoPurge = false <i class="conum" data-value="80"></i><b>(80)</b>

        // Configure Sync Mode
        config.continuous = true

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="81"></i><b>(81)</b>

        // Configure Client Security <i class="conum" data-value="82"></i><b>(82)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: "cbl-user-01",
                                                  password: "secret")

        /</strong> Optionally set custom conflict resolver call back
         config.conflictResolver = LocalWinConflictResolver()  <i class="conum" data-value="83"></i><b>(83)</b>
         <strong>/

        // Apply configuration settings to the replicator
        self.replicator = Replicator.init( config: config) <i class="conum" data-value="84"></i><b>(84)</b>

        // Optionally add a change listener
        // Retain token for use in deletion
        let token = self.replicator.addChangeListener { change in <i class="conum" data-value="85"></i><b>(85)</b>
            if change.status.activity == .stopped {
                print("Replication stopped")
            } else {
                print("Replicator is currently : \(self.replicator.status.activity)")
            }
        }

        // Run the replicator using the config settings
        self.replicator.start()  <i class="conum" data-value="86"></i><b>(86)</b>



        self.replicator.removeChangeListener(withToken: token)
    }


    func dontTestReplicatorStop() {
        let token = self.replicator.addChangeListener { change in }

        // Remove the change listener
        self.replicator.removeChangeListener(withToken: token)

        // Stop the replicator
        self.replicator.stop()

    }

    func dontTestAdditionalListenerConfigs() throws {
        let target = DatabaseEndpoint(database: otherDB)
        var config = ReplicatorConfiguration(database: database, target: target)
        let cert = self.listener.tlsIdentity!.certs[0]
        let validUsername = "cbl-user-01"
        let validPassword = "secret"
        // Configure Server Security -- only accept CA Certs
        config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="87"></i><b>(87)</b>

        // Configure Server Security -- only accept self-signed certs
        config.acceptOnlySelfSignedServerCertificate = true <i class="conum" data-value="88"></i><b>(88)</b>

        // Return the remote pinned cert (the listener's cert)
        config.pinnedServerCertificate = cert // Get listener cert if pinned

        // Configure Client Security <i class="conum" data-value="89"></i><b>(89)</b>
        //  Set Authentication Mode
        config.authenticator = BasicAuthenticator(username: validUsername, password: validPassword)


        // Check if Id exists in keychain and if so, use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") { <i class="conum" data-value="90"></i><b>(90)</b>
            print("An identity with label : doco-sync-server already exists in keychain")
            config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity) <i class="conum" data-value="91"></i><b>(91)</b>
        }

    }

    func myGetCert() throws -&gt; TLSIdentity? {
        var osStatus: OSStatus
        let target = DatabaseEndpoint(database: self.otherDB)
        var config = ReplicatorConfiguration(database: self.database, target: target)

        //var thisData : CFData?
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        if let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
            print("An identity with label : doco-sync-server already exists in keychain")
            return tlsIdentity
        }

        // FIXME: since old-p2p-tlsid-tlsidentity-with-label[] is removed, this code is not under any tag?
        guard let tlsIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") else {
            return nil
        }
        config.authenticator = ClientCertificateAuthenticator(identity: tlsIdentity)

        // CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let path = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
              let certData = NSData(contentsOfFile: path)
        else {
            return nil
        }

        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        var result : CFArray?
        osStatus = SecPKCS12Import(certData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;result)
        if osStatus != errSecSuccess {
            print("Failed to import data from provided with error :\(osStatus) ")
            return nil
        }
        let importedItems = result! as NSArray
        let item = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let secIdentity = item[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var privateKey : SecKey?
        osStatus = SecIdentityCopyPrivateKey(secIdentity, &amp;privateKey)
        if osStatus != errSecSuccess {
            print("Failed to import private key from provided with error :\(osStatus) ")
            return nil
        }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let certChain = item[String(kSecImportItemCertChain)] as? [SecCertificate]


        // Return nil, if errors in key, certChain at this stage
        guard let privateKey = privateKey, let certChain = certChain else {
            return nil
        }

        // STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN
#if os(iOS)
        // For iOS, need to save the identity into the KeyChain.
        // Save or Update identity with a label so that it could be cleaned up easily
        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       privateKey
        ]
        osStatus = SecItemAdd(params as CFDictionary, nil)
        if osStatus != errSecSuccess {
            print("Unable to store private key")
            return nil
        }
        // Store all Certs for Id in Keychain:
        var i = 0;
        for cert in certChain {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
            ]
            osStatus = SecItemAdd(params as CFDictionary, nil)
            if osStatus != errSecSuccess {
                print("Unable to store certs")
                return nil
            }
            i=i+1
        }
#else
        let query: [String : Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0]
        ]

        let update: [String: Any] = [
            String(kSecClass):          kSecClassCertificate,
            String(kSecValueRef):       certs[0],
            String(kSecAttrLabel):      label
        ]

        osStatus = SecItemUpdate(query as CFDictionary, update as CFDictionary)
        if osStatus != errSecSuccess {
            print("Unable to update certs \(osStatus)")
            return nil
        }
#endif


        // RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
        return try TLSIdentity.identity(withIdentity: secIdentity, certs: [certChain[1]])
    }

    func dontTestDeleteIDFromKeychain() throws {

        try TLSIdentity.deleteIdentity(withLabel: "doco-sync-server")


    }

    func myCaCertPinned() {
        let targetURL = URL(string: "wss://10.1.1.12:8092/otherDB")!
        let targetEndpoint = URLEndpoint(url: targetURL)
        var config = ReplicatorConfiguration(database: database, target: targetEndpoint)

        // Get bundled resource and read into localcert
        guard
            let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer"),
            let localCertificate:NSData = NSData(contentsOfFile: pathToCert)
        else { /</strong> process error <strong>/ return }

        // Create certificate
        // using its DER representation as a CFData
        guard
            let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
        else { /</strong> process error <strong>/  return }

        // Add <code>pinnedCert</code> and <code>acceptOnlySelfSignedServerCertificate=false</code>(by default)
        // to <code>ReplicatorConfiguration</code>
        config.pinnedServerCertificate = pinnedCert

    }

    func dontTestOldListenerConfigClientRootCA() throws {
        // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="92"></i><b>(92)</b>
    }


    enum PeerConnectionStatus: UInt8 {
        case stopped = 0;
        case offline
        case connecting
        case idle
        case busy
    }

    func dontTestReplicationStart(_ peer: String,
                                  peerDBName: String,
                                  user: String?,
                                  pass: String?,
                                  handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) throws {
        guard let validUser = user, let validPassword = pass else {
            fatalError("UserCredentialsNotProvided")
            // ... take appropriate actions
        }

        var replicator = self.replicatorsToPeers[peer]

        if replicator == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(peerDBName)") else {
                fatalError("URLInvalid")
                // ... take appropriate actions
            }

            var config = ReplicatorConfiguration.init(database: self.database, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>


            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>


            config.authenticator = BasicAuthenticator(username: validUser, password: validPassword)

            replicator = Replicator.init(config: config)
            self.replicatorsToPeers[peer] = replicator

            let token = registerForEventsForReplicator(replicator!, handler: handler)
            self.replicatorListenerTokens[peer] = token

        }

        replicator?.start()
    }

    func registerForEventsForReplicator(_ replicator: Replicator,
                                        handler: @escaping (PeerConnectionStatus, Error?) -&gt; Void) -&gt; ListenerToken {
        return replicator.addChangeListener { change in
            guard change.status.error == nil else {
                handler(.stopped, change.status.error)
                return
            }

            switch change.status.activity {
            case .connecting:
                print("Replicator Connecting to Peer")
            case .idle:
                print("Replicator in Idle state")
            case .busy:
                print("Replicator in busy state")
            case .offline:
                print("Replicator in offline state")
            case .stopped:
                print("Replicator is stopped")
            }

            let progress = change.status.progress
            if progress.completed == progress.total {
                print("All documents synced")
            }
            else {
                print("Documents \(progress.total - progress.completed) still pending sync")
            }

            if let customStatus = PeerConnectionStatus(rawValue: change.status.activity.rawValue) {
                handler(customStatus, nil)
            }
        }
    }

    func startListener() {
        var messageEndpointListener: MessageEndpointListener!

        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)

        print(messageEndpointListener.connections.count)
    }
}

class MyClass {
    var database: Database!
    var replicator: Replicator! <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        var config = ReplicatorConfiguration(database: database, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator.start()
    }
}


/</strong>

 &lt;.&gt; A replication is an asynchronous operation.
 To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
 &lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
 You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.



 let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
 let targetEndpoint = URLEndpoint(url: tgtUrl)
 var config = ReplicatorConfiguration(database: database!, target: targetEndpoint) <i class="conum" data-value="93"></i><b>(93)</b>


 <strong>/

// MARK: -- Conflict Resolver Helpers

class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}

class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}

class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}

// MARK: -- PredictiveModel Helpers

// <code>myMLModel</code> is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] { return [:] }
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // <code>myMLModel</code> is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

// MARK: Prediction Model
class TestPredictiveModel: PredictiveModel {

    class var name: String {
        return "Untitled"
    }

    var numberOfCalls = 0

    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        numberOfCalls = numberOfCalls + 1
        return self.doPredict(input: input)
    }

    func doPredict(input: DictionaryObject) -&gt; DictionaryObject? {
        return nil
    }

    func registerModel() {
        Database.prediction.registerModel(self, withName: type(of: self).name)
    }

    func unregisterModel() {
        Database.prediction.unregisterModel(withName: type(of: self).name)
    }

    func reset() {
        numberOfCalls = 0
    }
}

// MARK: -- Custom Logger

class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    // constructor for easiness
    init(_ level: LogLevel) {
        self.level = level
    }

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }
}

struct Hotel: Codable {
    var id: String
    var type: String?
    var name: String?
    var city: String?
}

#if os(macOS)
import SystemConfiguration
// . . .

class SomeClass {
    func SomeFunction() {
        for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
            // do something with this <code>interface</code>
        }
    }

    // . . .
}

#endif

// MARK -- P2p

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        let database = try Database(name: "dbname")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)

        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        return connection
    }

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion()
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ---------------  stubs for documentation  ----------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
    }

    func stopListener() {
        messageEndpointListener?.closeAll()
    }

    func acceptConnection() {
        let connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection: connection)
    }

    func disconnect() {
        replicatorConnection?.close(error: nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion(true, nil)
    }

    func receive(data: Data) {
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler */
        completion()
    }
}

public class Supporting_Datatypes
{

    func datatype_dictionary()
    {

        let database = try?Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database?.document(withID:"doc1");

        // Getting a dictionary from the document's properties
        let dict = document?.dictionary(forKey: "address");

        // Access a value with a key from the dictionary
        let street = dict?.string(forKey: "street");

        // Iterate dictionary
        for key in dict!.keys {
            print("Key \(key) = \(dict!.value(forKey:key))");
        }

        // Create a mutable copy
        let mutable_dict = dict?.toMutable();
    }

    func datatype_mutable_dictionary()
    {

        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        var mutable_dict = MutableDictionaryObject();
        mutable_dict.setString("1 Main st.", forKey: "street");
        mutable_dict.setString("San Francisco", forKey: "city");

        // Add the dictionary to a document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setDictionary(mutable_dict, forKey: "address");
        try!database.saveDocument(mutable_doc);

    }


    func datatype_array()
    {
        let database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)
        let document = database.document(withID:"doc1");

        // Getting a phones array from the document's properties
        let array = document?.array(forKey: "phones")

        // Get element count
        let count = array!.count;

        // Access an array element by index
        if count &gt;= 0 { let phone = array![1]; }

        // Iterate dictionary
        for (index, element) in array!.enumerated() {
            print("Index \(index) = \(element)");
        }

        // Create a mutable copy
        var mutable_array = array!.toMutable();

    }

    func datatype_mutable_array()
    {
        var database = try!Database(name: "mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        var mutable_array = MutableArrayObject();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

            // Set the array to document's properties and save the document
        var mutable_doc = MutableDocument(id: "doc1");
        mutable_doc.setArray(mutable_array, forKey:"phones");
        try!database.saveDocument(mutable_doc);
    }

} // end class supporting_datatypes



// MARK: -- QUESTIONS

// FIXME: can we use the docsn site to show the interface of the Listener class?
// <a href="https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html" class="bare">https://docs.couchbase.com/mobile/2.8.0/couchbase-lite-swift/Classes/URLEndpointListener.html</a></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-types"><a class="anchor" href="#data-types"></a>Data Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="scalars"><a class="anchor" href="#scalars"></a>Scalars</h3>
<div class="paragraph">
<p>The <code>Document</code> class offers a set of property accessors for various scalar types, including boolean, integers, floating-point and strings.
These accessors take care of converting to/from JSON encoding, and make sure you get the type you&#8217;re expecting.</p>
</div>
<div class="paragraph">
<p>So your document content may well comprise one or more supporting data types such as:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Double</p>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enumerator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HashCode</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dictionary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a read-only key-value pair collection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MutableDictionary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a writeable key-value pair collection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a readonly ordered collection of objects</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MutableArray</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a writeable collection of objects</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Blob</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents an arbitrary piece of binary data</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="date-accessors"><a class="anchor" href="#date-accessors"></a>Date accessors</h3>
<div class="paragraph">
<p>As a convenience Couchbase Lite offers <em>Date</em> accessors.
Dates are a common data type, but JSON doesn&#8217;t natively support them, so the convention is to store them as strings in ISO-8601 format.</p>
</div>
<div id="ex-date-getter" class="exampleblock">
<div class="title">Example 1. Date Getter</div>
<div class="content">
<div class="paragraph">
<p>This example sets the date on the <code>createdAt</code> property and reads it back using the <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Document.html#/s:18CouchbaseLiteSwift8DocumentC4date6forKey10Foundation4DateVSgSS_tF">Document.date()</a> accessor method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">newTask.setValue(Date(), forKey: "createdAt")
let date = newTask.date(forKey: "createdAt")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-dictionaries"><a class="anchor" href="#using-dictionaries"></a>Using Dictionaries</h3>
<div class="ulist">
<div class="title">API References</div>
<ul>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/DictionaryObject.html">property accessors</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/MutableDictionaryObject.html">MutableDictionaryObject</a></p>
</li>
</ul>
</div>
<div id="ex-dict" class="exampleblock">
<div class="title">Example 2. Read Only</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">// NOTE: No error handling, for brevity (see getting started)
let document = database?.document(withID:"doc1");

// Getting a dictionary from the document's properties
let dict = document?.dictionary(forKey: "address");

// Access a value with a key from the dictionary
let street = dict?.string(forKey: "street");

// Iterate dictionary
for key in dict!.keys {
    print("Key \(key) = \(dict!.value(forKey:key))");
}

// Create a mutable copy
let mutable_dict = dict?.toMutable();</code></pre>
</div>
</div>
</div>
</div>
<div id="ex-mutdict" class="exampleblock">
<div class="title">Example 3. Mutable</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable dictionary and populate some keys/values
var mutable_dict = MutableDictionaryObject();
mutable_dict.setString("1 Main st.", forKey: "street");
mutable_dict.setString("San Francisco", forKey: "city");

// Add the dictionary to a document's properties and save the document
var mutable_doc = MutableDocument(id: "doc1");
mutable_doc.setDictionary(mutable_dict, forKey: "address");
try!database.saveDocument(mutable_doc);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-arrays"><a class="anchor" href="#using-arrays"></a>Using Arrays</h3>
<div class="ulist">
<div class="title">API References</div>
<ul>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/ArrayObject.html">ArrayObject</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/MutableArrayObject.html">MutableArrayObject</a></p>
</li>
</ul>
</div>
<div id="ex-array" class="exampleblock">
<div class="title">Example 4. Read Only</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">// NOTE: No error handling, for brevity (see getting started)
let document = database.document(withID:"doc1");

// Getting a phones array from the document's properties
let array = document?.array(forKey: "phones")

// Get element count
let count = array!.count;

// Access an array element by index
if count &gt;= 0 { let phone = array![1]; }

// Iterate dictionary
for (index, element) in array!.enumerated() {
    print("Index \(index) = \(element)");
}

// Create a mutable copy
var mutable_array = array!.toMutable();</code></pre>
</div>
</div>
</div>
</div>
<div id="ex-mutarray" class="exampleblock">
<div class="title">Example 5. Mutable</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable array and populate data into the array
var mutable_array = MutableArrayObject();
mutable_array.addString("650-000-0000");
mutable_array.addString("650-000-0001");

    // Set the array to document's properties and save the document
var mutable_doc = MutableDocument(id: "doc1");
mutable_doc.setArray(mutable_array, forKey:"phones");
try!database.saveDocument(mutable_doc);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-blobs"><a class="anchor" href="#using-blobs"></a>Using Blobs</h3>
<div class="paragraph">
<p>For more on working with blobs&#8201;&#8212;&#8201;see <a href="blob.html" class="page">Blobs</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-initializers"><a class="anchor" href="#document-initializers"></a>Document Initializers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following methods/initializers can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/MutableDocument.html#/s:18CouchbaseLiteSwift15MutableDocumentCACycfc">MutableDocument()</a> initializer can be used to create a new document where the document ID is randomly generated by the database.</p>
</li>
<li>
<p>The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/MutableDocument.html#/s:18CouchbaseLiteSwift15MutableDocumentC2idACSSSg_tcfc">MutableDocument(String id)</a> initializer can be used to create a new document with a specific ID.</p>
</li>
<li>
<p>The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Database.html#/s:18CouchbaseLiteSwift8DatabaseC8document6withIDAA8DocumentCSgSS_tF">Database.document(withID:)</a> method can be used to get a document.
If it doesn&#8217;t exist in the database, it will return <code>null</code>.
This method can be used to check if a document with a given ID already exists in the database.</p>
</li>
</ul>
</div>
<div id="ex-persists-doc" class="exampleblock">
<div class="title">Example 6. Persist a document</div>
<div class="content">
<div class="paragraph">
<p>The following code example creates a document and persists it to the database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">let newTask = MutableDocument()
    .setString("task", forKey: "type")
    .setString("todo", forKey: "owner")
    .setDate(Date(), forKey: "createdAt")
try database.saveDocument(newTask)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mutability"><a class="anchor" href="#mutability"></a>Mutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, when a document is read from the database it is immutable.
The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Document.html#/s:18CouchbaseLiteSwift8DocumentC9toMutableAA0fD0CyF">Document.toMutable()</a> method should be used to create an instance of the document which can be updated.</p>
</div>
<div id="ex-update-doc" class="exampleblock">
<div class="title">Example 7. Make a mutable document</div>
<div class="content">
<div class="paragraph">
<p>Changes to the document are persisted to the database when the <code>save</code> method is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">guard let document = database.document(withID: "xyz") else { return }
let mutableDocument = document.toMutable()
mutableDocument.setString("apples", forKey: "name")
try database.saveDocument(mutableDocument)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any user change to the value of reserved keys (<code>_id</code>, <code>_rev</code> or <code>_deleted</code>) will be detected when a document is saved and will result in an exception (Error Code 5&#8201;&#8212;&#8201;<code>CorruptRevisionData</code>)&#8201;&#8212;&#8201;see also <a href="#lbl-doc-constraints">Document Constraints</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="checking-a-document-for-properties"><a class="anchor" href="#checking-a-document-for-properties"></a>Checking a Document for properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To check whether a given pro
perty exists in the document, you should use the <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Document.html#/s:18CouchbaseLiteSwift8DocumentC8contains3keySbSS_tF">Document.Contains(key:)</a> method.</p>
</div>
<div class="paragraph">
<p>If the property doesn&#8217;t exist in the document it will return the default value for that getter method (0 for <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Document.html#/s:18CouchbaseLiteSwift8DocumentC3int6forKeySiSS_tF">Document.int()</a> 0.0 for <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Document.html#/s:18CouchbaseLiteSwift8DocumentC5float6forKeySfSS_tF">Document.float()</a> etc.).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-conversion"><a class="anchor" href="#document-conversion"></a>Document Conversion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <code>Document</code> can be converted to a plain dictionary type and-or to a JSON string.
This can often be useful to pass the document contents as a plain object to another method.</p>
</div>
<div id="ex-conv-doc" class="exampleblock">
<div class="title">Example 8. Convert document</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">print(newTask.toDictionary())  <i class="conum" data-value="1"></i><b>(1)</b>

print(newTask.toJSON()) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns a Dictionary&lt;String, Any&gt;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns a JSON string
:param-tags!:
:param-leader!:</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="batch-operations"><a class="anchor" href="#batch-operations"></a>Batch operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re making multiple changes to a database at once, it&#8217;s faster to group them together.
The following example persists a few documents in batch.</p>
</div>
<div id="ex-batch-ops" class="exampleblock">
<div class="title">Example 9. Batch operations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">do {
    try database.inBatch {
        for i in 0...10 {
            let doc = MutableDocument()
            doc.setValue("user", forKey: "type")
            doc.setValue("user \(i)", forKey: "name")
            doc.setBoolean(false, forKey: "admin")
            try database.saveDocument(doc)
            print("saved user document \(doc.string(forKey: "name")!)")
        }
    }
} catch let error {
    print(error.localizedDescription)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>At the <strong>local</strong> level this operation is still transactional: no other <code>Database</code> instances, including ones managed by the replicator can make changes during the execution of the block, and other instances will not see partial changes.
But Couchbase Mobile is a distributed system, and due to the way replication works, there&#8217;s no guarantee that Sync Gateway or other devices will receive your changes all at once.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-change-events"><a class="anchor" href="#document-change-events"></a>Document change events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s also possible to register for document changes.
The following example registers for changes to the document with ID <code>user.john</code> and prints the <code>verified_account</code> property.</p>
</div>
<div id="ex-doc-events" class="exampleblock">
<div class="title">Example 10. Document change events</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">database.addDocumentChangeListener(withID: "user.john") { (change) in
    if let document = self.database.document(withID: change.documentID) {
        print("Status :: \(document.string(forKey: "verified_account")!)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-expiration"><a class="anchor" href="#document-expiration"></a>Document Expiration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Document expiration allows users to set the expiration date to a document.
When the document is expired, the document will be purged from the database.
The purge will not be replicated to Sync Gateway.</p>
</div>
<div id="ex-set-doc-exp" class="exampleblock">
<div class="title">Example 11. Set document expiration</div>
<div class="content">
<div class="paragraph">
<p>This example sets the TTL for a document to 5 minutes from the current time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">// Purge the document one day from now
let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

// Reset expiration
try database.setDocumentExpiration(withID: "doc1", expiration: nil)

// Query documents that will be expired in less than five minutes
let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
let query = QueryBuilder
    .select(SelectResult.expression(Meta.id))
    .from(DataSource.database(database))
    .where(
        Meta.expiration.lessThan(
            Expression.double(fiveMinutesFromNow)
        )
    )</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lbl-doc-constraints"><a class="anchor" href="#lbl-doc-constraints"></a>Document Constraints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite APIs do not explicitly disallow the use of attributes with the underscore prefix at the top level of document.
This is to facilitate the creation of documents for use either in <em>local only</em> mode where documents are not synced, or when used exclusively in peer-to-peer sync.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
"_id", :"_rev" and "_sequence" are reserved keywords and must not be used as top-level attributes&#8201;&#8212;&#8201;see <a href="#res-keys">Example 12</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Users are cautioned that any attempt to sync such documents to Sync Gateway will result in an error.
To be future proof, you are advised to avoid creating such documents.
Use of these attributes for user-level data may result in undefined system behavior.</p>
</div>
<div class="paragraph">
<p>For more guidance&#8201;&#8212;&#8201;see: <a href="../../../sync-gateway/current/data-modeling.html" class="page">Sync Gateway - data modeling guidelines</a></p>
</div>
<div id="res-keys" class="exampleblock">
<div class="title">Example 12. Reserved Keys List</div>
<div class="content">
<div class="ulist">
<ul>
<li>
<p>_attachments</p>
</li>
<li>
<p>_deleted <sup class="footnote" id="_footnote_fn1">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>_id <sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>_removed</p>
</li>
<li>
<p>_rev <sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>_sequence</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lbl-json-data"><a class="anchor" href="#lbl-json-data"></a>Working with JSON Data</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-array">Arrays</a>
| <a href="#lbl-blob">Blobs</a>
| <a href="#lbl-dictionary">Dictionaries</a>
| <a href="#lbl-document">Documents</a>
| <a href="#lbl-result">Query Results as JSON</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>toJSON()</code> typed-accessor means you can easily work with JSON data, native and Couchbase Lite objects.</p>
</div>
<div class="sect2">
<h3 id="lbl-array"><a class="anchor" href="#lbl-array"></a>Arrays</h3>
<div class="paragraph">
<p>Convert an <code>ArrayObject</code> to and from JSON using the <code>toJSON()</code> and <code>toArray</code> methods&#8201;&#8212;&#8201;see: <a href="#ex-array">Example 4</a>.</p>
</div>
<div class="paragraph">
<p>Additionally you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a 'MutableArrayObject' using data supplied as a JSON string.
This is done using the <code>init(json)</code> constructor-- see: <a href="#ex-array">Example 4</a></p>
</li>
<li>
<p>Convert an <code>ArrayFragment</code> object to a JSON String</p>
</li>
<li>
<p>Set data with a JSON string using <code>setJSON()</code></p>
</li>
</ul>
</div>
<div id="ex-array" class="exampleblock">
<div class="title">Example 13. Arrays as JSON strings</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">if let doc = database.document(withID: "1000") {<i class="conum" data-value="1"></i><b>(1)</b>
    guard let array = doc.array(forKey: "list") else {
        return
    }

    let json = array.toJSON() <i class="conum" data-value="2"></i><b>(2)</b>
    print(json)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initialize array with JSON string</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create and save new document using the array</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get native array object from new doc and print its elements</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get an array from the document as a JSON string</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lbl-blob"><a class="anchor" href="#lbl-blob"></a>Blobs</h3>
<div class="paragraph">
<p>Convert a <code>Blob</code> to JSON using the <code>toJSON</code> method&#8201;&#8212;&#8201;see <a href="#ex-blob">Example 14</a>.</p>
</div>
<div class="paragraph">
<p>You can also check whether a given dictionary object is a blob, or not, using <code>isBlob()</code>&#8201;&#8212;&#8201;again, see <a href="#ex-blob">Example 14</a>.</p>
</div>
<div class="paragraph">
<p>Note that the blob object must first be saved to the database (generating required metadata) before you can use the <code>toJSON</code> method.</p>
</div>
<div id="ex-blob" class="exampleblock">
<div class="title">Example 14. Blobs as JSON strings</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">// Get a document
if let doc = database.document(withID: "1000") {<i class="conum" data-value="1"></i><b>(1)</b>
    guard let blob = doc.blob(forKey: "avatar") else {
        return
    }

    let json = blob.toJSON() <i class="conum" data-value="2"></i><b>(2)</b>
    print(json)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also: <a href="blob.html" class="page">Blobs</a></p>
</div>
</div>
<div class="sect2">
<h3 id="lbl-dictionary"><a class="anchor" href="#lbl-dictionary"></a>Dictionaries</h3>
<div class="paragraph">
<p>Convert a <code>DictionaryObject</code> to and from JSON using the <code>toJSON</code> and <code>toDictionary</code> methods&#8201;&#8212;&#8201;see <a href="#ex-dictionary">Example 15</a>.</p>
</div>
<div class="paragraph">
<p>Additionally you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a 'MutableDictionaryObject' using data supplied as a JSON string.
This is done using the <code>init(json)</code> constructor-- see: <a href="#ex-dictionary">Example 15</a></p>
</li>
<li>
<p>Set data with a JSON string using <code>setJSON()</code></p>
</li>
</ul>
</div>
<div id="ex-dictionary" class="exampleblock">
<div class="title">Example 15. Dictionaries as JSON strings</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">if let doc = database.document(withID: "1000") {<i class="conum" data-value="1"></i><b>(1)</b>
    guard let dictionary = doc.dictionary(forKey: "dictionary") else {
        return
    }

    let json = dictionary.toJSON() <i class="conum" data-value="2"></i><b>(2)</b>
    print(json)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the dictionary using a JSON string</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lbl-document"><a class="anchor" href="#lbl-document"></a>Documents</h3>
<div class="paragraph">
<p>Convert a <code>Document</code> to and from JSON strings using the <code>toJSON()</code> and <code>setJSON()</code> methods&#8201;&#8212;&#8201;see <a href="#ex-document">Example 16</a>.</p>
</div>
<div class="paragraph">
<p>Additionally you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a 'MutableDocument' using data supplied as a JSON string.
This is done using the <code>init(json)</code> and-or <code>init(id: json:)</code> constructor-- see: <a href="#ex-document">Example 16</a></p>
</li>
<li>
<p>Set data with a JSON string using <code>setJSON()</code></p>
</li>
</ul>
</div>
<div id="ex-document" class="exampleblock">
<div class="title">Example 16. Documents as JSON strings</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">let database = try Database(name: "hotel")
let query = QueryBuilder
    .select(SelectResult.expression(Meta.id).as("metaId"))
    .from(DataSource.database(database))

if let doc = database.document(withID: "doc-id") {
    let json = doc.toJSON()
    print(json)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get a document as a JSON string</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Initialize a MutableDocument using the JSON string and save to a separate database</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Retrieve the document created from JSON and print values</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lbl-result"><a class="anchor" href="#lbl-result"></a>Query Results as JSON</h3>
<div class="paragraph">
<p>Convert a <code>Query Result</code> to JSON using its <code>toJSON()</code> accessor method.</p>
</div>
<div id="ex-json" class="exampleblock">
<div class="title">Example 17. Using JSON Results</div>
<div class="content">
<div class="paragraph">
<p>Use <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-swift/Classes/Result.htmls:18CouchbaseLiteSwift6ResultC6toJSONSSyF">result.toJSON()</a> to transform your result string into a JSON string, which can easily be serialized or used as required in your application. See <<ex-json>> for a working example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/examples/code_snippets/SampleCodeTest.swift">
// In this example the Hotel class is defined using Codable
//
// class Hotel : Codable {
//   var id : String = "undefined"
//   var type : String = "hotel"
//   var name : String = "undefined"
//   var city : String = "undefined"
//   var country : String = "undefined"
//   var description : String? = ""
//   var text : String? = ""
//   ... other class content
// }

let results = try query.execute()
for row in  results {

    // get the result into a JSON String
    let jsonString = row.toJSON() <i class="conum" data-value="1"></i><b>(1)</b>

    let thisJsonObj:Dictionary =
    try (JSONSerialization.jsonObject(
        with: jsonString.data(using: .utf8)!,
        options: .allowFragments)
         as? [String: Any])! <i class="conum" data-value="2"></i><b>(2)</b>

    // Use Json Object to populate Native object
    // Use Codable class to unpack JSON data to native object
    var this_hotel: Hotel = try JSONDecoder().decode(Hotel.self, from: jsonString.data(using: .utf8)!) <i class="conum" data-value="3"></i><b>(3)</b>

    // ALTERNATIVELY unpack in steps
    this_hotel.id = thisJsonObj["id"] as! String
    this_hotel.name = thisJsonObj["name"] as! String
    this_hotel.type = thisJsonObj["type"] as! String
    this_hotel.city = thisJsonObj["city"] as! String
    hotels[this_hotel.id] = this_hotel

} // end for</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the Query result as a JSON string&#8201;&#8212;&#8201;see <a href="#ex-json-format">JSON String Format</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get a native object from the JSON string</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Populate your custom object from the dictionary created from JSON data</td>
</tr>
</table>
</div>
<div id="ex-json-format" class="paragraph">
<div class="title">JSON String Format</div>
<p>If your query selects ALL then the JSON format will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-JSON hljs" data-lang="JSON">{
  database-name: {
    key1: "value1",
    keyx: "valuex"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your query selects a sub-set of available properties then the JSON format will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-JSON hljs" data-lang="JSON">{
  key1: "value1",
  keyx: "valuex"
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to . . .</div>
<ul>
<li>
<p><a href="gs-prereqs.html" class="page">Prerequisites</a></p>
</li>
<li>
<p><a href="gs-install.html" class="page">Install</a></p>
</li>
<li>
<p><a href="gs-build.html" class="page">Build and Run</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Learn more . . .</div>
<ul>
<li>
<p><a href="database.html" class="page">Databases</a></p>
</li>
<li>
<p><a href="document.html" class="page">Documents</a></p>
</li>
<li>
<p><a href="blob.html" class="page">Blobs</a></p>
</li>
<li>
<p><a href="replication.html" class="page">Remote Sync Gateway</a></p>
</li>
<li>
<p><a href="conflict.html" class="page">Handling Data Conflicts</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Dive Deeper . . .</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Mobile Forum</a> |
<a href="https://blog.couchbase.com/category/couchbase-mobile/?ref=blog-menu">Blog</a> |
<a href="https://docs.couchbase.com/tutorials/">Tutorials</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Any change to this reserved key will be detected when it is saved and will result in a Couchbase exception (Error Code 5&#8201;&#8212;&#8201;`CorruptRevisionData`)
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>© 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
