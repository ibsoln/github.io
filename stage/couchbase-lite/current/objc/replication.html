<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Data Sync using Sync Gateway | Couchbase Docs</title>
<link rel="canonical" href="http://127.0.0.1:5000/couchbase-lite/current/objc/replication.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite for Objective-C -- Synchronizing data changes between local and remote databases using Sync Gateway">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">
<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/objc/replication.html">
<meta name="generator" content="Antora 3.0.0-alpha.6">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://docs.couchbase.com">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="http://127.0.0.1:5000/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a href="https://cloud.couchbase.com/sign-up" class="free-trial-link" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  <i class="fas fa-cloud"></i>
                  Free Trial
                </a>
                <a class="btn btn-primary try-btn"  onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                </a>
              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list">
          <option value="3.0" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-active.html">Using Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:android:{cbl-pg-releasenotes}">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/p2psync-websocket-using-active.html">Using Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-c">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:clang:{cbl-pg-releasenotes}">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">C#.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Using Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-net">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:csharp:{cbl-pg-releasenotes}">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Using Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-java/index.html?">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:java:{cbl-pg-releasenotes}">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Using Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:objc:{cbl-pg-releasenotes}">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-active.html">Using Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:{cbl-pg-releasenotes}">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:compatibility.adoc">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:supported-os.adoc">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Sync&#160;Gateway</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties.html">Configure</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">REST API</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list">
          <option value="3.0" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties.html">Configuration <em><sup>(pre-3.0)</sup></em></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">REST API Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-client-app.html">Use the REST API?</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Certificate Authentication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-To</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign Users to Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRs for Access Grants</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Couchbase Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync Using App</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{sgw-xref}sync-inter-syncgateway-conflict-resolution.adoc[Conflict Resolution]</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/what-are-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SGCollect Info</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS-level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG-Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG-Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Logging Pre2 1</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
  </div>
</aside>
<aside class="toc sidebar">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/objc/pages/replication.adoc" title="Edit Page" target="_blank" rel="noopener">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="quickstart.html">Objective-C</a></li>
<li class="crumb"><a href="landing-replications.html">Data Sync</a></li>
<li class="crumb"><a href="replication.html">Remote Sync Gateway</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Data Sync using Sync Gateway</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite for Objective-C&#8201;&#8212;&#8201;Synchronizing data changes between local and remote databases using Sync Gateway</em><br>
Related Content&#8201;&#8212;&#8201;<a href="conflict.html" class="page">Handling Data Conflicts</a> | <a href="dbreplica.html" class="page">Intra-device Data Sync</a> | <a href="p2psync-websocket.html" class="page">Peer-to-Peer</a></p>
</div>
</blockquote>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Code Snippets</div>
All code examples are indicative only.
They demonstrate the basic concepts and approaches to using a feature.
Use them as inspiration and adapt these examples to best practice when developing applications for your platform.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite for Objective-C provides API support for secure, bi-directional, synchronization of data changes between mobile applications and a central server database.
It does so by using a replicator to interact with Sync Gateway.
Simply put, the replicator is designed to send documents from a source to a target database.
In this case, between a local Couchbase Lite database and remote Sync Gateway database (server or cloud).</p>
</div>
<div class="paragraph">
<p>This content provides sample code and configuration examples covering the implementation of a replication using Sync Gateway.</p>
</div>
<div class="paragraph">
<p>Your application runs a replicator (also referred to here as a client), which  will initiate connection with a Sync Gateway (also referred to here as a server) and participate in the replication of database changes to bring both local and remote databases into sync.</p>
</div>
<div class="paragraph">
<p>Subsequent sections provide additional details and examples for the main configuration options.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replication-protocol"><a class="anchor" href="#replication-protocol"></a>Replication Protocol</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="scheme"><a class="anchor" href="#scheme"></a>Scheme</h3>
<div class="paragraph">
<p>Couchbase Mobile uses a replication protocol based on WebSockets fof replication.
To use this protocol the replication URL should specify WebSockets as the URL scheme (see the <a href="#lbl-cfg-tgt">[lbl-cfg-tgt]</a> section below).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Incompatibilities</dt>
<dd>
<p>Couchbase Lite&#8217;s replication protocol is <strong>incompatible</strong> with CouchDB-based databases.
And since Couchbase Lite 2.x+ only supports the new protocol, you will need to run a version of Sync Gateway that supports it&#8201;&#8212;&#8201;see: <a href="compatibility.html" class="page">Compatibility</a>.</p>
</dd>
<dt class="hdlist1">Legacy Compatibility</dt>
<dd>
<p>Clients using Couchbase Lite 1.x can continue to use <code>http</code> as the URL scheme.
Sync Gateway 2.x+ will automatically use:</p>
<div class="ulist">
<ul>
<li>
<p>The 1.x replication protocol when a Couchbase Lite 1.x client connects through <code>http://localhost:4984/db</code></p>
</li>
<li>
<p>The 2.0 replication protocol when a Couchbase Lite 2.0 client connects through <code>ws://localhost:4984/db</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can find further information in our blog: <a href="https://blog.couchbase.com/data-replication-couchbase-mobile/" target="_blank" rel="noopener">Introducing the Data Replication Protocol</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="lbl-repl-ord"><a class="anchor" href="#lbl-repl-ord"></a>Ordering</h3>
<div class="paragraph">
<p>To optimize for speed, the replication protocol doesn&#8217;t guarantee that documents will be received in a particular order.
So we don&#8217;t recommend to rely on that when using the replication or database change listeners for example.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-summary"><a class="anchor" href="#configuration-summary"></a>Configuration Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You should configure and initialize a replicator for each Couchbase Lite database instance you want to sync.
<a href="#ex-simple-repl">Example 1</a> shows the configuration and initialization process.</p>
</div>
<div id="ex-simple-repl" class="exampleblock">
<div class="title">Example 1. Replication configuration and initialization</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="1"></i><b>(1)</b>

thisConfig.replicatorType = kCBLReplicatorTypePush;

thisConfig.continuous = YES;

// Configure Server Authentication
// Here - expect and accept self-signed certs
thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="2"></i><b>(2)</b>

// Configure Client Authentication
// Here set client to use basic authentication
// Providing username and password credentials
// If prompted for them by server
thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="3"></i><b>(3)</b>

/* Optionally set custom conflict resolver call back */
thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="4"></i><b>(4)</b>

// Apply configuration settings to the replicator
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="5"></i><b>(5)</b>

// Optionally add a change listener <i class="conum" data-value="6"></i><b>(6)</b>
// Retain token for use in deletion
id&lt;CBLListenerToken&gt; thisListenerToken
  = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
      if (thisChange.status.activity == kCBLReplicatorStopped) {
        NSLog(@"Replication stopped");
        } else {
        NSLog(@"Status: %d", thisChange.status.activity);
        };
    }];
// Run the replicator using the config settings
[thisReplicator start]; <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><strong>Notes on Example</strong></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html">ReplicatorConfiguration</a> class&#8217;s constructor&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(im)initWithDatabase:target:">-initWithDatabase:target:</a>&#8201;&#8212;&#8201;to initialize the replicator configuration with the local database&#8201;&#8212;&#8201;see also: <a href="#lbl-cfg-tgt">[lbl-cfg-tgt]</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configure how the client will authenticate the server.
Here we say connect only to servers presenting a self-signed certificate.
By default, clients accept only servers presenting certificates that can be verified using the OS bundled Root CA Certificates&#8201;&#8212;&#8201;see: <a href="#lbl-svr-auth">[lbl-svr-auth]</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Configure the credentials the client will present to the server.
Here we say to provide <em>Basic Authentication</em> credentials. Other options are available&#8201;&#8212;&#8201;see: <a href="#lbl-client-auth">[lbl-client-auth]</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Configure how the replication should handle conflict resolution&#8201;&#8212;&#8201;see: <a href="conflict.html" class="page">Handling Data Conflicts</a> topic for mor on conflict resolution.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Initialize the replicator using your configuration object&#8201;&#8212;&#8201;see: <a href="#lbl-init-repl">[lbl-init-repl]</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Optionally, register an observer, which will notify you of changes to the replication status&#8201;&#8212;&#8201;see: <a href="#lbl-repl-mon">[lbl-repl-mon]</a></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Start the replicator &#8201;&#8212;&#8201;see: <a href="#lbl-repl-start">[lbl-repl-start]</a>.</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-cfg-repl" class="paragraph">
<p>== Configure</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-cfg-tgt">[lbl-cfg-tgt]</a>  |  <a href="#lbl-cfg-sync">[lbl-cfg-sync]</a>  |  <a href="#lbl-cfg-keep-alive">[lbl-cfg-keep-alive]</a>  |  <a href="#lbl-svr-auth">[lbl-svr-auth]</a>  | <a href="#lbl-client-auth">[lbl-client-auth]</a> | <a href="#lbl-repl-evnts">[lbl-repl-evnts]</a> |  <a href="#lbl-repl-hdrs">[lbl-repl-hdrs]</a> |  <a href="#lbl-repl-ckpt">[lbl-repl-ckpt]</a> |  <a href="#lbl-repl-fltrs">[lbl-repl-fltrs]</a> | <a href="#lbl-repl-chan">[lbl-repl-chan]</a> | <a href="#lbl-repl-delta">[lbl-repl-delta]</a></p>
</dd>
</dl>
</div>
<div id="lbl-cfg-tgt" class="paragraph">
<p>=== Configure Target</p>
</div>
<div class="paragraph">
<p>Use the
<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html">ReplicatorConfiguration</a> class and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(im)initWithDatabase:target:">-initWithDatabase:target:</a> constructor to initialize the replication configuration with local and remote database locations.</p>
</div>
<div class="paragraph">
<p>The constructor provides:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the name of the local database to be sync&#8217;d</p>
</li>
<li>
<p>the server&#8217;s URL (including the port number and the name of the remote database to sync with)</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>It is expected that the app will identify the IP address and URL and append the remote database name to the URL endpoint, producing for example: <code>wss://10.0.2.2:4984/travel-sample</code></p>
</div>
<div class="paragraph">
<p>The URL scheme for web socket URLs uses <code>ws:</code> (non-TLS) or <code>wss:</code> (SSL/TLS) prefixes.</p>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesn’t exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="66"></i><b>(66)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="67"></i><b>(67)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="68"></i><b>(68)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="69"></i><b>(69)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="70"></i><b>(70)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="72"></i><b>(72)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note use of the <code>wss://</code> prefix to ensure TLS encryption (strongly recommended in production)</td>
</tr>
</table>
</div>
<div id="lbl-cfg-sync" class="paragraph">
<p>=== Sync Mode</p>
</div>
<div class="paragraph">
<p>Here we define the direction and type of replication we want to initiate.</p>
</div>
<div class="paragraph">
<p>We use <code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html">ReplicatorConfiguration</a></code> class&#8217;s <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)replicatorType">replicatorType</a> and
<code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)continuous">continuous</a></code> parameters, to tell the replicator:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The direction of the replication:
<code><strong>pushAndPull</strong></code>; <code>pull</code>; <code>push</code></p>
</li>
<li>
<p>The type of replication, that is:</p>
<div class="ulist">
<ul>
<li>
<p>Continuous&#8201;&#8212;&#8201;remaining active indefinitely to replicate changed documents (<code>continuous=true</code>).</p>
</li>
<li>
<p>Ad-hoc&#8201;&#8212;&#8201;a one-shot replication of changed documents (<code>continuous=false</code>).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">thisConfig.replicatorType = kCBLReplicatorTypePush;

thisConfig.continuous = YES;</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-cfg-keep-alive" class="paragraph">
<p>=== Retry Configuration</p>
</div>
<div class="paragraph">
<p>Couchbase Lite for Objective-C&#8217;s replication retry logic assures a resilient connection.</p>
</div>
<div class="paragraph">
<p>The replicator minimizes the chance and impact of dropped connections by maintaining a heartbeat; essentially pinging the Sync Gateway at a configurable interval to ensure the connection remains alive.</p>
</div>
<div class="paragraph">
<p>In the event it detects a transient error, the replicator will attempt to reconnect, stopping only when the connection is re-established, or the number of retries exceeds the retry limit (9 times for a single-shot replication and unlimited for a continuous replication).</p>
</div>
<div class="paragraph">
<p>On each retry the interval between attempts is increased exponentially (exponential backoff) up to the maximum wait time limit (5 minutes).</p>
</div>
<div class="paragraph">
<p>The REST API provides configurable control over this replication retry logic using a set of configiurable properties&#8201;&#8212;&#8201;see: <a href="#tbl-repl-retry">Table 1</a>.</p>
</div>
<table id="tbl-repl-retry" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Replication Retry Configuration Properties</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 30%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Property</p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock">Use cases</p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock">Description</p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)heartbeat">heartbeat()</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Reduce to detect connection errors sooner</p>
</li>
<li>
<p>Align to load-balancer or proxy <code>keep-alive</code> interval&#8201;&#8212;&#8201;see Sync Gateway&#8217;s topic <a href="../../../sync-gateway/current/load-balancer.html#websocket-connection" class="page">Load Balancer - Keep Alive</a></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The interval (in seconds) between the heartbeat pulses.</p>
</div>
<div class="paragraph">
<p>Default: The replicator pings the Sync Gateway every 300 seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)maxRetries">maxRetries()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change this to limit or extend the number of retry attempts.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of retry attempts</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set this to zero (0) to prevent any retry attempt</p>
</li>
<li>
<p>The retry attempt count is reset when the replicator is able to connect and replicate</p>
</li>
<li>
<p>Default values are:</p>
<div class="ulist">
<ul>
<li>
<p>Single-shot replication = 9;</p>
</li>
<li>
<p>Continuous replication = maximum integer value</p>
</li>
</ul>
</div>
</li>
<li>
<p>Negative values generate a Couchbase exception <code>InvalidArgumentException</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)maxRetryWaitTime">maxRetryWaitTime()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change this to adjust the interval between retries.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum interval between retry attempts</p>
</div>
<div class="paragraph">
<p>Whilst you can configure the <strong>maximum permitted</strong> wait time,  each individual interval is calculated by the replicator&#8217;s exponential backoff algorithm and is not configurable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Default value: 300 seconds (5 minutes)</p>
</li>
<li>
<p>Zero or negative values generate a Couchbase exception, <code>InvalidArgumentException</code>.</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When necessary you can adjust any or all of those configurable values&#8201;&#8212;&#8201;see: <a href="#ex-repl-retry">[ex-repl-retry]</a> for how to do this.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">id target =
  [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

CBLReplicatorConfiguration* config =
    [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
config.type = kCBLReplicatorTypePush;
config.continuous: YES;
//  other config as required . . .

config.heartbeat = 150; <i class="conum" data-value="1"></i><b>(1)</b>

config.maxretries = 20; <i class="conum" data-value="2"></i><b>(2)</b>

config.maxretrywaittime = 600; <i class="conum" data-value="3"></i><b>(3)</b>

//  other config as required . . .
repl = [[CBLReplicator alloc] initWithConfig: config];

// Cleanup:
repl = nil;</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we use <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)heartbeat">heartbeat()</a> to set the required interval (in seconds) between the heartbeat pulses</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we use <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)maxRetries">maxRetries()</a> to set the required number of retry attempts</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we use <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)maxRetryWaitTime">maxRetryWaitTime()</a> to set the required interval between retry attempts.</td>
</tr>
</table>
</div>
<div id="lbl-svr-auth" class="paragraph">
<p>=== Server Authentication</p>
</div>
<div class="paragraph">
<p>Define the credentials your app (the client) is expecting to receive from the Sync Gateway (the server) in order to ensure it is prepared to continue with the sync.</p>
</div>
<div class="paragraph">
<p>Note that the client cannot authenticate the server if TLS is turned off.
When TLS is enabled (Sync Gateway&#8217;s default) the client <em>must</em> authenticate the server.
If the server cannot provide acceptable credentials then the connection will fail.</p>
</div>
<div class="paragraph">
<p>Use <code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html">ReplicatorConfiguration</a></code> properties <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)acceptOnlySelfSignedServerCertificate">acceptOnlySelfSignedServerCertificate</a> and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)pinnedServerCertificate">setPinnedServerCertificate()</a>, to tell the replicator how to verify server-supplied TLS server certificates.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is a pinned certificate, nothing else matters, the server cert must <strong>exactly</strong> match the pinned certificate.</p>
</li>
<li>
<p>If there are no pinned certs and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)acceptOnlySelfSignedServerCertificate">acceptOnlySelfSignedServerCertificate</a> is <code>true</code> then any self-signed certificate is accepted.  Certificates that are not self signed are rejected, no matter who signed them.</p>
</li>
<li>
<p>If there are no pinned certificates and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)acceptOnlySelfSignedServerCertificate">acceptOnlySelfSignedServerCertificate</a> is <code>false</code> (default), the client validates the server’s certificates against the system CA certificates.  The server must supply a chain of certificates whose root is signed by one of the certificates in the system CA bundle.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_ca-cert"></a>CA Cert</p>
</li>
<li>
<p><a id="tabset1_self-signed-cert"></a>Self Signed Cert</p>
</li>
<li>
<p><a id="tabset1_pinned-certificate"></a>Pinned Certificate</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_ca-cert">
<div class="paragraph">
<p>Set the client to expect and accept only CA attested certificates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// Configure Server Security -- only accept CA Certs
thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the default.
Only certificate chains with roots signed by a trusted CA are allowed.
Self signed certificates are not allowed.</td>
</tr>
</table>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_self-signed-cert">
<div class="paragraph">
<p>Set the client to expect and accept only self-signed certificates</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// Configure Server Authentication
// Here - expect and accept self-signed certs
thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set this to <code>true</code> to accept any self signed cert.
Any certificates that are not self-signed are rejected.</td>
</tr>
</table>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_pinned-certificate">
<div class="paragraph">
<p>Set the client to expect and accept only a pinned certificate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m#L2436-L2455">NSURL *certURL =
  [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
NSData *data =
  [[NSData alloc] initWithContentsOfURL: certURL];
SecCertificateRef certificate =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

NSURL *url =
  [NSURL URLWithString:@"ws://localhost:4984/db"];

CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

CBLReplicatorConfiguration *thisConfig =
  [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                      target:target];
thisConfig.pinnedServerCertificate =
  (SecCertificateRef)CFAutorelease(certificate);

thisConfig.acceptOnlySelfSignedServerCertificate=false;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>This all assumes that you have configured the Sync Gateway to provide the appropriate SSL certificates, and have included the appropriate certificate in your app bundle&#8201;&#8212;&#8201;for more on this see: <a href="#lbl-cert-pinning">[lbl-cert-pinning]</a>.</p>
</div>
<div id="lbl-client-auth" class="paragraph">
<p>=== Client Authentication</p>
</div>
<div class="paragraph">
<p>By default, Sync Gateway does not enable authentication.
This is to make it easier to get up and running with synchronization.
You can enable authentication with the following properties in the configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "databases": {
    "mydatabase": {
      "users": {
        "GUEST": {"disabled": true}
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To authenticate with Sync Gateway, an associated user must first be created.
Sync Gateway users can be created through the <a href="../../../sync-gateway/current/rest-api-admin.html#/user/post__db___user_" class="page"><code>POST /{tkn-db}/_user</code></a> endpoint on the Admin REST API.
Provided that the user exists on Sync Gateway, there are two ways to authenticate from a Couchbase Lite client: Basic Authentication or Session Authentication.</p>
</div>
<div class="paragraph">
<p>==== Basic Authentication</p>
</div>
<div class="paragraph">
<p>You can provide a user name and password to the basic authenticator class method.
Under the hood, the replicator will send the credentials in the first request to retrieve a <code>SyncGatewaySession</code> cookie and use it for all subsequent requests during the replication.
This is the recommended way of using basic authentication.
<a href="#ex-base-auth">Basic Authentication</a> shows how to initiate a one-shot replication as the user <strong>username</strong> with the password <strong>password</strong>.</p>
</div>
<div id="ex-base-auth" class="paragraph">
<div class="title">Basic Authentication</div>
<p>Unresolved include directive in modules/ROOT/pages/_partials/authentication.adoc - include::ROOT:partial$_block_show_snippet.adoc[]
:param-tags!:</p>
</div>
<div class="paragraph">
<p>==== Session Authentication</p>
</div>
<div class="paragraph">
<p>Session authentication is another way to authenticate with Sync Gateway.
A user session must first be created through the <a href="../../../sync-gateway/current/rest-api.html#/session/post__db___session" class="page"><code>POST /{tkn-db}/_session</code></a> endpoint on the Public REST API.
The HTTP response contains a session ID which can then be used to authenticate as the user it was created for.</p>
</div>
<div class="paragraph">
<p><a href="#ex-session-auth">Session Authentication</a> shows how to initiate a one-shot replication with the session ID that is returned from the <code>POST /{tkn-db}/_session</code> endpoint.</p>
</div>
<div id="ex-session-auth" class="paragraph">
<div class="title">Session Authentication</div>
<p>Unresolved include directive in modules/ROOT/pages/_partials/authentication.adoc - include::ROOT:partial$_block_show_snippet.adoc[]
:param-tags!:</p>
</div>
<div id="lbl-repl-hdrs" class="paragraph">
<p>=== Custom&#160;Headers</p>
</div>
<div class="paragraph">
<p>Custom headers can be set on the configuration object.
And the replicator will send those header(s) in every request.
As an example, this feature can be useful to pass additional credentials when there is an authentication or authorization step being done by a proxy server (between Couchbase Lite and Sync Gateway).</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesn’t exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="66"></i><b>(66)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="67"></i><b>(67)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="68"></i><b>(68)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="69"></i><b>(69)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="70"></i><b>(70)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="72"></i><b>(72)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-fltrs" class="paragraph">
<p>=== Replication Filters</p>
</div>
<div class="paragraph">
<p>Replication Filters allow you to have quick control over which documents are stored as the result of a push and/or pull replication.</p>
</div>
<div class="paragraph">
<p>==== Push Filter</p>
</div>
<div class="paragraph">
<p>A push filter allows an app to push a subset of a database to the server, which can be very useful in some circumstances.
For instance, high-priority documents could be pushed first, or documents in a "draft" state could be skipped.</p>
</div>
<div class="paragraph">
<p>The following example filters out documents whose <code>type</code> property is equal to <code>draft</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesn’t exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="66"></i><b>(66)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="67"></i><b>(67)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="68"></i><b>(68)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="69"></i><b>(69)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="70"></i><b>(70)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="72"></i><b>(72)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The callback should follow the semantics of a <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">pure function</a>.
Otherwise, long running functions would slow down the replicator considerably.
Furthermore, your callback should not make assumptions about what thread it is being called on.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>==== Pull Filter</p>
</div>
<div class="paragraph">
<p>A pull filter gives an app the ability to validate documents being pulled, and skip ones that fail.
This is an important security mechanism in a peer-to-peer topology with peers that are not fully trusted.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pull replication filters are not a substitute for channels.
Sync Gateway <a href="../../../sync-gateway/current/channels.html" class="page">channels</a> are designed to be scalable (documents are filtered on the server) whereas a pull replication filter is applied to a document once it has been downloaded.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesn’t exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="66"></i><b>(66)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="67"></i><b>(67)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="68"></i><b>(68)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="69"></i><b>(69)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="70"></i><b>(70)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="72"></i><b>(72)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The callback should follow the semantics of a <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">pure function</a>.
Otherwise, long running functions would slow down the replicator considerably.
Furthermore, your callback should not make assumptions about what thread it is being called on.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Losing access to a document (via the Sync Function) also triggers the pull replication filter.
Filtering out such an event would retain the document locally.
As a result, there would be a local copy of the document disjointed from the one that resides on Couchbase Server.
Further updates to the document stored on Couchbase Server would not be received in pull replications and further local edits could be potentially pushed, which would result in 409 errors since access has been revoked.
</td>
</tr>
</table>
</div>
<div id="lbl-repl-chan" class="paragraph">
<p>=== Channels</p>
</div>
<div class="paragraph">
<p>By default, Couchbase Lite gets all the channels to which the configured user account has access.
This behavior is suitable for most apps that rely on <a href="../../../sync-gateway/current/authentication-users.html" class="page">user authentication</a> and the <a href="../../../sync-gateway/current/sync-function-api.html" class="page">sync function</a> to specify which data to pull for each user.</p>
</div>
<div class="paragraph">
<p>Optionally, it&#8217;s also possible to specify a comma-separated list of channel names on Couchbase Lite&#8217;s replicator configuration object.
In this case, the replication from Sync Gateway will only pull documents tagged with those channels.</p>
</div>
<div id="lbl-repl-delta" class="paragraph">
<p>=== Delta Sync</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This is an <a href="https://www.couchbase.com/products/editions">Enterprise Edition</a> feature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With Delta Sync <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>, only the changed parts of a Couchbase document are replicated.
This can result in significant savings in bandwidth consumption as well as throughput improvements, especially when network bandwidth is typically constrained.</p>
</div>
<div class="paragraph">
<p>Replications to a Server (for example, a Sync Gateway, or passive listener) automatically use delta sync if the property is enabled at database level by the server&#8201;&#8212;&#8201;see: <a href="../../../sync-gateway/current/configuration-properties.html#databases-foo_db-delta_sync" class="page">databases.$db.delta_sync.enabled</a>.</p>
</div>
<div class="paragraph">
<p><a href="dbreplica.html" class="page">Intra-device Data Sync</a> replications automatically <strong>disable</strong> delta sync, whilst <a href="p2psync-websocket.html" class="page">Peer-to-Peer</a> replications automatically <strong>enable</strong> delta sync.</p>
</div>
<div id="lbl-init-repl" class="paragraph">
<p>== Initialize</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-repl-start">[lbl-repl-start]</a>  | <a href="#lbl-repl-ckpt">[lbl-repl-ckpt]</a></p>
</dd>
</dl>
</div>
<div id="lbl-repl-start" class="paragraph">
<p>=== Start Replicator</p>
</div>
<div class="paragraph">
<p>Use the <code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html">Replicator</a></code> class&#8217;s <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)initWithConfig:">initWith(config:)</a> constructor, to initialize the replicator with the configuration you have defined.
You can, optionally, add a change listener (see <a href="#lbl-repl-mon">[lbl-repl-mon]</a>) before starting the replicator running using <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)start">start()</a>.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// Apply configuration settings to the replicator
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="1"></i><b>(1)</b>

// Run the replicator using the config settings
[thisReplicator start]; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initialize the replicator with the configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Start the replicator</td>
</tr>
</table>
</div>
<div id="lbl-repl-ckpt" class="paragraph">
<p>=== Checkpoint Starts</p>
</div>
<div class="paragraph">
<p>Replicators use <a href="refer-glossary.html#checkpoint" class="page">checkpoints</a> to keep track of documents sent to the target database.
Without <a href="refer-glossary.html#checkpoint" class="page">checkpoints</a> , Couchbase Lite would replicate the entire database content to the target database on each connection, even though previous replications may already have replicated some or all of that content.</p>
</div>
<div class="paragraph">
<p>This functionality is generally not a concern to application developers.
However, if you do want to force the replication to start again from zero, use the <a href="refer-glossary.html#checkpoint" class="page">checkpoint</a> reset method <code>replicator.resetCheckpoint()</code> <strong>before</strong> starting the replicator.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">[replicator resetCheckpoint];
[replicator start];</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-mon" class="paragraph">
<p>== Monitor</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-repl-chng">[lbl-repl-chng]</a>  |
<a href="#lbl-repl-status">[lbl-repl-status]</a>  |
<a href="#lbl-repl-evnts">[lbl-repl-evnts]</a> |
<a href="#lbl-repl-pend">[lbl-repl-pend]</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can monitor a replication’s status by using a combination of <a href="#lbl-repl-chng">[lbl-repl-chng]</a> and the <code>replication.status.activity</code> property&#8201;&#8212;&#8201;see; <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorStatus.html#/c:objc(cs)CBLReplicatorStatus(py)activity">activity enum</a>.
This enables you to know, for example, when the replication is actively transferring data and when it has stopped.</p>
</div>
<div class="paragraph">
<p>You can also choose to monitor document changes&#8201;&#8212;&#8201;see: <a href="#lbl-repl-evnts">[lbl-repl-evnts]</a>.</p>
</div>
<div id="lbl-repl-chng" class="paragraph">
<p>== Change Listeners
Use this to monitor changes and to inform on sync progress; this is an optional step.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Best Practice</div>
You should register the listener before starting your replication, to avoid having to do a restart to activate it &#8230;&#8203; and don&#8217;t forget to save the token so you can remove the listener later
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html">Replicator</a> class to add a change listener as a callback to the Replicator (<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)addChangeListener:">addChangeListener(_:)</a>)&#8201;&#8212;&#8201;see: <a href="#ex-repl-mon">[ex-repl-mon]</a>.
You will then be asynchronously notified of state changes.</p>
</div>
<div class="paragraph">
<p>Remove your change listener before stopping the replicator&#8201;&#8212;&#8201;use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)removeChangeListenerWithToken">removeChangeListenerWithToken(CBLListenerToken:)</a> method to do this.</p>
</div>
<div id="lbl-repl-status" class="paragraph">
<p>== Replicator Status</p>
</div>
<div class="paragraph">
<p>You can use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html">Replicator</a> class&#8217;s <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(py)status">status</a> property to check the replicator status.
That is, whether it is actively transferring data or if it has stopped&#8201;&#8212;&#8201;see: <a href="#ex-repl-mon">[ex-repl-mon]</a>.</p>
</div>
<div class="paragraph">
<p>The returned <em>ReplicationStatus</em> structure comprises:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorStatus.html#/c:objc(cs)CBLReplicatorStatus(py)activity">activity enum</a>&#8201;&#8212;&#8201;stopped, offline, connecting, idle or busy&#8201;&#8212;&#8201;see states described in: <a href="#tbl-states">Table 2</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorStatus.html#/c:objc(cs)CBLReplicatorStatus(py)progress)">progress enum</a></p>
<div class="ulist">
<ul>
<li>
<p>completed&#8201;&#8212;&#8201;the total number of changes completed</p>
</li>
<li>
<p>total&#8201;&#8212;&#8201;the total number of changes to be processed</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicatorStatus.html#/c:objc(cs)CBLReplicatorStatus(py)error">error enum</a>&#8201;&#8212;&#8201;the current error, if any</p>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset2_adding-a-change-listener"></a>Adding a Change Listener</p>
</li>
<li>
<p><a id="tabset2_using-replicator-status"></a>Using replicator.status</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset2_adding-a-change-listener">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc">// Retain token for use in deletion
id&lt;CBLListenerToken&gt; thisListenerToken
  = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
      if (thisChange.status.activity == kCBLReplicatorStopped) {
        NSLog(@"Replication stopped");
        } else {
        NSLog(@"Status: %d", thisChange.status.activity);
        };
    }];</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset2_using-replicator-status">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc">if (thisChange.status.activity == kCBLReplicatorStopped) {
  NSLog(@"Replication stopped");
  } else {
  NSLog(@"Status: %d", thisChange.status.activity);
  };</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-states" class="paragraph">
<p>=== Replication States
<a href="#tbl-states">Table 2</a> shows the different states, or activity levels, reported in the API; and the meaning of each.</p>
</div>
<table id="tbl-states" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Replicator activity levels</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">State</p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock">Meaning</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>STOPPED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication is finished or hit a fatal error.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>OFFLINE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replicator is offline as the remote host is unreachable.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>CONNECTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replicator is connecting to the remote host.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>IDLE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication caught up with all the changes available from the server.
The <code>IDLE</code> state is only used in continuous replications.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>BUSY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication is actively transferring data.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The replication change object also has properties to track the progress (<code>change.status.completed</code> and <code>change.status.total</code>).
Since the replication occurs in batches the total count can vary through the course of a replication.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>=== Replication Status and App Life Cycle</p>
</div>
<div class="paragraph">
<p>The following diagram describes the status changes when the application starts a replication, and when the application is being backgrounded or foregrounded by the OS.
It applies to iOS only.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/replicator-states.png" alt="replicator states">
</div>
</div>
<div class="paragraph">
<p>Additionally, on iOS, an app already in the background may be terminated.
In this case, the <code>Database</code> and <code>Replicator</code> instances will be <code>null</code> when the app returns to the foreground.
Therefore, as preventive measure, it is recommended to do a <code>null</code> check when the app enters the foreground, and to re-initialize the database and replicator if any of those is <code>null</code>.</p>
</div>
<div class="paragraph">
<p>On other platforms, Couchbase Lite doesn&#8217;t react to OS backgrounding or foregrounding events and replication(s) will continue running as long as the remote system does not terminate the connection and the app does not terminate.
It is generally recommended to stop replications before going into the background otherwise socket connections may be closed by the OS and this may interfere with the replication process.</p>
</div>
<div id="lbl-repl-evnts" class="paragraph">
<p>== Monitor Document Changes</p>
</div>
<div class="paragraph">
<p>You can choose to register for document updates during a replication.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You should register the listener before starting your replication, to avoid having to do a restart to activate it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the code snippet in <a href="#ex-reg-doc-listener">[ex-reg-doc-listener]</a> registers a listener to monitor document replication performed by the replicator referenced by the variable <code>replicator</code>.
It prints the document ID of each document received and sent.
Stop the listener as shown in <a href="#ex-stop-doc-listener">[ex-stop-doc-listener]</a>.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesn’t exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="66"></i><b>(66)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="67"></i><b>(67)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="68"></i><b>(68)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="69"></i><b>(69)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="70"></i><b>(70)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="72"></i><b>(72)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">

</div>
</div>
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">[replicator removeChangeListenerWithToken: token];</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>=== Document Access Removal Behavior</p>
</div>
<div class="paragraph">
<p>When access to a document is removed on Sync Gateway (see: Sync Gateway&#8217;s <a href="../../../sync-gateway/current/sync-function-api.html" class="page">Sync Function</a>), the document replication listener sends a notification with the <code>AccessRemoved</code> flag set to <code>true</code> and subsequently purges the document from the database.</p>
</div>
<div id="lbl-repl-pend" class="paragraph">
<p>== Documents Pending Push</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)isDocumentPending:error:">CBLReplicator.isDocumentPending()</a> is quicker and more efficient.
Use it in preference to returning a list of pending document IDs, where possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can check whether documents are waiting to be pushed in any forthcoming sync by using either of the following API methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)pendingDocumentIDs:">CBLReplicator.pendingDocumentIDs()</a> method, which returns a list of document IDs that have local changes, but which have not yet been pushed to the server.</p>
<div class="paragraph">
<p>This can be very useful in tracking the progress of a push sync, enabling the app to provide a visual indicator to the end user on its status, or decide when it is safe to exit.</p>
</div>
</li>
<li>
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)isDocumentPending:error:">CBLReplicator.isDocumentPending()</a> method to quickly check whether an individual document is pending a push.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">
CBLDatabase *database = self.db;
NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
CBLURLEndpoint *target =
  [[CBLURLEndpoint alloc] initWithURL: url];
CBLReplicatorConfiguration *config =
  [[CBLReplicatorConfiguration alloc]
    initWithDatabase:database
    target:target];

config.replicatorType = kCBLReplicatorTypePush;

CBLReplicator *replicator =
  [[CBLReplicator alloc] initWithConfig:config];

// Get list of pending doc IDs
NSError* err = nil;
NSSet *mydocids =
  [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="1"></i><b>(1)</b>


if ([mydocids count] &gt; 0) {

  NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

  [replicator addChangeListener:^(CBLReplicatorChange *change) {

    NSLog(@"Replicator activity level is %u", change.status.activity);
    // iterate and report-on the pending doc IDs  in 'mydocids'
    for (thisid in mydocids) {

      NSError* err = nil;
      if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="2"></i><b>(2)</b>
        NSLog(@"Doc ID %@ now pushed", thisid);
      }
    }

  }];
  [replicator start];

};</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)pendingDocumentIDs:">CBLReplicator.pendingDocumentIDs()</a> returns a list of the document IDs for all documents waiting to be pushed.
This is a snapshot and may have changed by the time the response is received and processed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)isDocumentPending:error:">CBLReplicator.isDocumentPending()</a> returns <code>true</code> if the document is waiting to be pushed, and <code>false</code> otherwise.</td>
</tr>
</table>
</div>
<div id="lbl-repl-stop" class="paragraph">
<p>== Stop</p>
</div>
<div class="paragraph">
<p>Stopping a replication is straightforward.
It is done using <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)stop">stop()</a>.
This initiates an asynchronous operation and so is not necessarily immediate.
Your app should account for this potential delay before attempting any subsequent operations, for example closing the database.</p>
</div>
<div class="paragraph">
<p>You can find further information on database operations in {xref-cbl-gp-database}.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Best Practice</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When you start a change listener, save the returned token, you will need it when you remove the listener</p>
</li>
<li>
<p>Remove any active change listener prior to stopping your replication</p>
</li>
<li>
<p>Ensure the replication has completely stopped by checking for a replication status = STOPPED, before closing any associated database</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// Remove the change listener
[thisReplicator removeChangeListenerWithToken: thisListenerToken];

// Stop the replicator
[thisReplicator stop];</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we stop our change listener</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we initiate the stopping of the replication using the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc/Classes/CBLReplicator.html#/c:objc(cs)CBLReplicator(im)stop">stop()</a> method.<br>
Remove any active <a href="#lbl-repl-chng">change listener</a> before stopping the replicator.</td>
</tr>
</table>
</div>
<div id="lbl-nwk-errs" class="paragraph">
<p>== Error Handling</p>
</div>
<div class="paragraph">
<p>When <em>replicator</em> detects a network error it updates its status depending on the error type (permanent or temporary) and returns an appropriate HTTP error code.</p>
</div>
<div class="paragraph">
<p>The following code snippet adds a <code>Change Listener</code>, which monitors a replication for errors and logs the the returned error code.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">[replicator addChangeListener:^(CBLReplicatorChange *change) {
    if (change.status.error) {
        NSLog(@"Error code: %ld", change.status.error.code);
    }
}];</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>For permanent network errors</strong> (for example, <code>404</code> not found, or <code>401</code> unauthorized):
<em>Replicator</em> will stop permanently, whether <code>setContinuous</code>  is <em>true</em> or <em>false</em>. Of course, it sets its status to <code>STOPPED</code></p>
</div>
<div class="paragraph">
<p><strong>For recoverable or temporary errors:</strong> <em>Replicator</em> sets its status to <code>OFFLINE</code>, then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>setContinuous=<em>true</em></code> it retries the connection indefinitely</p>
</li>
<li>
<p>If <code>setContinuous=<em>false</em></code> (one-shot) it retries the connection a limited number of times.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following error codes are considered temporary by the Couchbase Lite replicator and thus will trigger a connection retry.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>408</code>: Request Timeout</p>
</li>
<li>
<p><code>429</code>: Too Many Requests</p>
</li>
<li>
<p><code>500</code>: Internal Server Error</p>
</li>
<li>
<p><code>502</code>: Bad Gateway</p>
</li>
<li>
<p><code>503</code>: Service Unavailable</p>
</li>
<li>
<p><code>504</code>: Gateway Timeout</p>
</li>
<li>
<p><code>1001</code>: DNS resolution error</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>== Load Balancers</p>
</div>
<div class="paragraph">
<p>Couchbase Lite <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> uses WebSockets as the communication protocol to transmit data.
Some load balancers are not configured for WebSocket connections by default (NGINX for example);
so it might be necessary to explicitly enable them in the load balancer&#8217;s configuration (see <a href="../../../sync-gateway/current/load-balancer.html" class="page">Load Balancers</a>).</p>
</div>
<div class="paragraph">
<p>By default, the WebSocket protocol uses compression to optimize for speed and bandwidth utilization.
The level of compression is set on Sync Gateway and can be tuned in the configuration file (<a href="../../../sync-gateway/current/configuration-properties.html#replicator_compression" class="page"><code>replicator_compression</code></a>).</p>
</div>
<div id="lbl-cert-pinning" class="paragraph">
<p>== Certificate Pinning</p>
</div>
<div class="paragraph">
<p>Couchbase Lite for Objective-C supports certificate pinning.</p>
</div>
<div class="paragraph">
<p>Certificate pinning is a technique that can be used by applications to "pin" a host to its certificate.
The certificate is typically delivered to the client by an out-of-band channel and bundled with the client.
In this case, Couchbase Lite uses this embedded certificate to verify the trustworthiness of the server (for example, a Sync Gateway) and no longer needs to rely on a trusted third party for that (commonly referred to as the Certificate Authority).</p>
</div>
<div class="paragraph">
<p>The following steps describe how to configure certificate pinning between Couchbase Lite and Sync Gateway.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="../../../sync-gateway/current/authentication-certs.html#creating-your-own-self-signed-certificate" class="page">Create your own self-signed certificate</a> with the <code>openssl</code> command.
After completing this step, you should have 3 files: <code>cert.pem</code>, <code>cert.cer</code> and <code>privkey.pem</code>.</p>
</li>
<li>
<p><a href="../../../sync-gateway/current/authentication-certs.html#installing-the-certificate" class="page">Configure Sync Gateway</a> with the <code>cert.pem</code> and <code>privkey.pem</code> files.
After completing this step, Sync Gateway is reachable over <code>https</code>/<code>wss</code>.</p>
</li>
<li>
<p>On the Couchbase Lite side, the replication must point to a URL with the <code>wss</code> scheme and configured with the <code>cert.cer</code> file created in step 1.</p>
<div class="paragraph">
<p>This example loads the certificate from the application sandbox, then converts it to the appropriate type to configure the replication object.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// tag=p2p-act-rep-config-cacert-pinned[]
NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                   target:target];
config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

// end=p2p-act-rep-config-cacert-pinned[]</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Build and run your app.
The replication should now run successfully over https/wss with certificate pinning.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For more on pinning certificates see the blog entry: <a href="https://blog.couchbase.com/certificate-pinning-android-with-couchbase-mobile/" target="_blank" rel="noopener">Certificate Pinning with Couchbase Mobile</a></p>
</div>
<div id="lbl-trouble" class="paragraph">
<p>== Troubleshooting</p>
</div>
<div class="paragraph">
<p>=== Logs
As always, when there is a problem with replication, logging is your friend.
You can increase the log output for activity related to replication with Sync Gateway&#8201;&#8212;&#8201;see <a href="#ex-logs">[ex-logs]</a>.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">// Replicator
[CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
// Network
[CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>For more on troubleshooting with logs, see: <a href="troubleshooting-logs.html" class="page">Using Logs</a>.</p>
</div>
<div class="paragraph">
<p>=== Authentication Errors
If Sync Gateway is configured with a self signed certificate but your app points to a <code>ws</code> scheme instead of <code>wss</code> you will encounter an error with status code <code>11006</code>&#8201;&#8212;&#8201;see: <a href="#ex-11006">[ex-11006]</a></p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">CouchbaseLite Replicator ERROR: {Repl#2} Got LiteCore error: WebSocket error 1006 "connection closed abnormally"</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>If Sync Gateway is configured with a self signed certificate, and your app points to a <code>wss</code> scheme but the replicator configuration isn&#8217;t using the certificate you will encounter an error with status code <code>5011</code>&#8201;&#8212;&#8201;see: <a href="#ex-5011">[ex-5011]</a></p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">CouchbaseLite Replicator ERROR: {Repl#2} Got LiteCore error: Network error 11 "server TLS certificate is self-signed or has unknown root cert"</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>== Related Content</p>
</div>
<div class="card-row three-column-row">
<div class="paragraph column">
<p>====== 
.Learn more &#8230;&#8203;</p>
</div>
<div class="paragraph column">
<div class="title"></div>
<p>====== 
.Reference material &#8230;&#8203;
.</p>
</div>
<div class="paragraph column">
<p>====== 
.Community Resources &#8230;&#8203;</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Couchbase Mobile 2.5+
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. From 2.0
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>© 2021 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script id="site-script" src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../../../_/js/vendor/fontawesome.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
