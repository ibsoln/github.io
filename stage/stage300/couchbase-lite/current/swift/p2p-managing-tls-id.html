<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Managing TLS Identities | Couchbase Docs</title>
<link rel="canonical" href="https://ibsoln.github.io/stage/stage300/couchbase-lite/current/swift/p2p-managing-tls-id.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">
<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0 BETA01">
<meta name="page-url" content="/couchbase-lite/current/swift/p2p-managing-tls-id.html">
<meta name="generator" content="Antora 3.0.0-alpha.6">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://ibsoln.github.io/stage/stage300/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://ibsoln.github.io/stage/stage300/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a href="https://cloud.couchbase.com/sign-up" class="free-trial-link" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  <i class="fas fa-cloud"></i>
                  Free Trial
                </a>
                <a class="btn btn-primary try-btn"  onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                </a>
              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list" data-component="couchbase-lite">
          <option value="3.0 BETA01" data-url="../index.html" selected>3.0 BETA01</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0 BETA01">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">New in 3.0 BETA</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/api-changes.html">API Changes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/kotlin.html">Kotlin</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder-n1ql-diffs.html">N1QL Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../c/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-downloads.html">BETA Downloads</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/field-level-encryption.html">Field Level Encryption</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/querybuilder-n1ql-diffs.html">N1QL Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/replication.html">Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-c">API&#160;References</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">C#.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/api-changes.html">API Changes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder-n1ql-diffs.html">N1QL Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-net">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/api-changes.html">API Changes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder-n1ql-diffs.html">N1QL Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-java/index.html?">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/api-changes.html">API Changes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder-n1ql-diffs.html">N1QL Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="api-changes.html">API Changes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder-n1ql-diffs.html">N1QL Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:compatibility.adoc">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:supported-os.adoc">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list" data-component="sync-gateway">
          <option value="3.0 BETA" data-url="../../../sync-gateway/current/index.html" selected>3.0 BETA</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0 BETA">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html"><strong><em>New in 3.0 BETA</em></strong></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-import-filter.html">Import Filter</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties.html">Legacy Pre-3.0 BETA Configuration</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-javascript-functions.html">Javascript Functions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-environment-variables.html">Environment Variables</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/secure-sgw-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Cert Authetnication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access Control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-to</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign User to Role</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRS for Access Grants</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-Purge Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Application</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Inter Syncgateway Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/what-are-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tomstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import Filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect Info</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS Level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::{cao-pg-manage-sgw&amp;.adoc#8212;&amp;#8203;page">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::{cao-pg-clients-sgw&amp;.adoc#8212;&amp;#8203;page">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Pre-2.1 Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/swift/pages/p2p-managing-tls-id.adoc" title="Edit Page" target="_blank" rel="noopener">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="p2p-managing-tls-id.html">Managing TLS Identities</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Managing TLS Identities</h1>
<div class="labels">
<ul>
<li class="edition"><a href="https://www.couchbase.com/products/editions">3.0 https://www.couchbase.com/products/editions[ENTERPRISE EDITION]</a></li>
<li class="status"><span>BETA</span></li>
</ul>
</div>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract pendingDocumentIds()">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br>
Related Content&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br>
Related Content&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 pane__frames">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="ulist no-color">
<div class="title"></div>
<ul>
<li>
<p>This describes the configuration and management of TLS identities</p>
</li>
</ul>
</div>
<div class="ulist narrow">
<div class="title">Key Concepts</div>
<ul>
<li>
<p>API: <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift/Classes/TLSIdentity.html">TLSIdentity</a></p>
</li>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">Swift API References</a> here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-tls-identity"><a class="anchor" href="#creating-tls-identity"></a>Creating TLS Identity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are couple of options by which TLS Identity is created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can use the <a href="#anonymous-cert">anonymous self-signed cert</a> auto-generated by Couchbase Lite</p>
</li>
<li>
<p>You can <a href="#importing-a-cert">import a cert</a> to be bundled with the app and-or stored in the keychain</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-anonymous-cert"><a class="anchor" href="#use-anonymous-cert"></a>Use Anonymous Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Anonymous certification uses the self signed certificate auto-generated by Couchbase Lite when TLS is enabled, but no TLSIdentity is provided.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">listenerConfig.disableTLS  = false // Use with anonymous self signed cert
listenerConfig.tlsIdentity = nil</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="import-a-cert"><a class="anchor" href="#import-a-cert"></a>Import a Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift/Classes/TLSIdentity.html">TLSIdentity</a> class&#8217;s  <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift/Classes/TLSIdentity.html#/s:18CouchbaseLiteSwift11TLSIdentityC14importIdentity8withData8password5labelAC10Foundation0H0V_SSSgSStKFZ">importIdentity()</a> method to import a certificate that can be bundled with the app and-or added to the keychain.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First check the keychain to see if the identity already exists</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">[data-source-url=https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/swift/examples/code_snippets/SampleCodeTest.swift]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Check for an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML


class SampleCodeTest {

    var database: Database!
    var db: Database!

    var replicator: Replicator!

    // MARK: Database

    func dontTestNewDatabase() throws {
        // tag::new-database[]
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }
        // end::new-database[]

        // tag::close-database[]
        do {
            try userDb.close()
        }

        // end::close-database[]


    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        // tag::database-encryption[]
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        // end::database-encryption[]
    }
    #endif

    func dontTestLogging() throws {
        // tag::logging[]
        Database.setLogLevel(.verbose, domain: .replicator)
        Database.setLogLevel(.verbose, domain: .query)
        // end::logging[]
    }

    func dontTestConsoleLogging() throws {
        // tag::console-logging[]
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>

        // end::console-logging[]
        // tag::console-logging-db[]

        Database.log.console.domains = .database

        // end::console-logging-db[]
    }

    func dontTestFileLogging() throws {
        // tag::file-logging[]
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
        // end::file-logging[]
    }

    func dontTestEnableCustomLogging() throws {
        // tag::set-custom-logging[]
        Database.log.custom = LogTestLogger(.warning) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    func dontTestLoadingPrebuilt() throws {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
        // end::prebuilt-database[]
    }

    // MARK: Document

    func dontTestInitializer() throws {
        database = self.db

        // tag::initializer[]
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
        // end::initializer[]
    }

    func dontTestMutability() throws {
        database = self.db

        // tag::update-document[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
        // end::update-document[]
    }

    func dontTestTypedAcessors() throws {
        let newTask = Document()

        // tag::date-getter[]
        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")
        // end::date-getter[]

        // tag::to-dictionary[]
        newTask.toDictionary() <i class="conum" data-value="9"></i><b>(9)</b>

        // end::to-dictionary[]

        // tag::to-json[]
        newTask.toJSON() <i class="conum" data-value="10"></i><b>(10)</b>

        // end::to-json[]

        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        // tag::batch[]
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::batch[]
    }

    func dontTestChangeListener() throws {
        database = self.db

        // tag::document-listener[]
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
        // end::document-listener[]
    }

    func dontTestDocumentExpiration() throws {
        database = self.db

        // tag::document-expiration[]
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try db.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        // end::document-expiration[]

    }

    func dontTestBlob() throws {
    #if TARGET_OS_IPHONE
        database = self.db
        let newTask = MutableDocument()
        var image: UIImage!

        // tag::blob[]
        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)!

        let blob = Blob(contentType: "image/jpeg", data: imageData)
        newTask.setBlob(blob, forKey: "avatar")
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }
        // end::blob[]

        print("\(image)")
    #endif
    }

    func dontTest1xAttachment() throws {
        database = self.db
        let document = MutableDocument()

        // tag::1x-attachment[]
        let attachments = document.dictionary(forKey: "_attachments")
        let avatar = attachments?.blob(forKey: "avatar")
        let content = avatar?.content
        // end::1x-attachment[]

        print("\(content!)")
    }

    // MARK: Query

    func dontTestIndexing() throws {
        database = self.db

        // tag::query-index[]
        let index = IndexBuilder.valueIndex(items:
            ValueIndexItem.expression(Expression.property("type")),
            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
        // end::query-index[]
    }

    func dontTestSelectMeta() throws {
        database = self.db

        // tag::query-select-meta[]
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-meta[]
    }


    func dontTestSelectProps() throws {
        database = self.db

        // tag::query-select-props[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-props[]
    }

    func dontTestSelectAll() throws {
        database = self.db

        // tag::query-select-all[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
        // end::query-select-all[]

        // tag::live-query[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="11"></i><b>(11)</b>
            for result in change.results! {
                print(result.keys)
                /* Update UI */
            }
        }

        // Start live query.
        query.execute(); <i class="conum" data-value="12"></i><b>(12)</b>
        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(withToken: token) <i class="conum" data-value="13"></i><b>(13)</b>

        // end::stop-live-query[]

        print("\(query)")
    }

    func dontTestWhere() throws {
        database = self.db

        // tag::query-where[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
        // end::query-where[]
    }

    func dontTestQueryDeletedDocuments() throws {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(Meta.isDeleted)
        // end::query-deleted-documents[]
    }

    func dontTestCollectionOperatorContains() throws {
        database = self.db

        // tag::query-collection-operator-contains[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                .and(ArrayFunction.contains(Expression.property("public_likes"), value: Expression.string("Armani Langworth")))
        )

        do {
             for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
        // end::query-collection-operator-contains[]
    }

    func dontTestCollectionOperatorIn() throws {
        database = self.db

        // tag::query-collection-operator-in[]
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
            ]

        QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))
        // end::query-collection-operator-in[]
    }


    func dontTestLikeOperator() throws {
        database = self.db

        // tag::query-like-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
        // end::query-like-operator[]
    }

    func dontTestWildCardMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-character-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-character-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        database = self.db

        // tag::query-regex-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="14"></i><b>(14)</b>
            )
            .limit(Expression.int(10))
        // end::query-regex-operator[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        database = self.db

        // tag::query-join[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX")))
        )
        // end::query-join[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        database = self.db

        // tag::query-groupby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
        )

        do {
            for result in try query.execute() {
                print("There are \(result.int(forKey: "$1")) airports on the \(result.string(forKey: "tz")!) timezone located in \(result.string(forKey: "country")!) and above 300 ft")
            }
        }
        // end::query-groupby[]
    }

    func dontTestOrderBy() throws {
        database = self.db

        // tag::query-orderby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))
        // end::query-orderby[]

        print("\(query)")
    }

    func dontTestExplain() throws {
      database = self.db
      // tag::query-explain-all[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("university")))
          .groupBy(Expression.property("country"))
          .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="15"></i><b>(15)</b>

      print(try thisQuery.explain()) <i class="conum" data-value="16"></i><b>(16)</b>
      // end::query-explain-all[]

      // tag::query-explain-like[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="17"></i><b>(17)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain())

      // end::query-explain-like[]

      // tag::query-explain-nopfx[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="18"></i><b>(18)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain());

      // end::query-explain-nopfx[]

      // tag::query-explain-function[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Function.lower(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="19"></i><b>(19)</b>

      print(try thisQuery.explain());

      // end::query-explain-function[]

      // tag::query-explain-nofunction[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="20"></i><b>(20)</b>

      print(try thisQuery.explain());

      // end::query-explain-nofunction[]

    }


    func dontTestCreateFullTextIndex() throws {
        database = self.db

        // tag::fts-index[]
        // Insert documents
        let tasks = ["buy groceries", "play chess", "book travels", "buy museum tickets"]
        for task in tasks {
            let doc = MutableDocument()
            doc.setString("task", forKey: "type")
            doc.setString(task, forKey: "name")
            try database.saveDocument(doc)
        }

        // Create index
        do {
            let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("name")).ignoreAccents(false)
            try database.createIndex(index, withName: "nameFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-index[]
    }

    func dontTestFullTextSearch() throws {
        database = self.db

        // tag::fts-query[]
        let whereClause = FullTextExpression.index("nameFTSIndex").match("'buy'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)

        do {
            for result in try query.execute() {
                print("document id \(result.string(at: 0)!)")
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-query[]
    }


    func dontTestToJson-ArrayObject() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-array[]




        // end::tojson-array[]
    }



    func dontTestGetBlobAsJSONstring() throws {
        db = self.db

        // tag::tojson-getblobasstring[]

        let thisdoc = db.document(withID: "thisdoc-id")!.toDictionary();
        let thisBlob =  thisdoc["avatar"] as! Blob

        if Blob.isBlob(properties: thisBlob.properties) {
          var blobtype = thisBlob.properties["content_type"]
          var bloblength = thisBlob.properties["length"]
        }
        // end::tojson-getblobasstring[]
    }


    func dontTestToJson-Dictionary() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-dictionary[]


        // end::tojson-dictionary[]
    }


    func dontTestToJson-Document() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-document[]


        // end::tojson-document[]
    }


    func dontTestToJson-Result() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-result[]
        let ourJSON =  "{{\"id\": \"hotel-ted\"},{\"name\": \"Hotel Ted\"},{\"city\": \"Paris\"},{\"type\": \"hotel\"}}"
        let ourDoc = try MutableDocument(id: "doc", json: ourJSON)
        try database.saveDocument(ourDoc)

        let query = QueryBuilder
                      .select(SelectResult.all)
                      .from(DataSource.database(database)))
                      .where(Expression.property("id").equalTo(Expression.string("hotel-ted"))))

        for (_,result) in try! query.execute().enumerated() {
          if let thisJSON = result.toJSON().toJSONObj() as? [String:Any] {
              // ... process document properties as required e.g.
              let docid = thisJSON["id"]
              let name = thisJSON["name"]
              let city = thisJSON["city"]
              let type = thisJSON["type"]
              //
          }

        // end::tojson-result[]
    }







    // MARK: Replication

    /* The `tag::replication[]` example is inlined in swift.adoc */

    func dontTestEnableReplicatorLogging() throws {
        // tag::replication-logging[]
        // Replicator
        Database.setLogLevel(.verbose, domain: .replicator)
        // Network
        Database.setLogLevel(.verbose, domain: .network)
        // end::replication-logging[]
    }

    func dontTestReplicationBasicAuthentication() throws {
        // tag::basic-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::basic-authentication[]
    }

    func dontTestReplicationSessionAuthentication() throws {
        // tag::session-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::session-authentication[]
    }

    func dontTestReplicatorStatus() throws {
        // tag::replication-status[]
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
        // end::replication-status[]
    }

//  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {
      // tag::replication-pendingdocuments[]

      let url = URL(string: "ws://localhost:4984/mydatabase")!
      let target = URLEndpoint(url: url)

      let config = ReplicatorConfiguration(database: database, target: target)
      config.replicatorType = .push

      // tag::replication-push-pendingdocumentids[]
      self.replicator = Replicator(config: config)
      let mydocids:Set = self.replicator.pendingDocumentIds() <i class="conum" data-value="21"></i><b>(21)</b>

      // end::replication-push-pendingdocumentids[]
      if(!mydocids.isEmpty) {
        print("There are \(mydocids.count) documents pending")

        self.replicator.addChangeListener { (change) in
          print("Replicator activity level is \(change.status.activity.toString())")
          // iterate and report-on previously
          // retrieved pending docids 'list'
          for thisId in mydocids.sorted() {
            // tag::replication-push-isdocumentpending[]
            if(!self.replicator.isDocumentPending(thisid)) { <i class="conum" data-value="22"></i><b>(22)</b>
              print("Doc ID \(thisId) now pushed")
            }
            // end::replication-push-isdocumentpending[]
          }
        }

        self.replicator.start()
        // end::replication-pendingdocuments[]
    }

//  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        // tag::add-document-replication-listener[]
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        self.replicator.removeChangeListener(withToken: token)
        // end::remove-document-replication-listener[]
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-custom-header[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
        // end::replication-custom-header[]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-channels[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
        // end::replication-channels[]
    }

    func dontTestHandlingReplicationError() throws {
        // tag::replication-error-handling[]
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
        // end::replication-error-handling[]
    }

    func dontTestReplicationResetCheckpoint() throws {
        // tag::replication-reset-checkpoint[]
        if (resetCheckpointRequired_Example) {
          self.replicator.start(reset: true)  <i class="conum" data-value="23"></i><b>(23)</b>
        else
          self.replicator.start()
        }

        // end::replication-reset-checkpoint[]
    }

    func dontTestReplicationPushFilter() throws {
        // tag::replication-push-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-push-filter[]
    }

    func dontTestReplicationPullFilter() throws {
        // tag::replication-pull-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-pull-filter[]
    }

//  Added 2/Feb/21 - Ian Bridge
//  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        // tag::replication-retry-config[]
        let target =
          URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        let config =  ReplicatorConfiguration(database: database, target: targetDatabase)
        config.type = .pushAndPull
        config.continuous = true
        // tag::replication-set-heartbeat[]
        config.heartbeat = 150 <i class="conum" data-value="24"></i><b>(24)</b>

        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
        config.maxattempts = 20 <i class="conum" data-value="25"></i><b>(25)</b>

        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
        config.maxattemptwaittime = 600 <i class="conum" data-value="26"></i><b>(26)</b>
        repl = Replicator(config: config)

        // end::replication-set-maxattemptwaittime[]

        // end::replication-retry-config[]
    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Swift Community. */
        // tag::database-replica[]
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::database-replica[]

        try database2.delete()
    }
    #endif

    func dontTestCertificatePinning() throws {

        // tag::certificate-pinning[]
        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate
        // end::certificate-pinning[]

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // tag::getting-started[]
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        let replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
        // end::getting-started[]
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::register-model[]
        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")
        // end::register-model[]

        // tag::predictive-query-value-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel(withName: "ImageClassifier")
        // end::unregister-model[]
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query-predictive-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
        // end::predictive-query-predictive-index[]
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(
                    prediction.property("probablity")
                        .greaterThanOrEqualTo(Expression.double(0.8))
                )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
        // end::predictive-query[]
    }

    func dontTestCoreMLPredictiveModel() throws {
        // tag::coreml-predictive-model[]
        // Load MLModel from `ImageClassifier.mlmodel`
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
        // end::coreml-predictive-model[]
    }

    func dontTestReplicatorConflictResolver() throws {
        // tag::replication-conflict-resolver[]
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-conflict-resolver[]
    }

    func dontTestSaveWithConflictHandler() throws {
        // tag::update-document-with-conflict-handler[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, _) in first })
            new.setData(result)
            return true
        })
        // end::update-document-with-conflict-handler[]

    }

    // helper
    func isValidCredentials(_ u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        let db: Database!

        // tag::init-urllistener[]
        let config = URLEndpointListenerConfiguration(database: db)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator:
            { (username, password) -&gt; Bool in
                return self.isValidCredentials(username, password: password)
        })

        // end::init-urllistener[]
    }

    func dontTestListenerStart() throws {
        let listener: URLEndpointListener

        // tag::start-urllistener[]
        try listener.start()

        // end::start-urllistener[]
    }

    func dontTestListenerStop() throws {
        let listener: URLEndpointListener
        // tag::stop-urllistener[]
        listener.stop()

        // end::stop-urllistener[]
    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        // tag::create-self-signed-cert[]
        // tag::listener-config-tls-id-SelfSigned[]
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
          try TLSIdentity.createIdentity(forServer: true,
                attributes: attrs,
                expiration: Date().addingTimeInterval(86400),
                label: "Server-Cert-Label")
        // end::listener-config-tls-id-SelfSigned[]
        // end::create-self-signed-cert[]
        print("\(identity.expiration)") // to avoid warning
    }
}


// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] {}
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // `myMLModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}
// end::predictive-model[]

// tag::custom-logging[]
fileprivate class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }

}
// end::custom-logging[]

// tag::local-win-conflict-resolver[]
class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}
// end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        // tag::message-endpoint[]
        let database = try Database(name: "dbname")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /* implements MessageEndpointConnection */
        return connection
    }
    // end::create-connection[]

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::active-peer-open[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::active-peer-send[]

    func receive(data: Data) {
        // tag::active-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::active-peer-receive[]
    }

    // tag::active-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::active-peer-close[]

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        // tag::listener[]
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
        // end::listener[]
    }

    func stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    func acceptConnection() {
        // tag::advertizer-accept[]
        let connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection: connection)
        // end::advertizer-accept[]
    }

    func disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::passive-peer-send[]

    func receive(data: Data) {
        // tag::passive-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::passive-peer-receive[]
    }

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::passive-peer-close[]
}


// BEGIN URLENDPOINTLISTENER SAMPLES

//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
        let config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.port = tls ? wssPort : wsPort
        config.disableTLS = !tls
        config.authenticator = auth

        return try listen(config: config)
    }

    @discardableResult
    func listen(config: URLEndpointListenerConfiguration) throws -&gt; URLEndpointListener {
        self.listener = URLEndpointListener.init(config: config)

        // Start:
        try self.listener!.start()

        return self.listener!
    }

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
        }
    }

    func cleanUpIdentities() throws {
        self.ignoreException {
            try URLEndpointListener.deleteAnonymousIdentities()
        }
    }

    func replicator(db: Database, continuous: Bool, target: Endpoint, serverCert: SecCertificate?) -&gt; Replicator {
        let config = ReplicatorConfiguration(database: db, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = continuous
        config.pinnedServerCertificate = serverCert
        return Replicator(config: config)
    }

    /// Two replicators, replicates docs to the self.listener; validates connection status
    func validateMultipleReplicationsTo() throws {
        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")
        let count = self.listener!.config.database.count

        // open DBs
        try deleteDB(name: "db1")
        try deleteDB(name: "db2")
        let db1 = try openDB(name: "db1")
        let db2 = try openDB(name: "db2")

        // For keeping the replication long enough to validate connection status, we will use blob
        let imageData = try dataFromResource(name: "image", ofType: "jpg")

        // DB#1
        let doc1 = createDocument()
        let blob1 = Blob(contentType: "image/jpg", data: imageData)
        doc1.setBlob(blob1, forKey: "blob")
        try db1.saveDocument(doc1)

        // DB#2
        let doc2 = createDocument()
        let blob2 = Blob(contentType: "image/jpg", data: imageData)
        doc2.setBlob(blob2, forKey: "blob")
        try db2.saveDocument(doc2)

        let repl1 = replicator(db: db1,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])
        let repl2 = replicator(db: db2,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        var maxConnectionCount: UInt64 = 0, maxActiveCount: UInt64 = 0
        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .busy {
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount);
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount);
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db1" {
                    exp1.fulfill()
                } else {
                    exp2.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        // check both replicators access listener at same time
        XCTAssertEqual(maxConnectionCount, 2);
        XCTAssertEqual(maxActiveCount, 2);

        // all data are transferred to/from
        XCTAssertEqual(self.listener!.config.database.count, count + 2);
        XCTAssertEqual(db1.count, count + 1/* db2 doc*/);
        XCTAssertEqual(db2.count, count + 1/* db1 doc*/);

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db1.close()
        try db2.close()
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // Anonymous Identity:
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // User Identity:
// tag::p2psync-act-tlsid-create[]
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
// end::p2psync-act-tlsid-create[]
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
    }

    func testPasswordAuthenticator() throws {
        // Listener:
        let listenerAuth = ListenerPasswordAuthenticator.init {
            (username, password) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: listenerAuth)

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Success:
        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth)

        // Cleanup:
        try stopListen()
    }

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)

// tag::p2psync-act-tlsid-delete[]
        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
// end::p2psync-act-tlsid-delete[]

        // Create client identity:
// tag::p2psync-act-tlsid-import[]
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)
// end::p2psync-act-tlsid-import[]

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .selfSignedCert, serverCert: nil)
        }

        // Cleanup
        try stopListen()
    }

    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: serverCert)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: .caCert, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }

    func testMultipleListenersOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        let listener1 = URLEndpointListener(config: config)
        let listener2 = URLEndpointListener(config: config)

        try listener1.start()
        try listener2.start()

        try generateDocument(withID: "doc-1")
        self.run(target: listener1.localURLEndpoint,
                 type: .pushAndPull,
                 continuous: false,
                 auth: nil,
                 serverCert: listener1.tlsIdentity!.certs[0])

        // since listener1 and listener2 are using same certificates, one listener only needs stop.
        listener2.stop()
        try stopListener(listener: listener1)
        XCTAssertEqual(self.oDB.count, 1)
    }

    func testReplicatorAndListenerOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")

        // listener
        let doc = createDocument()
        try self.oDB.saveDocument(doc)
        try listen()

        // Replicator#1 (otherDB -&gt; DB#1)
        let doc1 = createDocument()
        try self.db.saveDocument(doc1)
        let target = DatabaseEndpoint(database: self.db)
        let repl1 = replicator(db: self.oDB, continuous: true, target: target, serverCert: nil)

        // Replicator#2 (DB#2 -&gt; Listener(otherDB))
        try deleteDB(name: "db2")
        let db2 = try openDB(name: "db2")
        let doc2 = createDocument()
        try db2.saveDocument(doc2)
        let repl2 = replicator(db: db2,
                               continuous: true,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .idle &amp;&amp;
                change.status.progress.completed == change.status.progress.total {
                if self.oDB.count == 3 &amp;&amp; self.db.count == 3 &amp;&amp; db2.count == 3 {
                    change.replicator.stop()
                }
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db2" {
                    exp2.fulfill()
                } else {
                    exp1.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        XCTAssertEqual(self.oDB.count, 3)
        XCTAssertEqual(self.db.count, 3)
        XCTAssertEqual(db2.count, 3)

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db2.close()
        try stopListen()
    }

    func testCloseWithActiveListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        // Close database should also stop the listener:
        try self.oDB.close()

        XCTAssertNil(self.listener!.port)
        XCTAssertNil(self.listener!.urls)

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-1008
    func _testEmptyNetworkInterface() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        for (i, url) in self.listener!.urls!.enumerated() {
            // separate db instance!
            let db = try Database(name: "db-\(i)")
            let doc = createDocument()
            doc.setString(url.absoluteString, forKey: "url")
            try db.saveDocument(doc)

            // separate replicator instance
            let target = URLEndpoint(url: url)
            let rConfig = ReplicatorConfiguration(database: db, target: target)
            rConfig.pinnedServerCertificate = self.listener?.tlsIdentity!.certs[0]
            run(config: rConfig, expectedError: nil)

            // remove the db
            try db.delete()
        }

        XCTAssertEqual(self.oDB.count, UInt64(self.listener!.urls!.count))

        let q = QueryBuilder.select([SelectResult.all()]).from(DataSource.database(self.oDB))
        let rs = try q.execute()
        var result = [URL]()
        for res in rs.allResults() {
            let dict = res.dictionary(at: 0)
            result.append(URL(string: dict!.string(forKey: "url")!)!)
        }

        XCTAssertEqual(result, self.listener!.urls)
        try stopListen()

        // validate 0.0.0.0 meta-address should return same empty response.
        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.networkInterface = "0.0.0.0"
        try listen(config: config)
        XCTAssertEqual(self.listener!.urls!, result)
        try stopListen()
    }

    func testMultipleReplicatorsToListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        let doc = createDocument()
        doc.setString("Tiger", forKey: "species")
        try self.oDB.saveDocument(doc)

        try validateMultipleReplicationsTo()

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-954
    func _testReadOnlyListener() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.readOnly = true
        try listen(config: config)

        self.run(target: self.listener!.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, serverCert: self.listener!.tlsIdentity!.certs[0],
                 expectedError: CBLErrorHTTPForbidden)
    }
}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}

// END URLENDPOINTLISTENER SAMPLES


//
//  QueryResultSets.swift
//  sampleQueryResults
//
//  Created by Ian Bridge on 28/07/2021.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

//import CoreML


class Query {

    var this_hotel:Hotel = Hotel()

    let dbName = "hotel"
    //    let dbName = "hotel"
    var db = try! Database(name: "hotel")
    var hotels = [String:Any]()
    var thisDocsProperties = [String:Any]()
    var jsonbit = [String:Any]()

    func dontTestQueryAll() throws {





    //        seedHotel()

    // QUERY RESULT SET HANDLING EXAMPLES
    // tag::query-syntax-all[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database( db))

    // end::query-syntax-all[]

    // tag::query-access-all[]

        do {

            for row in try! listQuery.execute() {

                let thisDocsProps =
                    row.dictionary(at: 0)?.toDictionary() <i class="conum" data-value="27"></i><b>(27)</b>

                let docid = thisDocsProps!["id"] as! String

                let name = thisDocsProps!["name"] as! String

                let type = thisDocsProps!["type"] as! String

                let city = thisDocsProps!["city"] as! String

                let hotel = row.dictionary(at: 0)?.toDictionary()  <i class="conum" data-value="28"></i><b>(28)</b>
                let hotelId = hotel!["id"] as! String
                hotels[hotelId] = hotel
            } // end for

        } //end do-block

    // end::query-access-all[]

    // tag::query-access-json[]

    // In this example the Hotel class is defined using Codable
    //
    // class Hotel : Codable {
    //   var id : String = "undefined"
    //   var type : String = "hotel"
    //   var name : String = "undefined"
    //   var city : String = "undefined"
    //   var country : String = "undefined"
    //   var description : String? = ""
    //   var text : String? = ""
    //   ... other class content
    // }


        do {
            var results = try! listQuery.execute()
            for row in  results {

                // get the result into a JSON String
                let jsonString = row.toJSON() <i class="conum" data-value="29"></i><b>(29)</b>

                let thisJsonObj:Dictionary =
                    try! (JSONSerialization.jsonObject(
                            with: jsonString.data(using: .utf8)!,
                                                  options: .allowFragments)
                            as? [String: Any])! <i class="conum" data-value="30"></i><b>(30)</b>

                // Use Json Object to populate Native object
                // Use Codable class to unpack JSON data to native object
                let this_hotel:Hotel =
                    (try JSONDecoder().decode(
                        Hotel.self,
                        from: jsonString.data(using: .utf8)!
                        )
                    ) <i class="conum" data-value="31"></i><b>(31)</b>

                // ALTERNATIVELY unpack in steps
                this_hotel.id = thisJsonObj["id"] as! String
                this_hotel.name = thisJsonObj["name"] as! String
                this_hotel.type = thisJsonObj["type"] as! String
                this_hotel.city = thisJsonObj["city"] as! String
                hotels[this_hotel.id] = this_hotel


            } // end for

            // end::query-access-json[]

        } catch let err {
            print(err.localizedDescription)

        } // end do



    } // end func dontTestQueryAll



    func dontTestQueryProps () throws {
        // tag::query-syntax-props[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()
        var hotel:Hotel = Hotel.init()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
                    .from(DataSource.database(db))

        // end::query-syntax-props[]

        // tag::query-access-props[]
        for (_, result) in try! listQuery.execute().enumerated() {


            let thisDoc = result.toDictionary() as? [String:Any]  <i class="conum" data-value="32"></i><b>(32)</b>
                // Store dictionary data in hotel object and save in arry
            hotel.id = thisDoc!["id"] as! String
            hotel.name = thisDoc!["name"] as! String
            hotel.city = thisDoc!["city"] as! String
            hotel.type = thisDoc!["type"] as! String
            hotels[hotel.id] = hotel

            // Use result content directly
            let docid = result.string(forKey: "metaId")
            let hotelId = result.string(forKey: "id")
            let name = result.string(forKey: "name")
            let city = result.string(forKey: "city")
            let type = result.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: ", docid, hotelId,name, city, type)
          } // end for

// end::query-access-props[]
    }// end func

//
    func dontTestQueryCount () throws {

    // tag::query-syntax-count-only[]
        let db = try! Database(name: "hotel")
        do {
            let listQuery = QueryBuilder
                .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
                .from (DataSource.database(db)).groupBy(Expression.property("type"))

                // end::query-syntax-count-only[]


            // tag::query-access-count-only[]

            for result in try! listQuery.execute() {
                let dict = result.toDictionary() as? [String: Int]
                let thiscount = dict!["mycount"]! <i class="conum" data-value="33"></i><b>(33)</b>
                print("There are ", thiscount, " rows")

                // Alternatively
                print ( result["mycount"] )

            } // end for

        } // end do
    } // end function

// end::query-access-count-only[]

//
    func dontTestQueryId () throws {

        // tag::query-syntax-id[]
        let db = try! Database(name: "hotel")
        let listQuery = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
                    .from(DataSource.database(db))

        // end::query-syntax-id[]


        // tag::query-access-id[]
        for (_, result) in try! listQuery.execute().enumerated() {

            print(result.toDictionary())
            print("Document Id is -- ", result["metaId"].string!)

            let thisDocsId = result["metaId"].string! <i class="conum" data-value="34"></i><b>(34)</b>

            // Now you can get the document using the ID
            var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

            let hotelId = thisDoc["id"] as! String

            let name = thisDoc["name"] as! String

            let city = thisDoc["city"] as! String

            let type = thisDoc["type"] as! String

            // ... process document properties as required
            print("Result properties are: ", hotelId,name, city, type)


        } // end for

// end::query-access-id[]
    } // end function dontTestQueryId

//
    func query_pagination () throws {

        //tag::query-syntax-pagination[]
        let thisOffset = 0;
        let thisLimit = 20;
        //
        let listQuery = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(db))
                .limit(Expression.int(thisLimit),
                  offset: Expression.int(thisOffset))

        // end::query-syntax-pagination[]

    } // end function
//
//


    func seedHotel () {

        try! db.delete()

        db = try! Database(name: "hotel")

        let key = ["id","name","type","city", "country","description"]
        let val = [
                    ["1000","Hotel Ted","hotel","Paris", "France","Very good and central"],
                    ["1001","Hotel Fred","hotel","London", "England","Very good and central"],
                    ["1002","Hotel Du Ville","hotel","Casablanca", "Morocco","Very good and central"],
                    ["1003","Hotel Ouzo","hotel","Athens", "Greece","Very good and central"]
                ]
        let maxrecs=val.count-1
        for i in 0 ... maxrecs {

            let hotel:MutableDocument = MutableDocument(id: val[0][i])

            for x in 0 ... key.count-1 {
                hotel.setString(val[i][x], forKey: key[x])
            }

            try! db.saveDocument(hotel)


        }

    }

//
// N1QL QUERY EXAMPLES
//

    func dontTestQueryN1QL() throws {


    // tag::query-syntax-n1ql[]
        let db = try! Database(name: "hotel")

        let listQuery =  db.createQuery( query:
            "SELECT META().id AS thisId FROM _ WHERE type = 'hotel'" <i class="conum" data-value="35"></i><b>(35)</b>
        )

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QL


    func dontTestQueryN1QLparams() throws {

    // tag::query-syntax-n1ql-params[]
        let db = try! Database(name: "hotel")

        let listQuery =
            db.createQuery( query:
                   "SELECT META().id AS thisId FROM _ WHERE type = $type" <i class="conum" data-value="36"></i><b>(36)</b>
                )

        listQuery.parameters =
            Parameters().setString("hotel", forName: "type") <i class="conum" data-value="37"></i><b>(37)</b>

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql-params[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QLparams()


    func dontTestProcessResults(results: ResultSet) throws {
        // tag::query-access-n1ql[]
        // tag::query-process-results[]

        do {

            for row in results {

                print(row["thisId"].string!)

                let thisDocsId = row["thisId"].string!

                // Now you can get the document using the ID
                var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

                let hotelId = thisDoc["id"] as! String

                let name = thisDoc["name"] as! String

                let city = thisDoc["city"] as! String

                let type = thisDoc["type"] as! String

                // ... process document properties as required
                print("Result properties are: ", hotelId,name, city, type)

            } // end for
            // end::query-access-n1ql[]
            // end::query-process-results[]

        } //end do-block

    } // end dontTestProcessResults

} // end class






//  JSON API SNIPPETS


    func dontTestJSONdocument() {
        // tag::query-get-all[]
        let db = try! Database(name: "hotel")
        let dbnew = try! Database(name: "newhotels")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(db))


        for row in try! listQuery.execute() {
        // end::query-get-all[]

        // tag::tojson-document[]
            var thisId = row.string(forKey: "metaId")! as String

            var thisJSONstring = try! db.document(withID: thisId)!.toJSON() <i class="conum" data-value="38"></i><b>(38)</b>

            print("JSON String = ", thisJSONstring as! String)

            let hotelFromJSON:MutableDocument = <i class="conum" data-value="39"></i><b>(39)</b>
                    try! MutableDocument(id: thisId as? String, json: thisJSONstring)

            try! dbnew.saveDocument(hotelFromJSON)

            let newhotel = dbnew.document(withID: thisId)

            let keys = newhotel!.keys
            for key in keys { <i class="conum" data-value="40"></i><b>(40)</b>
                print(key, newhotel!.value(forKey: key) as! String)
            }

            // end::tojson-document[]

        /*
        // tag::tojson-document-output[]
             JSON String =  {"description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
             type hotel
             id 1000
             country France
             city Paris
             description Very good and central
             name Hotel Ted
        // end::tojson-document-output[]
         */
        } // end  query for loop


        // tag::tojson-array[]

        let thisJSONstring = """
            [{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
            \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
            {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
            \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
            \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]
            """
        let myArray:MutableArrayObject =
            try! MutableArrayObject.init(json: thisJSONstring) <i class="conum" data-value="41"></i><b>(41)</b>

        for i in 0...myArray.count-1 {

            print(i+1, myArray.dictionary(at: i)!.string(forKey: "name")!)

            var docid = myArray.dictionary(at: i)!.string(forKey: "id")

            var newdoc:MutableDocument = <i class="conum" data-value="42"></i><b>(42)</b>
                try! MutableDocument(id: docid,
                         data: (myArray.dictionary(at: i)?.toDictionary())! )

            try! dbnew.saveDocument(newdoc)

        }

        let extendedDoc = dbnew.document(withID: "1002")
        let features =
            extendedDoc!.array(forKey: "features")?.toArray() <i class="conum" data-value="43"></i><b>(43)</b>
        for i in 0...features!.count-1 {
            print(features![i])
        }

        print( extendedDoc!.array(
                forKey: "features")?.toJSON() as! String) <i class="conum" data-value="44"></i><b>(44)</b>

        // end::tojson-array[]

        /*
        // tag::tojson-array-output[]

         1 Hotel Ted
         2 Hotel Fred
         3 Hotel Ned

         Cable TV
         Toaster
         Microwave

         ["Cable TV","Toaster","Microwave"]
         // end::tojson-array-output[]
        */


        // tag::tojson-dictionary[]

        var aJSONstring = """
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\"}
            """

        let myDict:MutableDictionaryObject =
            try! MutableDictionaryObject(json: aJSONstring) <i class="conum" data-value="45"></i><b>(45)</b>
        print(myDict)

        let name = myDict.string(forKey: "name")
        print("Details for: ", name!)

        for key in myDict {

            print(key, myDict.value(forKey: key) as! String)

        }


        // end::tojson-dictionary[]

        /*
        // tag::tojson-dictionary-output[]

         Details for:  Hotel Ned
         description Undefined description for Hotel Ned
         id 1002
         name Hotel Ned
         country Australia
         type hotel
         city Balmain

         // end::tojson-dictionary-output[]
        */
    public func JsonApiBlob() throws {
        // tag::tojson-blob[]
      // Get a document
        let thisDoc = db.document(withID: "1000")?.toMutable() <i class="conum" data-value="46"></i><b>(46)</b>

        // Get the image and add as a blob to the document
        let contentType = "image/jpg";
        let ourImage = UIImage(named: "couchbaseimage.png")!
        let imageData = ourImage.jpegData(compressionQuality: 1)!
        thisDoc?.setBlob(
            Blob(contentType: contentType, data: imageData), forKey: "avatar") <i class="conum" data-value="47"></i><b>(47)</b>

       let theBlobAsJSONstringFails =
              thisDoc?.blob(forKey: "avatar")!.toJSON();

        // Save blob as part of doc or alternatively as a blob

        try! db.saveDocument(thisDoc!);
        try! db.saveBlob(
                blob: Blob(contentType: contentType, data: imageData)); <i class="conum" data-value="48"></i><b>(48)</b>

        // Retrieve saved blob as a JSON, reconstitue and check still blob
        let sameDoc = db.document(withID: "1000")
        let sameBlob = sameDoc?.blob(forKey: "avatar")
        let theBlobAsJSONstring = sameBlob!.toJSON(); <i class="conum" data-value="49"></i><b>(49)</b>

        for (key, value) in sameDoc!.toDictionary() {
             print( "Data -- {0) = {1}", key, value);
        }

        if(Blob.isBlob(properties: sameBlob!.properties)) <i class="conum" data-value="50"></i><b>(50)</b>
        {
            print(theBlobAsJSONstring);
        }

        // end::tojson-blob[]


    }

//    } // end func testjson

//        } // end query loop

    } // end jsonapi func


}

    extension String {

        func toJSONObj() -&gt; Any {

            let d1 = self.data(using: .utf8)

            return try! JSONSerialization.jsonObject(
                with: d1!, options:[])
        }
    }



//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

// tag::listener[]

// tag::listener-simple[]
val config =
  URLEndpointListenerConfiguration(database) <i class="conum" data-value="51"></i><b>(51)</b>

config.setAuthenticator(
    ListenerPasswordAuthenticator {
      username, password -&gt;
        "valid.user" == username &amp;&amp;
        ("valid.password.string" == String(password))
    }
) <i class="conum" data-value="52"></i><b>(52)</b>

val listener =
  URLEndpointListener(config) <i class="conum" data-value="53"></i><b>(53)</b>

listener.start()  <i class="conum" data-value="54"></i><b>(54)</b>

// end::listener-simple[]



// tag::replicator-simple[]

let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="55"></i><b>(55)</b>

var thisConfig = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="56"></i><b>(56)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="57"></i><b>(57)</b>

let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="58"></i><b>(58)</b>

this.replicator = new Replicator(config); <i class="conum" data-value="59"></i><b>(59)</b>

this.replicator.start(); <i class="conum" data-value="60"></i><b>(60)</b>

// end::replicator-simple[]



import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    // tag::xctListener-start-func[]
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
    // tag::xctListener-start[]
    // tag::xctListener-config[]
    //  ... fragment preceded by other user code, including
    //  ... Couchbase Lite Database initialization that returns `thisDB`

    guard let db = thisDB else {
      throw print("DatabaseNotInitialized")
      // ... take appropriate actions
    }
    var listener: URLEndpointListener?
    let config = URLEndpointListenerConfiguration.init(database: db)
    config.port = tls ? wssPort : wsPort
    config.disableTLS = !tls
    config.authenticator = auth
    self.listener = URLEndpointListener.init(config: config)
//  ... fragment followed by other user code
    // end::xctListener-config[]

        // Start:
        try self.listener!.start()
    // end::xctListener-start[]

        return self.listener!
    }
    // end::xctListener-start-func[]

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
    // tag::xctListener-stop-func[]
    var listener: URLEndpointListener?
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
    // end::xctListener-stop-func[]
        }
    }

    func cleanUpIdentities() throws {
// tag::xctListener-delete-anon-ids[]
        try URLEndpointListener.deleteAnonymousIdentities()
// end::xctListener-delete-anon-ids[]
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// tag::xctListener-auth-tls-tlsidentity-anon[]
        // Anonymous Identity:

        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// end::xctListener-auth-tls-tlsidentity-anon[]

// tag::xctListener-auth-tls-tlsidentity-ca[]
        // User Identity:
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        var(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
// end::xctListener-auth-tls-tlsidentity-ca[]
    }

    func testPasswordAuthenticator() throws {
// tag::xctListener-auth-basic-pwd-full[]
        // Listener:
// tag::xctListener-auth-basic-pwd[]
        let thisAuth = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: thisAuth)

        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull,    continuous: false,
                 auth: auth)
// end::xctListener-auth-basic-pwd[]

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)


        // Cleanup:
        try stopListen()
    }
// end::xctListener-auth-basic-pwd-full[]

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }

// tag::xctListener-auth-tls-CCA-Root-full[]
// tag::xctListener-auth-tls-CCA-Root[]
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)
// end::xctListener-auth-tls-CCA-Root[]

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
// end::xctListener-auth-tls-CCA-Root-full[]
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }
// tag::xctListener-auth-tls-self-signed-full[]
// tag::xctListener-auth-tls-self-signed[]
        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)


        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: true, serverCert: nil)
        }
// end::xctListener-auth-tls-self-signed[]
        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
// end::xctListener-auth-tls-self-signed-full[]
    }

// tag::xctListener-auth-tls-ca-cert-full[]
    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
// tag::xctListener-auth-tls-ca-cert[]
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: serverCert)
        }
// end::xctListener-auth-tls-ca-cert[]

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
// tag::xctListener-status-check-full[]
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: false, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }
// end::xctListener-status-check-full[]

}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}
// end::start-replication[]

// tag::xctListener-auth-password-basic[]
listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
  (username, password) -&gt; Bool in
    (["password" : password, "name":username])
    if (self._allowListedUsers.contains(["password" : password, "name":username])) {
        return true
    }
    return false
}
// end::xctListener-auth-password-basic[]

// tag::xctListener-auth-cert-roots[]
let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
let listener = try listen(tls: true, auth: listenerAuth)// end::xctListener-auth-cert-roots[]

// tag::xctListener-auth-cert-auth[]
let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
    XCTAssertEqual(certs.count, 1)
    var commongName: CFString?
    let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
    XCTAssertEqual(status, errSecSuccess)
    XCTAssertNotNil(commongName)
    XCTAssertEqual((commongName! as String), "daniel")
    return true
}
// end::xctListener-auth-cert-auth[]

// tag::xctListener-config-basic-auth[]
let listenerConfig = URLEndpointListenerConfiguration(database: db)
listenerConfig.disableTLS  = true // Use with anonymous self signed cert
listenerConfig.enableDeltaSync = true
listenerConfig.tlsIdentity = nil

listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
    if (self._whitelistedUsers.contains(["password" : validPassword, "name":validUser])) {
        return true
    }
    return false
        }

_thisListener = URLEndpointListener(config: listenerConfig)
// end::xctListener-config-basic-auth[]





// tag::replication-start-func[]
    func startP2PReplicationWithUserDatabaseToRemotePeer(_ peer:PeerHost, handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void) throws{
        print("\(#function) with ws://\(peer)/\(kUserDBName)")
        guard let userDb = thisDB else {
          throw print("DatabaseNotInitialized")
          // ... take appropriate actions
        }
        guard let user = self.currentUserCredentials?.user, let password = self.currentUserCredentials?.password else {
          throw print("UserCredentialsNotProvided")
          // ... take appropriate actions
        }

// tag::replicator-start-func-config-init[]
        var replicatorForUserDb = _replicatorsToPeers[peer]

        if replicatorForUserDb == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(kUserDBName)") else {
                throw print("URLInvalid")
                // ... take appropriate actions
            }


            let config = ReplicatorConfiguration.init(database: userDb, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>
// end::replicator-start-func-config-init[]

// tag::replicator-start-func-config-more[]

            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>

// end::replicator-start-func-config-more[]

// tag::replicator-start-func-config-auth[]

            config.acceptOnlySelfSignedServerCertificate = true
            let authenticator = BasicAuthenticator(username: validUser, password: validPassword)
            config.authenticator = authenticator
// end::replicator-start-func-config-auth[]

// tag::replicator-start-func-repl-init[]
replicatorForUserDb = Replicator.init(config: config)
_replicatorsToPeers[peer] = replicatorForUserDb
// end::replicator-start-func-repl-init[]
          }


// tag::replicator-start-func-repl-start[]
if let pushPullReplListenerForUserDb = registerForEventsForReplicator(replicatorForUserDb,handler:handler) {
    _replicatorListenersToPeers[peer] = pushPullReplListenerForUserDb

}
replicatorForUserDb?.start()
handler(PeerConnectionStatus.Connecting)
// end::replicator-start-func-repl-start[]

      }
// end::replication-start-func[]


// tag::replicator-register-for-events[]
fileprivate func registerForEventsForReplicator(_ replicator:Replicator?,
  handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void )-&gt;ListenerToken? {
    let pushPullReplListenerForUserDb = replicator?.addChangeListener({ (change) in

      let s = change.status
      if s.error != nil {
          handler(PeerConnectionStatus.Error)
          return
      }

      switch s.activity {
      case .connecting:
          print("Replicator Connecting to Peer")
          handler(PeerConnectionStatus.Connecting)
      case .idle:
          print("Replicator in Idle state")
          handler(PeerConnectionStatus.Connected)
      case .busy:
          print("Replicator in busy state")
          handler(PeerConnectionStatus.Busy)
      case .offline:
          print("Replicator in offline state")
      case .stopped:
          print("Completed syncing documents")
          handler(PeerConnectionStatus.Error)

      }

      if s.progress.completed == s.progress.total {
          print("All documents synced")
      }
      else {
          print("Documents \(s.progress.total - s.progress.completed) still pending sync")
      }
  })
  return pushPullReplListenerForUserDb
// end::replicator-register-for-events[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  fileprivate var _allowlistedUsers:[[String:String]] = []
  // tag::listener-initialize[]
  fileprivate var _thisListener:URLEndpointListener?
  fileprivate var thisDB:Database?

    // tag::listener-config-db[]
    let listenerConfig =
      URLEndpointListenerConfiguration(database: thisDB!) <i class="conum" data-value="61"></i><b>(61)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    /* optionally */ let wsPort: UInt16 = 55991
    /* optionally */ let wssPort: UInt16 = 55990
    listenerConfig.port =  wssPort <i class="conum" data-value="62"></i><b>(62)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    listenerConfig.networkInterface = "10.1.1.10"  <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    listenerConfig.enableDeltaSync = true <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-tls-enable[]
     // tag::listener-config-tls-id-anon[]
    // Set the credentials the server presents the client
    // Use an anonymous self-signed cert
    listenerConfig.tlsIdentity = nil <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure how the client is to be authenticated
    // Here, use Basic Authentication
    listenerConfig.authenticator =
      ListenerPasswordAuthenticator(authenticator: {
        (validUser, validPassword) -&gt; Bool in
          if (self._allowlistedUsers.contains {
                $0 == validPassword &amp;&amp; $1 == validUser
              }) {
              return true
              }
            return false
          }) <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-client-auth-pwd[]

    // tag::listener-start[]
    // Initialize the listener
    _thisListener = URLEndpointListener(config: listenerConfig) <i class="conum" data-value="68"></i><b>(68)</b>
    guard let thisListener = _thisListener else {
      throw ListenerError.NotInitialized
      // ... take appropriate actions
    }
    // Start the listener
    try thisListener.start() <i class="conum" data-value="69"></i><b>(69)</b>

    // end::listener-start[]
// end::listener-initialize[]
  }
}


// BEGIN Additonal listener options



// tag::listener-get-network-interfaces[]
import SystemConfiguration
// . . .

  #if os(macOS)
  for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
      // do something with this `interface`
  }
  #endif
// . . .

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
let config =
  URLEndpointListenerConfiguration(database: self.oDB)
let listener = URLEndpointListener(config: config)
try listener.start()

print("urls: \(listener.urls)")

// end::listener-get-url-list[]


    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-full-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="70"></i><b>(70)</b>

    // end::listener-config-tls-full-enable[]
    // tag::listener-config-tls-disable[]
    listenerConfig.disableTLS  = true <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    guard let pathToCert =
      Bundle.main.path(forResource: "cert", ofType: "p12")
    else { /* process error */ return }

    guard let localCertificate =
      try? NSData(contentsOfFile: pathToCert) as Data
    else { /* process error */ return } <i class="conum" data-value="72"></i><b>(72)</b>

    let thisIdentity =
      try TLSIdentity.importIdentity(withData: localCertificate,
                                    password: "123",
                                    label: thisSecId) <i class="conum" data-value="73"></i><b>(73)</b>

    // end::listener-config-tls-id-caCert[]
    // tag::listener-config-tls-id-SelfSigned[]
    let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="74"></i><b>(74)</b>

    let thisIdentity =
      try TLSIdentity.createIdentity(forServer: true, /* isServer */
            attributes: attrs,
            expiration: Date().addingTimeInterval(86400),
            label: "Server-Cert-Label") <i class="conum" data-value="75"></i><b>(75)</b>

    // end::listener-config-tls-id-SelfSigned[]
    // tag::listener-config-tls-id-full-set[]
    // Set the credentials the server presents the client
    listenerConfig.tlsIdentity = thisIdentity    <i class="conum" data-value="76"></i><b>(76)</b>

    // end::listener-config-tls-id-full-set[]
    // end::listener-config-tls-id-full[]
    // tag::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-root[]
    // Authenticate using Cert Authority

    // cert is a pre-populated object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="77"></i><b>(77)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="78"></i><b>(78)</b> <i class="conum" data-value="79"></i><b>(79)</b>

    // end::listener-config-client-auth-root[]
    // end::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-lambda[]
    // tag::listener-config-client-auth-self-signed[]
    // Authenticate self-signed cert using application logic

    // cert is a user-supplied object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="80"></i><b>(80)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init { <i class="conum" data-value="81"></i><b>(81)</b>
      (certs) -&gt; Bool in
        var certs:SecCertificate
        var certCommonName:CFString?
        let status=SecCertificateCopyCommonName(certs[0], &amp;certCommonName)
        if (self._allowedCommonNames.contains(["name": certCommonName! as String])) {
            return true
        }
        return false
    } <i class="conum" data-value="82"></i><b>(82)</b>

    // end::listener-config-client-auth-self-signed[]
    // end::listener-config-client-auth-lambda[]
// END Additonal listener options





// tag::old-listener-config-tls-id-nil[]
listenerConfig.tlsIdentity = nil

// end::old-listener-config-tls-id-nil[]
// tag::old-listener-config-delta-sync[]
listenerConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]
// tag::listener-status-check[]
let totalConnections = thisListener.status.connectionCount
let activeConnections = thisListener.status.activeConnectionCount

// end::listener-status-check[]
// tag::listener-stop[]
        thisListener.stop()

// end::listener-stop[]
// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
// tag::old-listener-config-client-auth-self-signed[]
listenerConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}
// end::old-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
config.port = tls ? wssPort : wsPort
config.disableTLS = !tls
config.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // tag::p2p-act-rep-func[]
    let validUser = "syncuser"
    let validPassword = "sync9455"
    let cert:SecCertificate?
    let passivePeerEndpoint = "10.1.1.12:8920"
    let passivePeerPort = "8920"
    let passiveDbName = "userdb"
    var actDb:Database?
    var thisReplicator:Replicator?
    var replicatorListener:ListenerToken?


    // tag::p2p-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="83"></i><b>(83)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    config.replicatorType = .pushAndPull

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = false; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    config.continuous = true

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="85"></i><b>(85)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="86"></i><b>(86)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: "Our Username", password: "Our Password")
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    config.conflictResolver = ( /* define resolver function */); <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-conflict[]
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    thisReplicator = Replicator.init( config: config) <i class="conum" data-value="88"></i><b>(88)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // Optionally add a change listener
    // Retain token for use in deletion
    let pushPullReplListener:ListenerToken? = thisReplicator?.addChangeListener({ (change) in <i class="conum" data-value="89"></i><b>(89)</b>
      if change.status.activity == .stopped {
          print("Replication stopped")
      }
      else {
      // tag::p2p-act-rep-status[]
          print("Replicator is currently ", thisReplicator?.status.activity)
      }
    })

    // end::p2p-act-rep-status[]
    // end::p2p-act-rep-add-change-listener[]

    // tag::p2p-act-rep-start[]
        // Run the replicator using the config settings
        thisReplicator?.start()  <i class="conum" data-value="90"></i><b>(90)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]


    // end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener

    thisReplicator?.removeChangeListener(withToken: pushPullReplListener)
    // Stop the replicator
    thisReplicator?.stop()

// end::p2p-act-rep-stop[]
}


// BEGIN Additional p2p-avt-rep options
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="91"></i><b>(91)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    config.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="93"></i><b>(93)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: validUser, password: validPassword)
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-tlsid-tlsidentity-with-label[]
      // Check if Id exists in keychain and if so, use that Id
      if let thisIdentity =
        (try? TLSIdentity.identity(withLabel: "doco-sync-server")) ?? nil { <i class="conum" data-value="94"></i><b>(94)</b>
          print("An identity with label : doco-sync-server already exists in keychain")
          thisAuthenticator = ClientCertificateAuthenticator(identity: thisIdentity)  <i class="conum" data-value="95"></i><b>(95)</b>
          config.authenticator = thisAuthenticator
          }

      // end::p2p-tlsid-check-keychain[]
    // end::p2p-tlsid-tlsidentity-with-label[]
// END Additional p2p-avt-rep options




// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
    // tag::old-p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-tlsid-check-keychain[]
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        do {
            if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
                print("An identity with label : doco-sync-server already exists in keychain")
                return thisIdentity
                }
        } catch
          {return nil}
        // end::p2p-tlsid-check-keychain[]
        thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
        config.thisAuthenticator
    // end::old-p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert

// tag::p2p-tlsid-delete-id-from-keychain[]

try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);

// end::p2p-tlsid-delete-id-from-keychain[]


// end::p2p-tlsid-manage-func[]
// tag::old-p2p-act-rep-config-self-cert[]
// acceptOnlySelfSignedServerCertificate = true -- accept Slf-Signed Certs
config.disableTLS = false
config.acceptOnlySelfSignedServerCertificate = true

// end::old-p2p-act-rep-config-self-cert[]

// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]

  // Get bundled resource and read into localcert
  guard let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer")
    else { /* process error */ }
  guard let localCertificate:NSData =
               NSData(contentsOfFile: pathToCert)
    else { /* process error */ }

  // Create certificate
  // using its DER representation as a CFData
  guard let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
    else { /* process error */ }

  // Add `pinnedCert` and `acceptOnlySelfSignedServerCertificate=false` to `ReplicatorConfiguration`
  config.acceptOnlySelfSignedServerCertificate = false
  config.pinnedServerCertificate = pinnedCert
  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}

    // optionally  listenerConfig.tlsIdentity = TLSIdentity(withIdentity:serverSelfCert-id)


        // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="96"></i><b>(96)</b>

    // end::old-listener-config-client-root-ca[]

    // For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
class MyClass {
    var database: Database?
    var replicator: Replicator? <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database!, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator?.start()
    }
}

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]

&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

    // tag::sgw-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="97"></i><b>(97)</b>

    // end::sgw-act-rep-initialize[]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Import from an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML


class SampleCodeTest {

    var database: Database!
    var db: Database!

    var replicator: Replicator!

    // MARK: Database

    func dontTestNewDatabase() throws {
        // tag::new-database[]
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }
        // end::new-database[]

        // tag::close-database[]
        do {
            try userDb.close()
        }

        // end::close-database[]


    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        // tag::database-encryption[]
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        // end::database-encryption[]
    }
    #endif

    func dontTestLogging() throws {
        // tag::logging[]
        Database.setLogLevel(.verbose, domain: .replicator)
        Database.setLogLevel(.verbose, domain: .query)
        // end::logging[]
    }

    func dontTestConsoleLogging() throws {
        // tag::console-logging[]
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>

        // end::console-logging[]
        // tag::console-logging-db[]

        Database.log.console.domains = .database

        // end::console-logging-db[]
    }

    func dontTestFileLogging() throws {
        // tag::file-logging[]
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
        // end::file-logging[]
    }

    func dontTestEnableCustomLogging() throws {
        // tag::set-custom-logging[]
        Database.log.custom = LogTestLogger(.warning) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    func dontTestLoadingPrebuilt() throws {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
        // end::prebuilt-database[]
    }

    // MARK: Document

    func dontTestInitializer() throws {
        database = self.db

        // tag::initializer[]
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
        // end::initializer[]
    }

    func dontTestMutability() throws {
        database = self.db

        // tag::update-document[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
        // end::update-document[]
    }

    func dontTestTypedAcessors() throws {
        let newTask = Document()

        // tag::date-getter[]
        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")
        // end::date-getter[]

        // tag::to-dictionary[]
        newTask.toDictionary() <i class="conum" data-value="9"></i><b>(9)</b>

        // end::to-dictionary[]

        // tag::to-json[]
        newTask.toJSON() <i class="conum" data-value="10"></i><b>(10)</b>

        // end::to-json[]

        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        // tag::batch[]
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::batch[]
    }

    func dontTestChangeListener() throws {
        database = self.db

        // tag::document-listener[]
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
        // end::document-listener[]
    }

    func dontTestDocumentExpiration() throws {
        database = self.db

        // tag::document-expiration[]
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try db.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        // end::document-expiration[]

    }

    func dontTestBlob() throws {
    #if TARGET_OS_IPHONE
        database = self.db
        let newTask = MutableDocument()
        var image: UIImage!

        // tag::blob[]
        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)!

        let blob = Blob(contentType: "image/jpeg", data: imageData)
        newTask.setBlob(blob, forKey: "avatar")
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }
        // end::blob[]

        print("\(image)")
    #endif
    }

    func dontTest1xAttachment() throws {
        database = self.db
        let document = MutableDocument()

        // tag::1x-attachment[]
        let attachments = document.dictionary(forKey: "_attachments")
        let avatar = attachments?.blob(forKey: "avatar")
        let content = avatar?.content
        // end::1x-attachment[]

        print("\(content!)")
    }

    // MARK: Query

    func dontTestIndexing() throws {
        database = self.db

        // tag::query-index[]
        let index = IndexBuilder.valueIndex(items:
            ValueIndexItem.expression(Expression.property("type")),
            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
        // end::query-index[]
    }

    func dontTestSelectMeta() throws {
        database = self.db

        // tag::query-select-meta[]
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-meta[]
    }


    func dontTestSelectProps() throws {
        database = self.db

        // tag::query-select-props[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-props[]
    }

    func dontTestSelectAll() throws {
        database = self.db

        // tag::query-select-all[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
        // end::query-select-all[]

        // tag::live-query[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="11"></i><b>(11)</b>
            for result in change.results! {
                print(result.keys)
                /* Update UI */
            }
        }

        // Start live query.
        query.execute(); <i class="conum" data-value="12"></i><b>(12)</b>
        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(withToken: token) <i class="conum" data-value="13"></i><b>(13)</b>

        // end::stop-live-query[]

        print("\(query)")
    }

    func dontTestWhere() throws {
        database = self.db

        // tag::query-where[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
        // end::query-where[]
    }

    func dontTestQueryDeletedDocuments() throws {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(Meta.isDeleted)
        // end::query-deleted-documents[]
    }

    func dontTestCollectionOperatorContains() throws {
        database = self.db

        // tag::query-collection-operator-contains[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                .and(ArrayFunction.contains(Expression.property("public_likes"), value: Expression.string("Armani Langworth")))
        )

        do {
             for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
        // end::query-collection-operator-contains[]
    }

    func dontTestCollectionOperatorIn() throws {
        database = self.db

        // tag::query-collection-operator-in[]
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
            ]

        QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))
        // end::query-collection-operator-in[]
    }


    func dontTestLikeOperator() throws {
        database = self.db

        // tag::query-like-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
        // end::query-like-operator[]
    }

    func dontTestWildCardMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-character-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-character-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        database = self.db

        // tag::query-regex-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="14"></i><b>(14)</b>
            )
            .limit(Expression.int(10))
        // end::query-regex-operator[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        database = self.db

        // tag::query-join[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX")))
        )
        // end::query-join[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        database = self.db

        // tag::query-groupby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
        )

        do {
            for result in try query.execute() {
                print("There are \(result.int(forKey: "$1")) airports on the \(result.string(forKey: "tz")!) timezone located in \(result.string(forKey: "country")!) and above 300 ft")
            }
        }
        // end::query-groupby[]
    }

    func dontTestOrderBy() throws {
        database = self.db

        // tag::query-orderby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))
        // end::query-orderby[]

        print("\(query)")
    }

    func dontTestExplain() throws {
      database = self.db
      // tag::query-explain-all[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("university")))
          .groupBy(Expression.property("country"))
          .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="15"></i><b>(15)</b>

      print(try thisQuery.explain()) <i class="conum" data-value="16"></i><b>(16)</b>
      // end::query-explain-all[]

      // tag::query-explain-like[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="17"></i><b>(17)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain())

      // end::query-explain-like[]

      // tag::query-explain-nopfx[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="18"></i><b>(18)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain());

      // end::query-explain-nopfx[]

      // tag::query-explain-function[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Function.lower(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="19"></i><b>(19)</b>

      print(try thisQuery.explain());

      // end::query-explain-function[]

      // tag::query-explain-nofunction[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="20"></i><b>(20)</b>

      print(try thisQuery.explain());

      // end::query-explain-nofunction[]

    }


    func dontTestCreateFullTextIndex() throws {
        database = self.db

        // tag::fts-index[]
        // Insert documents
        let tasks = ["buy groceries", "play chess", "book travels", "buy museum tickets"]
        for task in tasks {
            let doc = MutableDocument()
            doc.setString("task", forKey: "type")
            doc.setString(task, forKey: "name")
            try database.saveDocument(doc)
        }

        // Create index
        do {
            let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("name")).ignoreAccents(false)
            try database.createIndex(index, withName: "nameFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-index[]
    }

    func dontTestFullTextSearch() throws {
        database = self.db

        // tag::fts-query[]
        let whereClause = FullTextExpression.index("nameFTSIndex").match("'buy'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)

        do {
            for result in try query.execute() {
                print("document id \(result.string(at: 0)!)")
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-query[]
    }


    func dontTestToJson-ArrayObject() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-array[]




        // end::tojson-array[]
    }



    func dontTestGetBlobAsJSONstring() throws {
        db = self.db

        // tag::tojson-getblobasstring[]

        let thisdoc = db.document(withID: "thisdoc-id")!.toDictionary();
        let thisBlob =  thisdoc["avatar"] as! Blob

        if Blob.isBlob(properties: thisBlob.properties) {
          var blobtype = thisBlob.properties["content_type"]
          var bloblength = thisBlob.properties["length"]
        }
        // end::tojson-getblobasstring[]
    }


    func dontTestToJson-Dictionary() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-dictionary[]


        // end::tojson-dictionary[]
    }


    func dontTestToJson-Document() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-document[]


        // end::tojson-document[]
    }


    func dontTestToJson-Result() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-result[]
        let ourJSON =  "{{\"id\": \"hotel-ted\"},{\"name\": \"Hotel Ted\"},{\"city\": \"Paris\"},{\"type\": \"hotel\"}}"
        let ourDoc = try MutableDocument(id: "doc", json: ourJSON)
        try database.saveDocument(ourDoc)

        let query = QueryBuilder
                      .select(SelectResult.all)
                      .from(DataSource.database(database)))
                      .where(Expression.property("id").equalTo(Expression.string("hotel-ted"))))

        for (_,result) in try! query.execute().enumerated() {
          if let thisJSON = result.toJSON().toJSONObj() as? [String:Any] {
              // ... process document properties as required e.g.
              let docid = thisJSON["id"]
              let name = thisJSON["name"]
              let city = thisJSON["city"]
              let type = thisJSON["type"]
              //
          }

        // end::tojson-result[]
    }







    // MARK: Replication

    /* The `tag::replication[]` example is inlined in swift.adoc */

    func dontTestEnableReplicatorLogging() throws {
        // tag::replication-logging[]
        // Replicator
        Database.setLogLevel(.verbose, domain: .replicator)
        // Network
        Database.setLogLevel(.verbose, domain: .network)
        // end::replication-logging[]
    }

    func dontTestReplicationBasicAuthentication() throws {
        // tag::basic-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::basic-authentication[]
    }

    func dontTestReplicationSessionAuthentication() throws {
        // tag::session-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::session-authentication[]
    }

    func dontTestReplicatorStatus() throws {
        // tag::replication-status[]
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
        // end::replication-status[]
    }

//  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {
      // tag::replication-pendingdocuments[]

      let url = URL(string: "ws://localhost:4984/mydatabase")!
      let target = URLEndpoint(url: url)

      let config = ReplicatorConfiguration(database: database, target: target)
      config.replicatorType = .push

      // tag::replication-push-pendingdocumentids[]
      self.replicator = Replicator(config: config)
      let mydocids:Set = self.replicator.pendingDocumentIds() <i class="conum" data-value="21"></i><b>(21)</b>

      // end::replication-push-pendingdocumentids[]
      if(!mydocids.isEmpty) {
        print("There are \(mydocids.count) documents pending")

        self.replicator.addChangeListener { (change) in
          print("Replicator activity level is \(change.status.activity.toString())")
          // iterate and report-on previously
          // retrieved pending docids 'list'
          for thisId in mydocids.sorted() {
            // tag::replication-push-isdocumentpending[]
            if(!self.replicator.isDocumentPending(thisid)) { <i class="conum" data-value="22"></i><b>(22)</b>
              print("Doc ID \(thisId) now pushed")
            }
            // end::replication-push-isdocumentpending[]
          }
        }

        self.replicator.start()
        // end::replication-pendingdocuments[]
    }

//  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        // tag::add-document-replication-listener[]
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        self.replicator.removeChangeListener(withToken: token)
        // end::remove-document-replication-listener[]
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-custom-header[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
        // end::replication-custom-header[]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-channels[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
        // end::replication-channels[]
    }

    func dontTestHandlingReplicationError() throws {
        // tag::replication-error-handling[]
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
        // end::replication-error-handling[]
    }

    func dontTestReplicationResetCheckpoint() throws {
        // tag::replication-reset-checkpoint[]
        if (resetCheckpointRequired_Example) {
          self.replicator.start(reset: true)  <i class="conum" data-value="23"></i><b>(23)</b>
        else
          self.replicator.start()
        }

        // end::replication-reset-checkpoint[]
    }

    func dontTestReplicationPushFilter() throws {
        // tag::replication-push-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-push-filter[]
    }

    func dontTestReplicationPullFilter() throws {
        // tag::replication-pull-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-pull-filter[]
    }

//  Added 2/Feb/21 - Ian Bridge
//  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        // tag::replication-retry-config[]
        let target =
          URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        let config =  ReplicatorConfiguration(database: database, target: targetDatabase)
        config.type = .pushAndPull
        config.continuous = true
        // tag::replication-set-heartbeat[]
        config.heartbeat = 150 <i class="conum" data-value="24"></i><b>(24)</b>

        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
        config.maxattempts = 20 <i class="conum" data-value="25"></i><b>(25)</b>

        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
        config.maxattemptwaittime = 600 <i class="conum" data-value="26"></i><b>(26)</b>
        repl = Replicator(config: config)

        // end::replication-set-maxattemptwaittime[]

        // end::replication-retry-config[]
    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Swift Community. */
        // tag::database-replica[]
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::database-replica[]

        try database2.delete()
    }
    #endif

    func dontTestCertificatePinning() throws {

        // tag::certificate-pinning[]
        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate
        // end::certificate-pinning[]

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // tag::getting-started[]
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        let replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
        // end::getting-started[]
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::register-model[]
        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")
        // end::register-model[]

        // tag::predictive-query-value-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel(withName: "ImageClassifier")
        // end::unregister-model[]
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query-predictive-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
        // end::predictive-query-predictive-index[]
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(
                    prediction.property("probablity")
                        .greaterThanOrEqualTo(Expression.double(0.8))
                )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
        // end::predictive-query[]
    }

    func dontTestCoreMLPredictiveModel() throws {
        // tag::coreml-predictive-model[]
        // Load MLModel from `ImageClassifier.mlmodel`
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
        // end::coreml-predictive-model[]
    }

    func dontTestReplicatorConflictResolver() throws {
        // tag::replication-conflict-resolver[]
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-conflict-resolver[]
    }

    func dontTestSaveWithConflictHandler() throws {
        // tag::update-document-with-conflict-handler[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, _) in first })
            new.setData(result)
            return true
        })
        // end::update-document-with-conflict-handler[]

    }

    // helper
    func isValidCredentials(_ u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        let db: Database!

        // tag::init-urllistener[]
        let config = URLEndpointListenerConfiguration(database: db)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator:
            { (username, password) -&gt; Bool in
                return self.isValidCredentials(username, password: password)
        })

        // end::init-urllistener[]
    }

    func dontTestListenerStart() throws {
        let listener: URLEndpointListener

        // tag::start-urllistener[]
        try listener.start()

        // end::start-urllistener[]
    }

    func dontTestListenerStop() throws {
        let listener: URLEndpointListener
        // tag::stop-urllistener[]
        listener.stop()

        // end::stop-urllistener[]
    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        // tag::create-self-signed-cert[]
        // tag::listener-config-tls-id-SelfSigned[]
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
          try TLSIdentity.createIdentity(forServer: true,
                attributes: attrs,
                expiration: Date().addingTimeInterval(86400),
                label: "Server-Cert-Label")
        // end::listener-config-tls-id-SelfSigned[]
        // end::create-self-signed-cert[]
        print("\(identity.expiration)") // to avoid warning
    }
}


// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] {}
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // `myMLModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}
// end::predictive-model[]

// tag::custom-logging[]
fileprivate class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }

}
// end::custom-logging[]

// tag::local-win-conflict-resolver[]
class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}
// end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        // tag::message-endpoint[]
        let database = try Database(name: "dbname")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /* implements MessageEndpointConnection */
        return connection
    }
    // end::create-connection[]

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::active-peer-open[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::active-peer-send[]

    func receive(data: Data) {
        // tag::active-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::active-peer-receive[]
    }

    // tag::active-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::active-peer-close[]

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        // tag::listener[]
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
        // end::listener[]
    }

    func stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    func acceptConnection() {
        // tag::advertizer-accept[]
        let connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection: connection)
        // end::advertizer-accept[]
    }

    func disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::passive-peer-send[]

    func receive(data: Data) {
        // tag::passive-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::passive-peer-receive[]
    }

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::passive-peer-close[]
}


// BEGIN URLENDPOINTLISTENER SAMPLES

//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
        let config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.port = tls ? wssPort : wsPort
        config.disableTLS = !tls
        config.authenticator = auth

        return try listen(config: config)
    }

    @discardableResult
    func listen(config: URLEndpointListenerConfiguration) throws -&gt; URLEndpointListener {
        self.listener = URLEndpointListener.init(config: config)

        // Start:
        try self.listener!.start()

        return self.listener!
    }

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
        }
    }

    func cleanUpIdentities() throws {
        self.ignoreException {
            try URLEndpointListener.deleteAnonymousIdentities()
        }
    }

    func replicator(db: Database, continuous: Bool, target: Endpoint, serverCert: SecCertificate?) -&gt; Replicator {
        let config = ReplicatorConfiguration(database: db, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = continuous
        config.pinnedServerCertificate = serverCert
        return Replicator(config: config)
    }

    /// Two replicators, replicates docs to the self.listener; validates connection status
    func validateMultipleReplicationsTo() throws {
        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")
        let count = self.listener!.config.database.count

        // open DBs
        try deleteDB(name: "db1")
        try deleteDB(name: "db2")
        let db1 = try openDB(name: "db1")
        let db2 = try openDB(name: "db2")

        // For keeping the replication long enough to validate connection status, we will use blob
        let imageData = try dataFromResource(name: "image", ofType: "jpg")

        // DB#1
        let doc1 = createDocument()
        let blob1 = Blob(contentType: "image/jpg", data: imageData)
        doc1.setBlob(blob1, forKey: "blob")
        try db1.saveDocument(doc1)

        // DB#2
        let doc2 = createDocument()
        let blob2 = Blob(contentType: "image/jpg", data: imageData)
        doc2.setBlob(blob2, forKey: "blob")
        try db2.saveDocument(doc2)

        let repl1 = replicator(db: db1,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])
        let repl2 = replicator(db: db2,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        var maxConnectionCount: UInt64 = 0, maxActiveCount: UInt64 = 0
        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .busy {
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount);
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount);
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db1" {
                    exp1.fulfill()
                } else {
                    exp2.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        // check both replicators access listener at same time
        XCTAssertEqual(maxConnectionCount, 2);
        XCTAssertEqual(maxActiveCount, 2);

        // all data are transferred to/from
        XCTAssertEqual(self.listener!.config.database.count, count + 2);
        XCTAssertEqual(db1.count, count + 1/* db2 doc*/);
        XCTAssertEqual(db2.count, count + 1/* db1 doc*/);

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db1.close()
        try db2.close()
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // Anonymous Identity:
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // User Identity:
// tag::p2psync-act-tlsid-create[]
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
// end::p2psync-act-tlsid-create[]
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
    }

    func testPasswordAuthenticator() throws {
        // Listener:
        let listenerAuth = ListenerPasswordAuthenticator.init {
            (username, password) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: listenerAuth)

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Success:
        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth)

        // Cleanup:
        try stopListen()
    }

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)

// tag::p2psync-act-tlsid-delete[]
        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
// end::p2psync-act-tlsid-delete[]

        // Create client identity:
// tag::p2psync-act-tlsid-import[]
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)
// end::p2psync-act-tlsid-import[]

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .selfSignedCert, serverCert: nil)
        }

        // Cleanup
        try stopListen()
    }

    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: serverCert)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: .caCert, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }

    func testMultipleListenersOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        let listener1 = URLEndpointListener(config: config)
        let listener2 = URLEndpointListener(config: config)

        try listener1.start()
        try listener2.start()

        try generateDocument(withID: "doc-1")
        self.run(target: listener1.localURLEndpoint,
                 type: .pushAndPull,
                 continuous: false,
                 auth: nil,
                 serverCert: listener1.tlsIdentity!.certs[0])

        // since listener1 and listener2 are using same certificates, one listener only needs stop.
        listener2.stop()
        try stopListener(listener: listener1)
        XCTAssertEqual(self.oDB.count, 1)
    }

    func testReplicatorAndListenerOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")

        // listener
        let doc = createDocument()
        try self.oDB.saveDocument(doc)
        try listen()

        // Replicator#1 (otherDB -&gt; DB#1)
        let doc1 = createDocument()
        try self.db.saveDocument(doc1)
        let target = DatabaseEndpoint(database: self.db)
        let repl1 = replicator(db: self.oDB, continuous: true, target: target, serverCert: nil)

        // Replicator#2 (DB#2 -&gt; Listener(otherDB))
        try deleteDB(name: "db2")
        let db2 = try openDB(name: "db2")
        let doc2 = createDocument()
        try db2.saveDocument(doc2)
        let repl2 = replicator(db: db2,
                               continuous: true,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .idle &amp;&amp;
                change.status.progress.completed == change.status.progress.total {
                if self.oDB.count == 3 &amp;&amp; self.db.count == 3 &amp;&amp; db2.count == 3 {
                    change.replicator.stop()
                }
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db2" {
                    exp2.fulfill()
                } else {
                    exp1.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        XCTAssertEqual(self.oDB.count, 3)
        XCTAssertEqual(self.db.count, 3)
        XCTAssertEqual(db2.count, 3)

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db2.close()
        try stopListen()
    }

    func testCloseWithActiveListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        // Close database should also stop the listener:
        try self.oDB.close()

        XCTAssertNil(self.listener!.port)
        XCTAssertNil(self.listener!.urls)

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-1008
    func _testEmptyNetworkInterface() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        for (i, url) in self.listener!.urls!.enumerated() {
            // separate db instance!
            let db = try Database(name: "db-\(i)")
            let doc = createDocument()
            doc.setString(url.absoluteString, forKey: "url")
            try db.saveDocument(doc)

            // separate replicator instance
            let target = URLEndpoint(url: url)
            let rConfig = ReplicatorConfiguration(database: db, target: target)
            rConfig.pinnedServerCertificate = self.listener?.tlsIdentity!.certs[0]
            run(config: rConfig, expectedError: nil)

            // remove the db
            try db.delete()
        }

        XCTAssertEqual(self.oDB.count, UInt64(self.listener!.urls!.count))

        let q = QueryBuilder.select([SelectResult.all()]).from(DataSource.database(self.oDB))
        let rs = try q.execute()
        var result = [URL]()
        for res in rs.allResults() {
            let dict = res.dictionary(at: 0)
            result.append(URL(string: dict!.string(forKey: "url")!)!)
        }

        XCTAssertEqual(result, self.listener!.urls)
        try stopListen()

        // validate 0.0.0.0 meta-address should return same empty response.
        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.networkInterface = "0.0.0.0"
        try listen(config: config)
        XCTAssertEqual(self.listener!.urls!, result)
        try stopListen()
    }

    func testMultipleReplicatorsToListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        let doc = createDocument()
        doc.setString("Tiger", forKey: "species")
        try self.oDB.saveDocument(doc)

        try validateMultipleReplicationsTo()

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-954
    func _testReadOnlyListener() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.readOnly = true
        try listen(config: config)

        self.run(target: self.listener!.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, serverCert: self.listener!.tlsIdentity!.certs[0],
                 expectedError: CBLErrorHTTPForbidden)
    }
}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}

// END URLENDPOINTLISTENER SAMPLES


//
//  QueryResultSets.swift
//  sampleQueryResults
//
//  Created by Ian Bridge on 28/07/2021.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

//import CoreML


class Query {

    var this_hotel:Hotel = Hotel()

    let dbName = "hotel"
    //    let dbName = "hotel"
    var db = try! Database(name: "hotel")
    var hotels = [String:Any]()
    var thisDocsProperties = [String:Any]()
    var jsonbit = [String:Any]()

    func dontTestQueryAll() throws {





    //        seedHotel()

    // QUERY RESULT SET HANDLING EXAMPLES
    // tag::query-syntax-all[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database( db))

    // end::query-syntax-all[]

    // tag::query-access-all[]

        do {

            for row in try! listQuery.execute() {

                let thisDocsProps =
                    row.dictionary(at: 0)?.toDictionary() <i class="conum" data-value="27"></i><b>(27)</b>

                let docid = thisDocsProps!["id"] as! String

                let name = thisDocsProps!["name"] as! String

                let type = thisDocsProps!["type"] as! String

                let city = thisDocsProps!["city"] as! String

                let hotel = row.dictionary(at: 0)?.toDictionary()  <i class="conum" data-value="28"></i><b>(28)</b>
                let hotelId = hotel!["id"] as! String
                hotels[hotelId] = hotel
            } // end for

        } //end do-block

    // end::query-access-all[]

    // tag::query-access-json[]

    // In this example the Hotel class is defined using Codable
    //
    // class Hotel : Codable {
    //   var id : String = "undefined"
    //   var type : String = "hotel"
    //   var name : String = "undefined"
    //   var city : String = "undefined"
    //   var country : String = "undefined"
    //   var description : String? = ""
    //   var text : String? = ""
    //   ... other class content
    // }


        do {
            var results = try! listQuery.execute()
            for row in  results {

                // get the result into a JSON String
                let jsonString = row.toJSON() <i class="conum" data-value="29"></i><b>(29)</b>

                let thisJsonObj:Dictionary =
                    try! (JSONSerialization.jsonObject(
                            with: jsonString.data(using: .utf8)!,
                                                  options: .allowFragments)
                            as? [String: Any])! <i class="conum" data-value="30"></i><b>(30)</b>

                // Use Json Object to populate Native object
                // Use Codable class to unpack JSON data to native object
                let this_hotel:Hotel =
                    (try JSONDecoder().decode(
                        Hotel.self,
                        from: jsonString.data(using: .utf8)!
                        )
                    ) <i class="conum" data-value="31"></i><b>(31)</b>

                // ALTERNATIVELY unpack in steps
                this_hotel.id = thisJsonObj["id"] as! String
                this_hotel.name = thisJsonObj["name"] as! String
                this_hotel.type = thisJsonObj["type"] as! String
                this_hotel.city = thisJsonObj["city"] as! String
                hotels[this_hotel.id] = this_hotel


            } // end for

            // end::query-access-json[]

        } catch let err {
            print(err.localizedDescription)

        } // end do



    } // end func dontTestQueryAll



    func dontTestQueryProps () throws {
        // tag::query-syntax-props[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()
        var hotel:Hotel = Hotel.init()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
                    .from(DataSource.database(db))

        // end::query-syntax-props[]

        // tag::query-access-props[]
        for (_, result) in try! listQuery.execute().enumerated() {


            let thisDoc = result.toDictionary() as? [String:Any]  <i class="conum" data-value="32"></i><b>(32)</b>
                // Store dictionary data in hotel object and save in arry
            hotel.id = thisDoc!["id"] as! String
            hotel.name = thisDoc!["name"] as! String
            hotel.city = thisDoc!["city"] as! String
            hotel.type = thisDoc!["type"] as! String
            hotels[hotel.id] = hotel

            // Use result content directly
            let docid = result.string(forKey: "metaId")
            let hotelId = result.string(forKey: "id")
            let name = result.string(forKey: "name")
            let city = result.string(forKey: "city")
            let type = result.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: ", docid, hotelId,name, city, type)
          } // end for

// end::query-access-props[]
    }// end func

//
    func dontTestQueryCount () throws {

    // tag::query-syntax-count-only[]
        let db = try! Database(name: "hotel")
        do {
            let listQuery = QueryBuilder
                .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
                .from (DataSource.database(db)).groupBy(Expression.property("type"))

                // end::query-syntax-count-only[]


            // tag::query-access-count-only[]

            for result in try! listQuery.execute() {
                let dict = result.toDictionary() as? [String: Int]
                let thiscount = dict!["mycount"]! <i class="conum" data-value="33"></i><b>(33)</b>
                print("There are ", thiscount, " rows")

                // Alternatively
                print ( result["mycount"] )

            } // end for

        } // end do
    } // end function

// end::query-access-count-only[]

//
    func dontTestQueryId () throws {

        // tag::query-syntax-id[]
        let db = try! Database(name: "hotel")
        let listQuery = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
                    .from(DataSource.database(db))

        // end::query-syntax-id[]


        // tag::query-access-id[]
        for (_, result) in try! listQuery.execute().enumerated() {

            print(result.toDictionary())
            print("Document Id is -- ", result["metaId"].string!)

            let thisDocsId = result["metaId"].string! <i class="conum" data-value="34"></i><b>(34)</b>

            // Now you can get the document using the ID
            var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

            let hotelId = thisDoc["id"] as! String

            let name = thisDoc["name"] as! String

            let city = thisDoc["city"] as! String

            let type = thisDoc["type"] as! String

            // ... process document properties as required
            print("Result properties are: ", hotelId,name, city, type)


        } // end for

// end::query-access-id[]
    } // end function dontTestQueryId

//
    func query_pagination () throws {

        //tag::query-syntax-pagination[]
        let thisOffset = 0;
        let thisLimit = 20;
        //
        let listQuery = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(db))
                .limit(Expression.int(thisLimit),
                  offset: Expression.int(thisOffset))

        // end::query-syntax-pagination[]

    } // end function
//
//


    func seedHotel () {

        try! db.delete()

        db = try! Database(name: "hotel")

        let key = ["id","name","type","city", "country","description"]
        let val = [
                    ["1000","Hotel Ted","hotel","Paris", "France","Very good and central"],
                    ["1001","Hotel Fred","hotel","London", "England","Very good and central"],
                    ["1002","Hotel Du Ville","hotel","Casablanca", "Morocco","Very good and central"],
                    ["1003","Hotel Ouzo","hotel","Athens", "Greece","Very good and central"]
                ]
        let maxrecs=val.count-1
        for i in 0 ... maxrecs {

            let hotel:MutableDocument = MutableDocument(id: val[0][i])

            for x in 0 ... key.count-1 {
                hotel.setString(val[i][x], forKey: key[x])
            }

            try! db.saveDocument(hotel)


        }

    }

//
// N1QL QUERY EXAMPLES
//

    func dontTestQueryN1QL() throws {


    // tag::query-syntax-n1ql[]
        let db = try! Database(name: "hotel")

        let listQuery =  db.createQuery( query:
            "SELECT META().id AS thisId FROM _ WHERE type = 'hotel'" <i class="conum" data-value="35"></i><b>(35)</b>
        )

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QL


    func dontTestQueryN1QLparams() throws {

    // tag::query-syntax-n1ql-params[]
        let db = try! Database(name: "hotel")

        let listQuery =
            db.createQuery( query:
                   "SELECT META().id AS thisId FROM _ WHERE type = $type" <i class="conum" data-value="36"></i><b>(36)</b>
                )

        listQuery.parameters =
            Parameters().setString("hotel", forName: "type") <i class="conum" data-value="37"></i><b>(37)</b>

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql-params[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QLparams()


    func dontTestProcessResults(results: ResultSet) throws {
        // tag::query-access-n1ql[]
        // tag::query-process-results[]

        do {

            for row in results {

                print(row["thisId"].string!)

                let thisDocsId = row["thisId"].string!

                // Now you can get the document using the ID
                var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

                let hotelId = thisDoc["id"] as! String

                let name = thisDoc["name"] as! String

                let city = thisDoc["city"] as! String

                let type = thisDoc["type"] as! String

                // ... process document properties as required
                print("Result properties are: ", hotelId,name, city, type)

            } // end for
            // end::query-access-n1ql[]
            // end::query-process-results[]

        } //end do-block

    } // end dontTestProcessResults

} // end class






//  JSON API SNIPPETS


    func dontTestJSONdocument() {
        // tag::query-get-all[]
        let db = try! Database(name: "hotel")
        let dbnew = try! Database(name: "newhotels")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(db))


        for row in try! listQuery.execute() {
        // end::query-get-all[]

        // tag::tojson-document[]
            var thisId = row.string(forKey: "metaId")! as String

            var thisJSONstring = try! db.document(withID: thisId)!.toJSON() <i class="conum" data-value="38"></i><b>(38)</b>

            print("JSON String = ", thisJSONstring as! String)

            let hotelFromJSON:MutableDocument = <i class="conum" data-value="39"></i><b>(39)</b>
                    try! MutableDocument(id: thisId as? String, json: thisJSONstring)

            try! dbnew.saveDocument(hotelFromJSON)

            let newhotel = dbnew.document(withID: thisId)

            let keys = newhotel!.keys
            for key in keys { <i class="conum" data-value="40"></i><b>(40)</b>
                print(key, newhotel!.value(forKey: key) as! String)
            }

            // end::tojson-document[]

        /*
        // tag::tojson-document-output[]
             JSON String =  {"description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
             type hotel
             id 1000
             country France
             city Paris
             description Very good and central
             name Hotel Ted
        // end::tojson-document-output[]
         */
        } // end  query for loop


        // tag::tojson-array[]

        let thisJSONstring = """
            [{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
            \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
            {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
            \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
            \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]
            """
        let myArray:MutableArrayObject =
            try! MutableArrayObject.init(json: thisJSONstring) <i class="conum" data-value="41"></i><b>(41)</b>

        for i in 0...myArray.count-1 {

            print(i+1, myArray.dictionary(at: i)!.string(forKey: "name")!)

            var docid = myArray.dictionary(at: i)!.string(forKey: "id")

            var newdoc:MutableDocument = <i class="conum" data-value="42"></i><b>(42)</b>
                try! MutableDocument(id: docid,
                         data: (myArray.dictionary(at: i)?.toDictionary())! )

            try! dbnew.saveDocument(newdoc)

        }

        let extendedDoc = dbnew.document(withID: "1002")
        let features =
            extendedDoc!.array(forKey: "features")?.toArray() <i class="conum" data-value="43"></i><b>(43)</b>
        for i in 0...features!.count-1 {
            print(features![i])
        }

        print( extendedDoc!.array(
                forKey: "features")?.toJSON() as! String) <i class="conum" data-value="44"></i><b>(44)</b>

        // end::tojson-array[]

        /*
        // tag::tojson-array-output[]

         1 Hotel Ted
         2 Hotel Fred
         3 Hotel Ned

         Cable TV
         Toaster
         Microwave

         ["Cable TV","Toaster","Microwave"]
         // end::tojson-array-output[]
        */


        // tag::tojson-dictionary[]

        var aJSONstring = """
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\"}
            """

        let myDict:MutableDictionaryObject =
            try! MutableDictionaryObject(json: aJSONstring) <i class="conum" data-value="45"></i><b>(45)</b>
        print(myDict)

        let name = myDict.string(forKey: "name")
        print("Details for: ", name!)

        for key in myDict {

            print(key, myDict.value(forKey: key) as! String)

        }


        // end::tojson-dictionary[]

        /*
        // tag::tojson-dictionary-output[]

         Details for:  Hotel Ned
         description Undefined description for Hotel Ned
         id 1002
         name Hotel Ned
         country Australia
         type hotel
         city Balmain

         // end::tojson-dictionary-output[]
        */
    public func JsonApiBlob() throws {
        // tag::tojson-blob[]
      // Get a document
        let thisDoc = db.document(withID: "1000")?.toMutable() <i class="conum" data-value="46"></i><b>(46)</b>

        // Get the image and add as a blob to the document
        let contentType = "image/jpg";
        let ourImage = UIImage(named: "couchbaseimage.png")!
        let imageData = ourImage.jpegData(compressionQuality: 1)!
        thisDoc?.setBlob(
            Blob(contentType: contentType, data: imageData), forKey: "avatar") <i class="conum" data-value="47"></i><b>(47)</b>

       let theBlobAsJSONstringFails =
              thisDoc?.blob(forKey: "avatar")!.toJSON();

        // Save blob as part of doc or alternatively as a blob

        try! db.saveDocument(thisDoc!);
        try! db.saveBlob(
                blob: Blob(contentType: contentType, data: imageData)); <i class="conum" data-value="48"></i><b>(48)</b>

        // Retrieve saved blob as a JSON, reconstitue and check still blob
        let sameDoc = db.document(withID: "1000")
        let sameBlob = sameDoc?.blob(forKey: "avatar")
        let theBlobAsJSONstring = sameBlob!.toJSON(); <i class="conum" data-value="49"></i><b>(49)</b>

        for (key, value) in sameDoc!.toDictionary() {
             print( "Data -- {0) = {1}", key, value);
        }

        if(Blob.isBlob(properties: sameBlob!.properties)) <i class="conum" data-value="50"></i><b>(50)</b>
        {
            print(theBlobAsJSONstring);
        }

        // end::tojson-blob[]


    }

//    } // end func testjson

//        } // end query loop

    } // end jsonapi func


}

    extension String {

        func toJSONObj() -&gt; Any {

            let d1 = self.data(using: .utf8)

            return try! JSONSerialization.jsonObject(
                with: d1!, options:[])
        }
    }



//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

// tag::listener[]

// tag::listener-simple[]
val config =
  URLEndpointListenerConfiguration(database) <i class="conum" data-value="51"></i><b>(51)</b>

config.setAuthenticator(
    ListenerPasswordAuthenticator {
      username, password -&gt;
        "valid.user" == username &amp;&amp;
        ("valid.password.string" == String(password))
    }
) <i class="conum" data-value="52"></i><b>(52)</b>

val listener =
  URLEndpointListener(config) <i class="conum" data-value="53"></i><b>(53)</b>

listener.start()  <i class="conum" data-value="54"></i><b>(54)</b>

// end::listener-simple[]



// tag::replicator-simple[]

let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="55"></i><b>(55)</b>

var thisConfig = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="56"></i><b>(56)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="57"></i><b>(57)</b>

let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="58"></i><b>(58)</b>

this.replicator = new Replicator(config); <i class="conum" data-value="59"></i><b>(59)</b>

this.replicator.start(); <i class="conum" data-value="60"></i><b>(60)</b>

// end::replicator-simple[]



import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    // tag::xctListener-start-func[]
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
    // tag::xctListener-start[]
    // tag::xctListener-config[]
    //  ... fragment preceded by other user code, including
    //  ... Couchbase Lite Database initialization that returns `thisDB`

    guard let db = thisDB else {
      throw print("DatabaseNotInitialized")
      // ... take appropriate actions
    }
    var listener: URLEndpointListener?
    let config = URLEndpointListenerConfiguration.init(database: db)
    config.port = tls ? wssPort : wsPort
    config.disableTLS = !tls
    config.authenticator = auth
    self.listener = URLEndpointListener.init(config: config)
//  ... fragment followed by other user code
    // end::xctListener-config[]

        // Start:
        try self.listener!.start()
    // end::xctListener-start[]

        return self.listener!
    }
    // end::xctListener-start-func[]

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
    // tag::xctListener-stop-func[]
    var listener: URLEndpointListener?
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
    // end::xctListener-stop-func[]
        }
    }

    func cleanUpIdentities() throws {
// tag::xctListener-delete-anon-ids[]
        try URLEndpointListener.deleteAnonymousIdentities()
// end::xctListener-delete-anon-ids[]
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// tag::xctListener-auth-tls-tlsidentity-anon[]
        // Anonymous Identity:

        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// end::xctListener-auth-tls-tlsidentity-anon[]

// tag::xctListener-auth-tls-tlsidentity-ca[]
        // User Identity:
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        var(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
// end::xctListener-auth-tls-tlsidentity-ca[]
    }

    func testPasswordAuthenticator() throws {
// tag::xctListener-auth-basic-pwd-full[]
        // Listener:
// tag::xctListener-auth-basic-pwd[]
        let thisAuth = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: thisAuth)

        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull,    continuous: false,
                 auth: auth)
// end::xctListener-auth-basic-pwd[]

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)


        // Cleanup:
        try stopListen()
    }
// end::xctListener-auth-basic-pwd-full[]

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }

// tag::xctListener-auth-tls-CCA-Root-full[]
// tag::xctListener-auth-tls-CCA-Root[]
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)
// end::xctListener-auth-tls-CCA-Root[]

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
// end::xctListener-auth-tls-CCA-Root-full[]
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }
// tag::xctListener-auth-tls-self-signed-full[]
// tag::xctListener-auth-tls-self-signed[]
        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)


        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: true, serverCert: nil)
        }
// end::xctListener-auth-tls-self-signed[]
        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
// end::xctListener-auth-tls-self-signed-full[]
    }

// tag::xctListener-auth-tls-ca-cert-full[]
    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
// tag::xctListener-auth-tls-ca-cert[]
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: serverCert)
        }
// end::xctListener-auth-tls-ca-cert[]

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
// tag::xctListener-status-check-full[]
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: false, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }
// end::xctListener-status-check-full[]

}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}
// end::start-replication[]

// tag::xctListener-auth-password-basic[]
listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
  (username, password) -&gt; Bool in
    (["password" : password, "name":username])
    if (self._allowListedUsers.contains(["password" : password, "name":username])) {
        return true
    }
    return false
}
// end::xctListener-auth-password-basic[]

// tag::xctListener-auth-cert-roots[]
let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
let listener = try listen(tls: true, auth: listenerAuth)// end::xctListener-auth-cert-roots[]

// tag::xctListener-auth-cert-auth[]
let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
    XCTAssertEqual(certs.count, 1)
    var commongName: CFString?
    let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
    XCTAssertEqual(status, errSecSuccess)
    XCTAssertNotNil(commongName)
    XCTAssertEqual((commongName! as String), "daniel")
    return true
}
// end::xctListener-auth-cert-auth[]

// tag::xctListener-config-basic-auth[]
let listenerConfig = URLEndpointListenerConfiguration(database: db)
listenerConfig.disableTLS  = true // Use with anonymous self signed cert
listenerConfig.enableDeltaSync = true
listenerConfig.tlsIdentity = nil

listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
    if (self._whitelistedUsers.contains(["password" : validPassword, "name":validUser])) {
        return true
    }
    return false
        }

_thisListener = URLEndpointListener(config: listenerConfig)
// end::xctListener-config-basic-auth[]





// tag::replication-start-func[]
    func startP2PReplicationWithUserDatabaseToRemotePeer(_ peer:PeerHost, handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void) throws{
        print("\(#function) with ws://\(peer)/\(kUserDBName)")
        guard let userDb = thisDB else {
          throw print("DatabaseNotInitialized")
          // ... take appropriate actions
        }
        guard let user = self.currentUserCredentials?.user, let password = self.currentUserCredentials?.password else {
          throw print("UserCredentialsNotProvided")
          // ... take appropriate actions
        }

// tag::replicator-start-func-config-init[]
        var replicatorForUserDb = _replicatorsToPeers[peer]

        if replicatorForUserDb == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(kUserDBName)") else {
                throw print("URLInvalid")
                // ... take appropriate actions
            }


            let config = ReplicatorConfiguration.init(database: userDb, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>
// end::replicator-start-func-config-init[]

// tag::replicator-start-func-config-more[]

            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>

// end::replicator-start-func-config-more[]

// tag::replicator-start-func-config-auth[]

            config.acceptOnlySelfSignedServerCertificate = true
            let authenticator = BasicAuthenticator(username: validUser, password: validPassword)
            config.authenticator = authenticator
// end::replicator-start-func-config-auth[]

// tag::replicator-start-func-repl-init[]
replicatorForUserDb = Replicator.init(config: config)
_replicatorsToPeers[peer] = replicatorForUserDb
// end::replicator-start-func-repl-init[]
          }


// tag::replicator-start-func-repl-start[]
if let pushPullReplListenerForUserDb = registerForEventsForReplicator(replicatorForUserDb,handler:handler) {
    _replicatorListenersToPeers[peer] = pushPullReplListenerForUserDb

}
replicatorForUserDb?.start()
handler(PeerConnectionStatus.Connecting)
// end::replicator-start-func-repl-start[]

      }
// end::replication-start-func[]


// tag::replicator-register-for-events[]
fileprivate func registerForEventsForReplicator(_ replicator:Replicator?,
  handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void )-&gt;ListenerToken? {
    let pushPullReplListenerForUserDb = replicator?.addChangeListener({ (change) in

      let s = change.status
      if s.error != nil {
          handler(PeerConnectionStatus.Error)
          return
      }

      switch s.activity {
      case .connecting:
          print("Replicator Connecting to Peer")
          handler(PeerConnectionStatus.Connecting)
      case .idle:
          print("Replicator in Idle state")
          handler(PeerConnectionStatus.Connected)
      case .busy:
          print("Replicator in busy state")
          handler(PeerConnectionStatus.Busy)
      case .offline:
          print("Replicator in offline state")
      case .stopped:
          print("Completed syncing documents")
          handler(PeerConnectionStatus.Error)

      }

      if s.progress.completed == s.progress.total {
          print("All documents synced")
      }
      else {
          print("Documents \(s.progress.total - s.progress.completed) still pending sync")
      }
  })
  return pushPullReplListenerForUserDb
// end::replicator-register-for-events[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  fileprivate var _allowlistedUsers:[[String:String]] = []
  // tag::listener-initialize[]
  fileprivate var _thisListener:URLEndpointListener?
  fileprivate var thisDB:Database?

    // tag::listener-config-db[]
    let listenerConfig =
      URLEndpointListenerConfiguration(database: thisDB!) <i class="conum" data-value="61"></i><b>(61)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    /* optionally */ let wsPort: UInt16 = 55991
    /* optionally */ let wssPort: UInt16 = 55990
    listenerConfig.port =  wssPort <i class="conum" data-value="62"></i><b>(62)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    listenerConfig.networkInterface = "10.1.1.10"  <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    listenerConfig.enableDeltaSync = true <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-tls-enable[]
     // tag::listener-config-tls-id-anon[]
    // Set the credentials the server presents the client
    // Use an anonymous self-signed cert
    listenerConfig.tlsIdentity = nil <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure how the client is to be authenticated
    // Here, use Basic Authentication
    listenerConfig.authenticator =
      ListenerPasswordAuthenticator(authenticator: {
        (validUser, validPassword) -&gt; Bool in
          if (self._allowlistedUsers.contains {
                $0 == validPassword &amp;&amp; $1 == validUser
              }) {
              return true
              }
            return false
          }) <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-client-auth-pwd[]

    // tag::listener-start[]
    // Initialize the listener
    _thisListener = URLEndpointListener(config: listenerConfig) <i class="conum" data-value="68"></i><b>(68)</b>
    guard let thisListener = _thisListener else {
      throw ListenerError.NotInitialized
      // ... take appropriate actions
    }
    // Start the listener
    try thisListener.start() <i class="conum" data-value="69"></i><b>(69)</b>

    // end::listener-start[]
// end::listener-initialize[]
  }
}


// BEGIN Additonal listener options



// tag::listener-get-network-interfaces[]
import SystemConfiguration
// . . .

  #if os(macOS)
  for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
      // do something with this `interface`
  }
  #endif
// . . .

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
let config =
  URLEndpointListenerConfiguration(database: self.oDB)
let listener = URLEndpointListener(config: config)
try listener.start()

print("urls: \(listener.urls)")

// end::listener-get-url-list[]


    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-full-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="70"></i><b>(70)</b>

    // end::listener-config-tls-full-enable[]
    // tag::listener-config-tls-disable[]
    listenerConfig.disableTLS  = true <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    guard let pathToCert =
      Bundle.main.path(forResource: "cert", ofType: "p12")
    else { /* process error */ return }

    guard let localCertificate =
      try? NSData(contentsOfFile: pathToCert) as Data
    else { /* process error */ return } <i class="conum" data-value="72"></i><b>(72)</b>

    let thisIdentity =
      try TLSIdentity.importIdentity(withData: localCertificate,
                                    password: "123",
                                    label: thisSecId) <i class="conum" data-value="73"></i><b>(73)</b>

    // end::listener-config-tls-id-caCert[]
    // tag::listener-config-tls-id-SelfSigned[]
    let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="74"></i><b>(74)</b>

    let thisIdentity =
      try TLSIdentity.createIdentity(forServer: true, /* isServer */
            attributes: attrs,
            expiration: Date().addingTimeInterval(86400),
            label: "Server-Cert-Label") <i class="conum" data-value="75"></i><b>(75)</b>

    // end::listener-config-tls-id-SelfSigned[]
    // tag::listener-config-tls-id-full-set[]
    // Set the credentials the server presents the client
    listenerConfig.tlsIdentity = thisIdentity    <i class="conum" data-value="76"></i><b>(76)</b>

    // end::listener-config-tls-id-full-set[]
    // end::listener-config-tls-id-full[]
    // tag::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-root[]
    // Authenticate using Cert Authority

    // cert is a pre-populated object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="77"></i><b>(77)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="78"></i><b>(78)</b> <i class="conum" data-value="79"></i><b>(79)</b>

    // end::listener-config-client-auth-root[]
    // end::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-lambda[]
    // tag::listener-config-client-auth-self-signed[]
    // Authenticate self-signed cert using application logic

    // cert is a user-supplied object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="80"></i><b>(80)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init { <i class="conum" data-value="81"></i><b>(81)</b>
      (certs) -&gt; Bool in
        var certs:SecCertificate
        var certCommonName:CFString?
        let status=SecCertificateCopyCommonName(certs[0], &amp;certCommonName)
        if (self._allowedCommonNames.contains(["name": certCommonName! as String])) {
            return true
        }
        return false
    } <i class="conum" data-value="82"></i><b>(82)</b>

    // end::listener-config-client-auth-self-signed[]
    // end::listener-config-client-auth-lambda[]
// END Additonal listener options





// tag::old-listener-config-tls-id-nil[]
listenerConfig.tlsIdentity = nil

// end::old-listener-config-tls-id-nil[]
// tag::old-listener-config-delta-sync[]
listenerConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]
// tag::listener-status-check[]
let totalConnections = thisListener.status.connectionCount
let activeConnections = thisListener.status.activeConnectionCount

// end::listener-status-check[]
// tag::listener-stop[]
        thisListener.stop()

// end::listener-stop[]
// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
// tag::old-listener-config-client-auth-self-signed[]
listenerConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}
// end::old-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
config.port = tls ? wssPort : wsPort
config.disableTLS = !tls
config.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // tag::p2p-act-rep-func[]
    let validUser = "syncuser"
    let validPassword = "sync9455"
    let cert:SecCertificate?
    let passivePeerEndpoint = "10.1.1.12:8920"
    let passivePeerPort = "8920"
    let passiveDbName = "userdb"
    var actDb:Database?
    var thisReplicator:Replicator?
    var replicatorListener:ListenerToken?


    // tag::p2p-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="83"></i><b>(83)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    config.replicatorType = .pushAndPull

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = false; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    config.continuous = true

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="85"></i><b>(85)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="86"></i><b>(86)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: "Our Username", password: "Our Password")
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    config.conflictResolver = ( /* define resolver function */); <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-conflict[]
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    thisReplicator = Replicator.init( config: config) <i class="conum" data-value="88"></i><b>(88)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // Optionally add a change listener
    // Retain token for use in deletion
    let pushPullReplListener:ListenerToken? = thisReplicator?.addChangeListener({ (change) in <i class="conum" data-value="89"></i><b>(89)</b>
      if change.status.activity == .stopped {
          print("Replication stopped")
      }
      else {
      // tag::p2p-act-rep-status[]
          print("Replicator is currently ", thisReplicator?.status.activity)
      }
    })

    // end::p2p-act-rep-status[]
    // end::p2p-act-rep-add-change-listener[]

    // tag::p2p-act-rep-start[]
        // Run the replicator using the config settings
        thisReplicator?.start()  <i class="conum" data-value="90"></i><b>(90)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]


    // end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener

    thisReplicator?.removeChangeListener(withToken: pushPullReplListener)
    // Stop the replicator
    thisReplicator?.stop()

// end::p2p-act-rep-stop[]
}


// BEGIN Additional p2p-avt-rep options
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="91"></i><b>(91)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    config.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="93"></i><b>(93)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: validUser, password: validPassword)
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-tlsid-tlsidentity-with-label[]
      // Check if Id exists in keychain and if so, use that Id
      if let thisIdentity =
        (try? TLSIdentity.identity(withLabel: "doco-sync-server")) ?? nil { <i class="conum" data-value="94"></i><b>(94)</b>
          print("An identity with label : doco-sync-server already exists in keychain")
          thisAuthenticator = ClientCertificateAuthenticator(identity: thisIdentity)  <i class="conum" data-value="95"></i><b>(95)</b>
          config.authenticator = thisAuthenticator
          }

      // end::p2p-tlsid-check-keychain[]
    // end::p2p-tlsid-tlsidentity-with-label[]
// END Additional p2p-avt-rep options




// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
    // tag::old-p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-tlsid-check-keychain[]
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        do {
            if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
                print("An identity with label : doco-sync-server already exists in keychain")
                return thisIdentity
                }
        } catch
          {return nil}
        // end::p2p-tlsid-check-keychain[]
        thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
        config.thisAuthenticator
    // end::old-p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert

// tag::p2p-tlsid-delete-id-from-keychain[]

try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);

// end::p2p-tlsid-delete-id-from-keychain[]


// end::p2p-tlsid-manage-func[]
// tag::old-p2p-act-rep-config-self-cert[]
// acceptOnlySelfSignedServerCertificate = true -- accept Slf-Signed Certs
config.disableTLS = false
config.acceptOnlySelfSignedServerCertificate = true

// end::old-p2p-act-rep-config-self-cert[]

// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]

  // Get bundled resource and read into localcert
  guard let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer")
    else { /* process error */ }
  guard let localCertificate:NSData =
               NSData(contentsOfFile: pathToCert)
    else { /* process error */ }

  // Create certificate
  // using its DER representation as a CFData
  guard let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
    else { /* process error */ }

  // Add `pinnedCert` and `acceptOnlySelfSignedServerCertificate=false` to `ReplicatorConfiguration`
  config.acceptOnlySelfSignedServerCertificate = false
  config.pinnedServerCertificate = pinnedCert
  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}

    // optionally  listenerConfig.tlsIdentity = TLSIdentity(withIdentity:serverSelfCert-id)


        // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="96"></i><b>(96)</b>

    // end::old-listener-config-client-root-ca[]

    // For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
class MyClass {
    var database: Database?
    var replicator: Replicator? <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database!, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator?.start()
    }
}

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]

&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

    // tag::sgw-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="97"></i><b>(97)</b>

    // end::sgw-act-rep-initialize[]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Store imported identity in keychain</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML


class SampleCodeTest {

    var database: Database!
    var db: Database!

    var replicator: Replicator!

    // MARK: Database

    func dontTestNewDatabase() throws {
        // tag::new-database[]
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }
        // end::new-database[]

        // tag::close-database[]
        do {
            try userDb.close()
        }

        // end::close-database[]


    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        // tag::database-encryption[]
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        // end::database-encryption[]
    }
    #endif

    func dontTestLogging() throws {
        // tag::logging[]
        Database.setLogLevel(.verbose, domain: .replicator)
        Database.setLogLevel(.verbose, domain: .query)
        // end::logging[]
    }

    func dontTestConsoleLogging() throws {
        // tag::console-logging[]
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>

        // end::console-logging[]
        // tag::console-logging-db[]

        Database.log.console.domains = .database

        // end::console-logging-db[]
    }

    func dontTestFileLogging() throws {
        // tag::file-logging[]
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
        // end::file-logging[]
    }

    func dontTestEnableCustomLogging() throws {
        // tag::set-custom-logging[]
        Database.log.custom = LogTestLogger(.warning) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    func dontTestLoadingPrebuilt() throws {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
        // end::prebuilt-database[]
    }

    // MARK: Document

    func dontTestInitializer() throws {
        database = self.db

        // tag::initializer[]
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
        // end::initializer[]
    }

    func dontTestMutability() throws {
        database = self.db

        // tag::update-document[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
        // end::update-document[]
    }

    func dontTestTypedAcessors() throws {
        let newTask = Document()

        // tag::date-getter[]
        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")
        // end::date-getter[]

        // tag::to-dictionary[]
        newTask.toDictionary() <i class="conum" data-value="9"></i><b>(9)</b>

        // end::to-dictionary[]

        // tag::to-json[]
        newTask.toJSON() <i class="conum" data-value="10"></i><b>(10)</b>

        // end::to-json[]

        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        // tag::batch[]
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::batch[]
    }

    func dontTestChangeListener() throws {
        database = self.db

        // tag::document-listener[]
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
        // end::document-listener[]
    }

    func dontTestDocumentExpiration() throws {
        database = self.db

        // tag::document-expiration[]
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try db.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        // end::document-expiration[]

    }

    func dontTestBlob() throws {
    #if TARGET_OS_IPHONE
        database = self.db
        let newTask = MutableDocument()
        var image: UIImage!

        // tag::blob[]
        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)!

        let blob = Blob(contentType: "image/jpeg", data: imageData)
        newTask.setBlob(blob, forKey: "avatar")
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }
        // end::blob[]

        print("\(image)")
    #endif
    }

    func dontTest1xAttachment() throws {
        database = self.db
        let document = MutableDocument()

        // tag::1x-attachment[]
        let attachments = document.dictionary(forKey: "_attachments")
        let avatar = attachments?.blob(forKey: "avatar")
        let content = avatar?.content
        // end::1x-attachment[]

        print("\(content!)")
    }

    // MARK: Query

    func dontTestIndexing() throws {
        database = self.db

        // tag::query-index[]
        let index = IndexBuilder.valueIndex(items:
            ValueIndexItem.expression(Expression.property("type")),
            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
        // end::query-index[]
    }

    func dontTestSelectMeta() throws {
        database = self.db

        // tag::query-select-meta[]
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-meta[]
    }


    func dontTestSelectProps() throws {
        database = self.db

        // tag::query-select-props[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-props[]
    }

    func dontTestSelectAll() throws {
        database = self.db

        // tag::query-select-all[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
        // end::query-select-all[]

        // tag::live-query[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="11"></i><b>(11)</b>
            for result in change.results! {
                print(result.keys)
                /* Update UI */
            }
        }

        // Start live query.
        query.execute(); <i class="conum" data-value="12"></i><b>(12)</b>
        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(withToken: token) <i class="conum" data-value="13"></i><b>(13)</b>

        // end::stop-live-query[]

        print("\(query)")
    }

    func dontTestWhere() throws {
        database = self.db

        // tag::query-where[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
        // end::query-where[]
    }

    func dontTestQueryDeletedDocuments() throws {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(Meta.isDeleted)
        // end::query-deleted-documents[]
    }

    func dontTestCollectionOperatorContains() throws {
        database = self.db

        // tag::query-collection-operator-contains[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                .and(ArrayFunction.contains(Expression.property("public_likes"), value: Expression.string("Armani Langworth")))
        )

        do {
             for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
        // end::query-collection-operator-contains[]
    }

    func dontTestCollectionOperatorIn() throws {
        database = self.db

        // tag::query-collection-operator-in[]
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
            ]

        QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))
        // end::query-collection-operator-in[]
    }


    func dontTestLikeOperator() throws {
        database = self.db

        // tag::query-like-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
        // end::query-like-operator[]
    }

    func dontTestWildCardMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-character-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-character-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        database = self.db

        // tag::query-regex-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="14"></i><b>(14)</b>
            )
            .limit(Expression.int(10))
        // end::query-regex-operator[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        database = self.db

        // tag::query-join[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX")))
        )
        // end::query-join[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        database = self.db

        // tag::query-groupby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
        )

        do {
            for result in try query.execute() {
                print("There are \(result.int(forKey: "$1")) airports on the \(result.string(forKey: "tz")!) timezone located in \(result.string(forKey: "country")!) and above 300 ft")
            }
        }
        // end::query-groupby[]
    }

    func dontTestOrderBy() throws {
        database = self.db

        // tag::query-orderby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))
        // end::query-orderby[]

        print("\(query)")
    }

    func dontTestExplain() throws {
      database = self.db
      // tag::query-explain-all[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("university")))
          .groupBy(Expression.property("country"))
          .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="15"></i><b>(15)</b>

      print(try thisQuery.explain()) <i class="conum" data-value="16"></i><b>(16)</b>
      // end::query-explain-all[]

      // tag::query-explain-like[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="17"></i><b>(17)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain())

      // end::query-explain-like[]

      // tag::query-explain-nopfx[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="18"></i><b>(18)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain());

      // end::query-explain-nopfx[]

      // tag::query-explain-function[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Function.lower(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="19"></i><b>(19)</b>

      print(try thisQuery.explain());

      // end::query-explain-function[]

      // tag::query-explain-nofunction[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="20"></i><b>(20)</b>

      print(try thisQuery.explain());

      // end::query-explain-nofunction[]

    }


    func dontTestCreateFullTextIndex() throws {
        database = self.db

        // tag::fts-index[]
        // Insert documents
        let tasks = ["buy groceries", "play chess", "book travels", "buy museum tickets"]
        for task in tasks {
            let doc = MutableDocument()
            doc.setString("task", forKey: "type")
            doc.setString(task, forKey: "name")
            try database.saveDocument(doc)
        }

        // Create index
        do {
            let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("name")).ignoreAccents(false)
            try database.createIndex(index, withName: "nameFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-index[]
    }

    func dontTestFullTextSearch() throws {
        database = self.db

        // tag::fts-query[]
        let whereClause = FullTextExpression.index("nameFTSIndex").match("'buy'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)

        do {
            for result in try query.execute() {
                print("document id \(result.string(at: 0)!)")
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-query[]
    }


    func dontTestToJson-ArrayObject() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-array[]




        // end::tojson-array[]
    }



    func dontTestGetBlobAsJSONstring() throws {
        db = self.db

        // tag::tojson-getblobasstring[]

        let thisdoc = db.document(withID: "thisdoc-id")!.toDictionary();
        let thisBlob =  thisdoc["avatar"] as! Blob

        if Blob.isBlob(properties: thisBlob.properties) {
          var blobtype = thisBlob.properties["content_type"]
          var bloblength = thisBlob.properties["length"]
        }
        // end::tojson-getblobasstring[]
    }


    func dontTestToJson-Dictionary() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-dictionary[]


        // end::tojson-dictionary[]
    }


    func dontTestToJson-Document() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-document[]


        // end::tojson-document[]
    }


    func dontTestToJson-Result() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-result[]
        let ourJSON =  "{{\"id\": \"hotel-ted\"},{\"name\": \"Hotel Ted\"},{\"city\": \"Paris\"},{\"type\": \"hotel\"}}"
        let ourDoc = try MutableDocument(id: "doc", json: ourJSON)
        try database.saveDocument(ourDoc)

        let query = QueryBuilder
                      .select(SelectResult.all)
                      .from(DataSource.database(database)))
                      .where(Expression.property("id").equalTo(Expression.string("hotel-ted"))))

        for (_,result) in try! query.execute().enumerated() {
          if let thisJSON = result.toJSON().toJSONObj() as? [String:Any] {
              // ... process document properties as required e.g.
              let docid = thisJSON["id"]
              let name = thisJSON["name"]
              let city = thisJSON["city"]
              let type = thisJSON["type"]
              //
          }

        // end::tojson-result[]
    }







    // MARK: Replication

    /* The `tag::replication[]` example is inlined in swift.adoc */

    func dontTestEnableReplicatorLogging() throws {
        // tag::replication-logging[]
        // Replicator
        Database.setLogLevel(.verbose, domain: .replicator)
        // Network
        Database.setLogLevel(.verbose, domain: .network)
        // end::replication-logging[]
    }

    func dontTestReplicationBasicAuthentication() throws {
        // tag::basic-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::basic-authentication[]
    }

    func dontTestReplicationSessionAuthentication() throws {
        // tag::session-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::session-authentication[]
    }

    func dontTestReplicatorStatus() throws {
        // tag::replication-status[]
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
        // end::replication-status[]
    }

//  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {
      // tag::replication-pendingdocuments[]

      let url = URL(string: "ws://localhost:4984/mydatabase")!
      let target = URLEndpoint(url: url)

      let config = ReplicatorConfiguration(database: database, target: target)
      config.replicatorType = .push

      // tag::replication-push-pendingdocumentids[]
      self.replicator = Replicator(config: config)
      let mydocids:Set = self.replicator.pendingDocumentIds() <i class="conum" data-value="21"></i><b>(21)</b>

      // end::replication-push-pendingdocumentids[]
      if(!mydocids.isEmpty) {
        print("There are \(mydocids.count) documents pending")

        self.replicator.addChangeListener { (change) in
          print("Replicator activity level is \(change.status.activity.toString())")
          // iterate and report-on previously
          // retrieved pending docids 'list'
          for thisId in mydocids.sorted() {
            // tag::replication-push-isdocumentpending[]
            if(!self.replicator.isDocumentPending(thisid)) { <i class="conum" data-value="22"></i><b>(22)</b>
              print("Doc ID \(thisId) now pushed")
            }
            // end::replication-push-isdocumentpending[]
          }
        }

        self.replicator.start()
        // end::replication-pendingdocuments[]
    }

//  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        // tag::add-document-replication-listener[]
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        self.replicator.removeChangeListener(withToken: token)
        // end::remove-document-replication-listener[]
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-custom-header[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
        // end::replication-custom-header[]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-channels[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
        // end::replication-channels[]
    }

    func dontTestHandlingReplicationError() throws {
        // tag::replication-error-handling[]
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
        // end::replication-error-handling[]
    }

    func dontTestReplicationResetCheckpoint() throws {
        // tag::replication-reset-checkpoint[]
        if (resetCheckpointRequired_Example) {
          self.replicator.start(reset: true)  <i class="conum" data-value="23"></i><b>(23)</b>
        else
          self.replicator.start()
        }

        // end::replication-reset-checkpoint[]
    }

    func dontTestReplicationPushFilter() throws {
        // tag::replication-push-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-push-filter[]
    }

    func dontTestReplicationPullFilter() throws {
        // tag::replication-pull-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-pull-filter[]
    }

//  Added 2/Feb/21 - Ian Bridge
//  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        // tag::replication-retry-config[]
        let target =
          URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        let config =  ReplicatorConfiguration(database: database, target: targetDatabase)
        config.type = .pushAndPull
        config.continuous = true
        // tag::replication-set-heartbeat[]
        config.heartbeat = 150 <i class="conum" data-value="24"></i><b>(24)</b>

        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
        config.maxattempts = 20 <i class="conum" data-value="25"></i><b>(25)</b>

        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
        config.maxattemptwaittime = 600 <i class="conum" data-value="26"></i><b>(26)</b>
        repl = Replicator(config: config)

        // end::replication-set-maxattemptwaittime[]

        // end::replication-retry-config[]
    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Swift Community. */
        // tag::database-replica[]
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::database-replica[]

        try database2.delete()
    }
    #endif

    func dontTestCertificatePinning() throws {

        // tag::certificate-pinning[]
        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate
        // end::certificate-pinning[]

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // tag::getting-started[]
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        let replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
        // end::getting-started[]
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::register-model[]
        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")
        // end::register-model[]

        // tag::predictive-query-value-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel(withName: "ImageClassifier")
        // end::unregister-model[]
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query-predictive-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
        // end::predictive-query-predictive-index[]
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(
                    prediction.property("probablity")
                        .greaterThanOrEqualTo(Expression.double(0.8))
                )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
        // end::predictive-query[]
    }

    func dontTestCoreMLPredictiveModel() throws {
        // tag::coreml-predictive-model[]
        // Load MLModel from `ImageClassifier.mlmodel`
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
        // end::coreml-predictive-model[]
    }

    func dontTestReplicatorConflictResolver() throws {
        // tag::replication-conflict-resolver[]
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-conflict-resolver[]
    }

    func dontTestSaveWithConflictHandler() throws {
        // tag::update-document-with-conflict-handler[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, _) in first })
            new.setData(result)
            return true
        })
        // end::update-document-with-conflict-handler[]

    }

    // helper
    func isValidCredentials(_ u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        let db: Database!

        // tag::init-urllistener[]
        let config = URLEndpointListenerConfiguration(database: db)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator:
            { (username, password) -&gt; Bool in
                return self.isValidCredentials(username, password: password)
        })

        // end::init-urllistener[]
    }

    func dontTestListenerStart() throws {
        let listener: URLEndpointListener

        // tag::start-urllistener[]
        try listener.start()

        // end::start-urllistener[]
    }

    func dontTestListenerStop() throws {
        let listener: URLEndpointListener
        // tag::stop-urllistener[]
        listener.stop()

        // end::stop-urllistener[]
    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        // tag::create-self-signed-cert[]
        // tag::listener-config-tls-id-SelfSigned[]
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
          try TLSIdentity.createIdentity(forServer: true,
                attributes: attrs,
                expiration: Date().addingTimeInterval(86400),
                label: "Server-Cert-Label")
        // end::listener-config-tls-id-SelfSigned[]
        // end::create-self-signed-cert[]
        print("\(identity.expiration)") // to avoid warning
    }
}


// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] {}
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // `myMLModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}
// end::predictive-model[]

// tag::custom-logging[]
fileprivate class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }

}
// end::custom-logging[]

// tag::local-win-conflict-resolver[]
class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}
// end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        // tag::message-endpoint[]
        let database = try Database(name: "dbname")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /* implements MessageEndpointConnection */
        return connection
    }
    // end::create-connection[]

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::active-peer-open[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::active-peer-send[]

    func receive(data: Data) {
        // tag::active-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::active-peer-receive[]
    }

    // tag::active-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::active-peer-close[]

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        // tag::listener[]
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
        // end::listener[]
    }

    func stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    func acceptConnection() {
        // tag::advertizer-accept[]
        let connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection: connection)
        // end::advertizer-accept[]
    }

    func disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::passive-peer-send[]

    func receive(data: Data) {
        // tag::passive-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::passive-peer-receive[]
    }

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::passive-peer-close[]
}


// BEGIN URLENDPOINTLISTENER SAMPLES

//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
        let config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.port = tls ? wssPort : wsPort
        config.disableTLS = !tls
        config.authenticator = auth

        return try listen(config: config)
    }

    @discardableResult
    func listen(config: URLEndpointListenerConfiguration) throws -&gt; URLEndpointListener {
        self.listener = URLEndpointListener.init(config: config)

        // Start:
        try self.listener!.start()

        return self.listener!
    }

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
        }
    }

    func cleanUpIdentities() throws {
        self.ignoreException {
            try URLEndpointListener.deleteAnonymousIdentities()
        }
    }

    func replicator(db: Database, continuous: Bool, target: Endpoint, serverCert: SecCertificate?) -&gt; Replicator {
        let config = ReplicatorConfiguration(database: db, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = continuous
        config.pinnedServerCertificate = serverCert
        return Replicator(config: config)
    }

    /// Two replicators, replicates docs to the self.listener; validates connection status
    func validateMultipleReplicationsTo() throws {
        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")
        let count = self.listener!.config.database.count

        // open DBs
        try deleteDB(name: "db1")
        try deleteDB(name: "db2")
        let db1 = try openDB(name: "db1")
        let db2 = try openDB(name: "db2")

        // For keeping the replication long enough to validate connection status, we will use blob
        let imageData = try dataFromResource(name: "image", ofType: "jpg")

        // DB#1
        let doc1 = createDocument()
        let blob1 = Blob(contentType: "image/jpg", data: imageData)
        doc1.setBlob(blob1, forKey: "blob")
        try db1.saveDocument(doc1)

        // DB#2
        let doc2 = createDocument()
        let blob2 = Blob(contentType: "image/jpg", data: imageData)
        doc2.setBlob(blob2, forKey: "blob")
        try db2.saveDocument(doc2)

        let repl1 = replicator(db: db1,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])
        let repl2 = replicator(db: db2,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        var maxConnectionCount: UInt64 = 0, maxActiveCount: UInt64 = 0
        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .busy {
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount);
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount);
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db1" {
                    exp1.fulfill()
                } else {
                    exp2.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        // check both replicators access listener at same time
        XCTAssertEqual(maxConnectionCount, 2);
        XCTAssertEqual(maxActiveCount, 2);

        // all data are transferred to/from
        XCTAssertEqual(self.listener!.config.database.count, count + 2);
        XCTAssertEqual(db1.count, count + 1/* db2 doc*/);
        XCTAssertEqual(db2.count, count + 1/* db1 doc*/);

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db1.close()
        try db2.close()
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // Anonymous Identity:
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // User Identity:
// tag::p2psync-act-tlsid-create[]
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
// end::p2psync-act-tlsid-create[]
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
    }

    func testPasswordAuthenticator() throws {
        // Listener:
        let listenerAuth = ListenerPasswordAuthenticator.init {
            (username, password) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: listenerAuth)

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Success:
        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth)

        // Cleanup:
        try stopListen()
    }

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)

// tag::p2psync-act-tlsid-delete[]
        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
// end::p2psync-act-tlsid-delete[]

        // Create client identity:
// tag::p2psync-act-tlsid-import[]
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)
// end::p2psync-act-tlsid-import[]

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .selfSignedCert, serverCert: nil)
        }

        // Cleanup
        try stopListen()
    }

    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: serverCert)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: .caCert, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }

    func testMultipleListenersOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        let listener1 = URLEndpointListener(config: config)
        let listener2 = URLEndpointListener(config: config)

        try listener1.start()
        try listener2.start()

        try generateDocument(withID: "doc-1")
        self.run(target: listener1.localURLEndpoint,
                 type: .pushAndPull,
                 continuous: false,
                 auth: nil,
                 serverCert: listener1.tlsIdentity!.certs[0])

        // since listener1 and listener2 are using same certificates, one listener only needs stop.
        listener2.stop()
        try stopListener(listener: listener1)
        XCTAssertEqual(self.oDB.count, 1)
    }

    func testReplicatorAndListenerOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")

        // listener
        let doc = createDocument()
        try self.oDB.saveDocument(doc)
        try listen()

        // Replicator#1 (otherDB -&gt; DB#1)
        let doc1 = createDocument()
        try self.db.saveDocument(doc1)
        let target = DatabaseEndpoint(database: self.db)
        let repl1 = replicator(db: self.oDB, continuous: true, target: target, serverCert: nil)

        // Replicator#2 (DB#2 -&gt; Listener(otherDB))
        try deleteDB(name: "db2")
        let db2 = try openDB(name: "db2")
        let doc2 = createDocument()
        try db2.saveDocument(doc2)
        let repl2 = replicator(db: db2,
                               continuous: true,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .idle &amp;&amp;
                change.status.progress.completed == change.status.progress.total {
                if self.oDB.count == 3 &amp;&amp; self.db.count == 3 &amp;&amp; db2.count == 3 {
                    change.replicator.stop()
                }
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db2" {
                    exp2.fulfill()
                } else {
                    exp1.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        XCTAssertEqual(self.oDB.count, 3)
        XCTAssertEqual(self.db.count, 3)
        XCTAssertEqual(db2.count, 3)

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db2.close()
        try stopListen()
    }

    func testCloseWithActiveListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        // Close database should also stop the listener:
        try self.oDB.close()

        XCTAssertNil(self.listener!.port)
        XCTAssertNil(self.listener!.urls)

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-1008
    func _testEmptyNetworkInterface() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        for (i, url) in self.listener!.urls!.enumerated() {
            // separate db instance!
            let db = try Database(name: "db-\(i)")
            let doc = createDocument()
            doc.setString(url.absoluteString, forKey: "url")
            try db.saveDocument(doc)

            // separate replicator instance
            let target = URLEndpoint(url: url)
            let rConfig = ReplicatorConfiguration(database: db, target: target)
            rConfig.pinnedServerCertificate = self.listener?.tlsIdentity!.certs[0]
            run(config: rConfig, expectedError: nil)

            // remove the db
            try db.delete()
        }

        XCTAssertEqual(self.oDB.count, UInt64(self.listener!.urls!.count))

        let q = QueryBuilder.select([SelectResult.all()]).from(DataSource.database(self.oDB))
        let rs = try q.execute()
        var result = [URL]()
        for res in rs.allResults() {
            let dict = res.dictionary(at: 0)
            result.append(URL(string: dict!.string(forKey: "url")!)!)
        }

        XCTAssertEqual(result, self.listener!.urls)
        try stopListen()

        // validate 0.0.0.0 meta-address should return same empty response.
        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.networkInterface = "0.0.0.0"
        try listen(config: config)
        XCTAssertEqual(self.listener!.urls!, result)
        try stopListen()
    }

    func testMultipleReplicatorsToListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        let doc = createDocument()
        doc.setString("Tiger", forKey: "species")
        try self.oDB.saveDocument(doc)

        try validateMultipleReplicationsTo()

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-954
    func _testReadOnlyListener() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.readOnly = true
        try listen(config: config)

        self.run(target: self.listener!.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, serverCert: self.listener!.tlsIdentity!.certs[0],
                 expectedError: CBLErrorHTTPForbidden)
    }
}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}

// END URLENDPOINTLISTENER SAMPLES


//
//  QueryResultSets.swift
//  sampleQueryResults
//
//  Created by Ian Bridge on 28/07/2021.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

//import CoreML


class Query {

    var this_hotel:Hotel = Hotel()

    let dbName = "hotel"
    //    let dbName = "hotel"
    var db = try! Database(name: "hotel")
    var hotels = [String:Any]()
    var thisDocsProperties = [String:Any]()
    var jsonbit = [String:Any]()

    func dontTestQueryAll() throws {





    //        seedHotel()

    // QUERY RESULT SET HANDLING EXAMPLES
    // tag::query-syntax-all[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database( db))

    // end::query-syntax-all[]

    // tag::query-access-all[]

        do {

            for row in try! listQuery.execute() {

                let thisDocsProps =
                    row.dictionary(at: 0)?.toDictionary() <i class="conum" data-value="27"></i><b>(27)</b>

                let docid = thisDocsProps!["id"] as! String

                let name = thisDocsProps!["name"] as! String

                let type = thisDocsProps!["type"] as! String

                let city = thisDocsProps!["city"] as! String

                let hotel = row.dictionary(at: 0)?.toDictionary()  <i class="conum" data-value="28"></i><b>(28)</b>
                let hotelId = hotel!["id"] as! String
                hotels[hotelId] = hotel
            } // end for

        } //end do-block

    // end::query-access-all[]

    // tag::query-access-json[]

    // In this example the Hotel class is defined using Codable
    //
    // class Hotel : Codable {
    //   var id : String = "undefined"
    //   var type : String = "hotel"
    //   var name : String = "undefined"
    //   var city : String = "undefined"
    //   var country : String = "undefined"
    //   var description : String? = ""
    //   var text : String? = ""
    //   ... other class content
    // }


        do {
            var results = try! listQuery.execute()
            for row in  results {

                // get the result into a JSON String
                let jsonString = row.toJSON() <i class="conum" data-value="29"></i><b>(29)</b>

                let thisJsonObj:Dictionary =
                    try! (JSONSerialization.jsonObject(
                            with: jsonString.data(using: .utf8)!,
                                                  options: .allowFragments)
                            as? [String: Any])! <i class="conum" data-value="30"></i><b>(30)</b>

                // Use Json Object to populate Native object
                // Use Codable class to unpack JSON data to native object
                let this_hotel:Hotel =
                    (try JSONDecoder().decode(
                        Hotel.self,
                        from: jsonString.data(using: .utf8)!
                        )
                    ) <i class="conum" data-value="31"></i><b>(31)</b>

                // ALTERNATIVELY unpack in steps
                this_hotel.id = thisJsonObj["id"] as! String
                this_hotel.name = thisJsonObj["name"] as! String
                this_hotel.type = thisJsonObj["type"] as! String
                this_hotel.city = thisJsonObj["city"] as! String
                hotels[this_hotel.id] = this_hotel


            } // end for

            // end::query-access-json[]

        } catch let err {
            print(err.localizedDescription)

        } // end do



    } // end func dontTestQueryAll



    func dontTestQueryProps () throws {
        // tag::query-syntax-props[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()
        var hotel:Hotel = Hotel.init()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
                    .from(DataSource.database(db))

        // end::query-syntax-props[]

        // tag::query-access-props[]
        for (_, result) in try! listQuery.execute().enumerated() {


            let thisDoc = result.toDictionary() as? [String:Any]  <i class="conum" data-value="32"></i><b>(32)</b>
                // Store dictionary data in hotel object and save in arry
            hotel.id = thisDoc!["id"] as! String
            hotel.name = thisDoc!["name"] as! String
            hotel.city = thisDoc!["city"] as! String
            hotel.type = thisDoc!["type"] as! String
            hotels[hotel.id] = hotel

            // Use result content directly
            let docid = result.string(forKey: "metaId")
            let hotelId = result.string(forKey: "id")
            let name = result.string(forKey: "name")
            let city = result.string(forKey: "city")
            let type = result.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: ", docid, hotelId,name, city, type)
          } // end for

// end::query-access-props[]
    }// end func

//
    func dontTestQueryCount () throws {

    // tag::query-syntax-count-only[]
        let db = try! Database(name: "hotel")
        do {
            let listQuery = QueryBuilder
                .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
                .from (DataSource.database(db)).groupBy(Expression.property("type"))

                // end::query-syntax-count-only[]


            // tag::query-access-count-only[]

            for result in try! listQuery.execute() {
                let dict = result.toDictionary() as? [String: Int]
                let thiscount = dict!["mycount"]! <i class="conum" data-value="33"></i><b>(33)</b>
                print("There are ", thiscount, " rows")

                // Alternatively
                print ( result["mycount"] )

            } // end for

        } // end do
    } // end function

// end::query-access-count-only[]

//
    func dontTestQueryId () throws {

        // tag::query-syntax-id[]
        let db = try! Database(name: "hotel")
        let listQuery = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
                    .from(DataSource.database(db))

        // end::query-syntax-id[]


        // tag::query-access-id[]
        for (_, result) in try! listQuery.execute().enumerated() {

            print(result.toDictionary())
            print("Document Id is -- ", result["metaId"].string!)

            let thisDocsId = result["metaId"].string! <i class="conum" data-value="34"></i><b>(34)</b>

            // Now you can get the document using the ID
            var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

            let hotelId = thisDoc["id"] as! String

            let name = thisDoc["name"] as! String

            let city = thisDoc["city"] as! String

            let type = thisDoc["type"] as! String

            // ... process document properties as required
            print("Result properties are: ", hotelId,name, city, type)


        } // end for

// end::query-access-id[]
    } // end function dontTestQueryId

//
    func query_pagination () throws {

        //tag::query-syntax-pagination[]
        let thisOffset = 0;
        let thisLimit = 20;
        //
        let listQuery = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(db))
                .limit(Expression.int(thisLimit),
                  offset: Expression.int(thisOffset))

        // end::query-syntax-pagination[]

    } // end function
//
//


    func seedHotel () {

        try! db.delete()

        db = try! Database(name: "hotel")

        let key = ["id","name","type","city", "country","description"]
        let val = [
                    ["1000","Hotel Ted","hotel","Paris", "France","Very good and central"],
                    ["1001","Hotel Fred","hotel","London", "England","Very good and central"],
                    ["1002","Hotel Du Ville","hotel","Casablanca", "Morocco","Very good and central"],
                    ["1003","Hotel Ouzo","hotel","Athens", "Greece","Very good and central"]
                ]
        let maxrecs=val.count-1
        for i in 0 ... maxrecs {

            let hotel:MutableDocument = MutableDocument(id: val[0][i])

            for x in 0 ... key.count-1 {
                hotel.setString(val[i][x], forKey: key[x])
            }

            try! db.saveDocument(hotel)


        }

    }

//
// N1QL QUERY EXAMPLES
//

    func dontTestQueryN1QL() throws {


    // tag::query-syntax-n1ql[]
        let db = try! Database(name: "hotel")

        let listQuery =  db.createQuery( query:
            "SELECT META().id AS thisId FROM _ WHERE type = 'hotel'" <i class="conum" data-value="35"></i><b>(35)</b>
        )

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QL


    func dontTestQueryN1QLparams() throws {

    // tag::query-syntax-n1ql-params[]
        let db = try! Database(name: "hotel")

        let listQuery =
            db.createQuery( query:
                   "SELECT META().id AS thisId FROM _ WHERE type = $type" <i class="conum" data-value="36"></i><b>(36)</b>
                )

        listQuery.parameters =
            Parameters().setString("hotel", forName: "type") <i class="conum" data-value="37"></i><b>(37)</b>

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql-params[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QLparams()


    func dontTestProcessResults(results: ResultSet) throws {
        // tag::query-access-n1ql[]
        // tag::query-process-results[]

        do {

            for row in results {

                print(row["thisId"].string!)

                let thisDocsId = row["thisId"].string!

                // Now you can get the document using the ID
                var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

                let hotelId = thisDoc["id"] as! String

                let name = thisDoc["name"] as! String

                let city = thisDoc["city"] as! String

                let type = thisDoc["type"] as! String

                // ... process document properties as required
                print("Result properties are: ", hotelId,name, city, type)

            } // end for
            // end::query-access-n1ql[]
            // end::query-process-results[]

        } //end do-block

    } // end dontTestProcessResults

} // end class






//  JSON API SNIPPETS


    func dontTestJSONdocument() {
        // tag::query-get-all[]
        let db = try! Database(name: "hotel")
        let dbnew = try! Database(name: "newhotels")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(db))


        for row in try! listQuery.execute() {
        // end::query-get-all[]

        // tag::tojson-document[]
            var thisId = row.string(forKey: "metaId")! as String

            var thisJSONstring = try! db.document(withID: thisId)!.toJSON() <i class="conum" data-value="38"></i><b>(38)</b>

            print("JSON String = ", thisJSONstring as! String)

            let hotelFromJSON:MutableDocument = <i class="conum" data-value="39"></i><b>(39)</b>
                    try! MutableDocument(id: thisId as? String, json: thisJSONstring)

            try! dbnew.saveDocument(hotelFromJSON)

            let newhotel = dbnew.document(withID: thisId)

            let keys = newhotel!.keys
            for key in keys { <i class="conum" data-value="40"></i><b>(40)</b>
                print(key, newhotel!.value(forKey: key) as! String)
            }

            // end::tojson-document[]

        /*
        // tag::tojson-document-output[]
             JSON String =  {"description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
             type hotel
             id 1000
             country France
             city Paris
             description Very good and central
             name Hotel Ted
        // end::tojson-document-output[]
         */
        } // end  query for loop


        // tag::tojson-array[]

        let thisJSONstring = """
            [{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
            \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
            {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
            \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
            \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]
            """
        let myArray:MutableArrayObject =
            try! MutableArrayObject.init(json: thisJSONstring) <i class="conum" data-value="41"></i><b>(41)</b>

        for i in 0...myArray.count-1 {

            print(i+1, myArray.dictionary(at: i)!.string(forKey: "name")!)

            var docid = myArray.dictionary(at: i)!.string(forKey: "id")

            var newdoc:MutableDocument = <i class="conum" data-value="42"></i><b>(42)</b>
                try! MutableDocument(id: docid,
                         data: (myArray.dictionary(at: i)?.toDictionary())! )

            try! dbnew.saveDocument(newdoc)

        }

        let extendedDoc = dbnew.document(withID: "1002")
        let features =
            extendedDoc!.array(forKey: "features")?.toArray() <i class="conum" data-value="43"></i><b>(43)</b>
        for i in 0...features!.count-1 {
            print(features![i])
        }

        print( extendedDoc!.array(
                forKey: "features")?.toJSON() as! String) <i class="conum" data-value="44"></i><b>(44)</b>

        // end::tojson-array[]

        /*
        // tag::tojson-array-output[]

         1 Hotel Ted
         2 Hotel Fred
         3 Hotel Ned

         Cable TV
         Toaster
         Microwave

         ["Cable TV","Toaster","Microwave"]
         // end::tojson-array-output[]
        */


        // tag::tojson-dictionary[]

        var aJSONstring = """
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\"}
            """

        let myDict:MutableDictionaryObject =
            try! MutableDictionaryObject(json: aJSONstring) <i class="conum" data-value="45"></i><b>(45)</b>
        print(myDict)

        let name = myDict.string(forKey: "name")
        print("Details for: ", name!)

        for key in myDict {

            print(key, myDict.value(forKey: key) as! String)

        }


        // end::tojson-dictionary[]

        /*
        // tag::tojson-dictionary-output[]

         Details for:  Hotel Ned
         description Undefined description for Hotel Ned
         id 1002
         name Hotel Ned
         country Australia
         type hotel
         city Balmain

         // end::tojson-dictionary-output[]
        */
    public func JsonApiBlob() throws {
        // tag::tojson-blob[]
      // Get a document
        let thisDoc = db.document(withID: "1000")?.toMutable() <i class="conum" data-value="46"></i><b>(46)</b>

        // Get the image and add as a blob to the document
        let contentType = "image/jpg";
        let ourImage = UIImage(named: "couchbaseimage.png")!
        let imageData = ourImage.jpegData(compressionQuality: 1)!
        thisDoc?.setBlob(
            Blob(contentType: contentType, data: imageData), forKey: "avatar") <i class="conum" data-value="47"></i><b>(47)</b>

       let theBlobAsJSONstringFails =
              thisDoc?.blob(forKey: "avatar")!.toJSON();

        // Save blob as part of doc or alternatively as a blob

        try! db.saveDocument(thisDoc!);
        try! db.saveBlob(
                blob: Blob(contentType: contentType, data: imageData)); <i class="conum" data-value="48"></i><b>(48)</b>

        // Retrieve saved blob as a JSON, reconstitue and check still blob
        let sameDoc = db.document(withID: "1000")
        let sameBlob = sameDoc?.blob(forKey: "avatar")
        let theBlobAsJSONstring = sameBlob!.toJSON(); <i class="conum" data-value="49"></i><b>(49)</b>

        for (key, value) in sameDoc!.toDictionary() {
             print( "Data -- {0) = {1}", key, value);
        }

        if(Blob.isBlob(properties: sameBlob!.properties)) <i class="conum" data-value="50"></i><b>(50)</b>
        {
            print(theBlobAsJSONstring);
        }

        // end::tojson-blob[]


    }

//    } // end func testjson

//        } // end query loop

    } // end jsonapi func


}

    extension String {

        func toJSONObj() -&gt; Any {

            let d1 = self.data(using: .utf8)

            return try! JSONSerialization.jsonObject(
                with: d1!, options:[])
        }
    }



//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

// tag::listener[]

// tag::listener-simple[]
val config =
  URLEndpointListenerConfiguration(database) <i class="conum" data-value="51"></i><b>(51)</b>

config.setAuthenticator(
    ListenerPasswordAuthenticator {
      username, password -&gt;
        "valid.user" == username &amp;&amp;
        ("valid.password.string" == String(password))
    }
) <i class="conum" data-value="52"></i><b>(52)</b>

val listener =
  URLEndpointListener(config) <i class="conum" data-value="53"></i><b>(53)</b>

listener.start()  <i class="conum" data-value="54"></i><b>(54)</b>

// end::listener-simple[]



// tag::replicator-simple[]

let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="55"></i><b>(55)</b>

var thisConfig = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="56"></i><b>(56)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="57"></i><b>(57)</b>

let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="58"></i><b>(58)</b>

this.replicator = new Replicator(config); <i class="conum" data-value="59"></i><b>(59)</b>

this.replicator.start(); <i class="conum" data-value="60"></i><b>(60)</b>

// end::replicator-simple[]



import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    // tag::xctListener-start-func[]
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
    // tag::xctListener-start[]
    // tag::xctListener-config[]
    //  ... fragment preceded by other user code, including
    //  ... Couchbase Lite Database initialization that returns `thisDB`

    guard let db = thisDB else {
      throw print("DatabaseNotInitialized")
      // ... take appropriate actions
    }
    var listener: URLEndpointListener?
    let config = URLEndpointListenerConfiguration.init(database: db)
    config.port = tls ? wssPort : wsPort
    config.disableTLS = !tls
    config.authenticator = auth
    self.listener = URLEndpointListener.init(config: config)
//  ... fragment followed by other user code
    // end::xctListener-config[]

        // Start:
        try self.listener!.start()
    // end::xctListener-start[]

        return self.listener!
    }
    // end::xctListener-start-func[]

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
    // tag::xctListener-stop-func[]
    var listener: URLEndpointListener?
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
    // end::xctListener-stop-func[]
        }
    }

    func cleanUpIdentities() throws {
// tag::xctListener-delete-anon-ids[]
        try URLEndpointListener.deleteAnonymousIdentities()
// end::xctListener-delete-anon-ids[]
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// tag::xctListener-auth-tls-tlsidentity-anon[]
        // Anonymous Identity:

        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// end::xctListener-auth-tls-tlsidentity-anon[]

// tag::xctListener-auth-tls-tlsidentity-ca[]
        // User Identity:
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        var(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
// end::xctListener-auth-tls-tlsidentity-ca[]
    }

    func testPasswordAuthenticator() throws {
// tag::xctListener-auth-basic-pwd-full[]
        // Listener:
// tag::xctListener-auth-basic-pwd[]
        let thisAuth = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: thisAuth)

        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull,    continuous: false,
                 auth: auth)
// end::xctListener-auth-basic-pwd[]

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)


        // Cleanup:
        try stopListen()
    }
// end::xctListener-auth-basic-pwd-full[]

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }

// tag::xctListener-auth-tls-CCA-Root-full[]
// tag::xctListener-auth-tls-CCA-Root[]
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)
// end::xctListener-auth-tls-CCA-Root[]

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
// end::xctListener-auth-tls-CCA-Root-full[]
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }
// tag::xctListener-auth-tls-self-signed-full[]
// tag::xctListener-auth-tls-self-signed[]
        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)


        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: true, serverCert: nil)
        }
// end::xctListener-auth-tls-self-signed[]
        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
// end::xctListener-auth-tls-self-signed-full[]
    }

// tag::xctListener-auth-tls-ca-cert-full[]
    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
// tag::xctListener-auth-tls-ca-cert[]
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: serverCert)
        }
// end::xctListener-auth-tls-ca-cert[]

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
// tag::xctListener-status-check-full[]
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: false, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }
// end::xctListener-status-check-full[]

}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}
// end::start-replication[]

// tag::xctListener-auth-password-basic[]
listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
  (username, password) -&gt; Bool in
    (["password" : password, "name":username])
    if (self._allowListedUsers.contains(["password" : password, "name":username])) {
        return true
    }
    return false
}
// end::xctListener-auth-password-basic[]

// tag::xctListener-auth-cert-roots[]
let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
let listener = try listen(tls: true, auth: listenerAuth)// end::xctListener-auth-cert-roots[]

// tag::xctListener-auth-cert-auth[]
let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
    XCTAssertEqual(certs.count, 1)
    var commongName: CFString?
    let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
    XCTAssertEqual(status, errSecSuccess)
    XCTAssertNotNil(commongName)
    XCTAssertEqual((commongName! as String), "daniel")
    return true
}
// end::xctListener-auth-cert-auth[]

// tag::xctListener-config-basic-auth[]
let listenerConfig = URLEndpointListenerConfiguration(database: db)
listenerConfig.disableTLS  = true // Use with anonymous self signed cert
listenerConfig.enableDeltaSync = true
listenerConfig.tlsIdentity = nil

listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
    if (self._whitelistedUsers.contains(["password" : validPassword, "name":validUser])) {
        return true
    }
    return false
        }

_thisListener = URLEndpointListener(config: listenerConfig)
// end::xctListener-config-basic-auth[]





// tag::replication-start-func[]
    func startP2PReplicationWithUserDatabaseToRemotePeer(_ peer:PeerHost, handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void) throws{
        print("\(#function) with ws://\(peer)/\(kUserDBName)")
        guard let userDb = thisDB else {
          throw print("DatabaseNotInitialized")
          // ... take appropriate actions
        }
        guard let user = self.currentUserCredentials?.user, let password = self.currentUserCredentials?.password else {
          throw print("UserCredentialsNotProvided")
          // ... take appropriate actions
        }

// tag::replicator-start-func-config-init[]
        var replicatorForUserDb = _replicatorsToPeers[peer]

        if replicatorForUserDb == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(kUserDBName)") else {
                throw print("URLInvalid")
                // ... take appropriate actions
            }


            let config = ReplicatorConfiguration.init(database: userDb, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>
// end::replicator-start-func-config-init[]

// tag::replicator-start-func-config-more[]

            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>

// end::replicator-start-func-config-more[]

// tag::replicator-start-func-config-auth[]

            config.acceptOnlySelfSignedServerCertificate = true
            let authenticator = BasicAuthenticator(username: validUser, password: validPassword)
            config.authenticator = authenticator
// end::replicator-start-func-config-auth[]

// tag::replicator-start-func-repl-init[]
replicatorForUserDb = Replicator.init(config: config)
_replicatorsToPeers[peer] = replicatorForUserDb
// end::replicator-start-func-repl-init[]
          }


// tag::replicator-start-func-repl-start[]
if let pushPullReplListenerForUserDb = registerForEventsForReplicator(replicatorForUserDb,handler:handler) {
    _replicatorListenersToPeers[peer] = pushPullReplListenerForUserDb

}
replicatorForUserDb?.start()
handler(PeerConnectionStatus.Connecting)
// end::replicator-start-func-repl-start[]

      }
// end::replication-start-func[]


// tag::replicator-register-for-events[]
fileprivate func registerForEventsForReplicator(_ replicator:Replicator?,
  handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void )-&gt;ListenerToken? {
    let pushPullReplListenerForUserDb = replicator?.addChangeListener({ (change) in

      let s = change.status
      if s.error != nil {
          handler(PeerConnectionStatus.Error)
          return
      }

      switch s.activity {
      case .connecting:
          print("Replicator Connecting to Peer")
          handler(PeerConnectionStatus.Connecting)
      case .idle:
          print("Replicator in Idle state")
          handler(PeerConnectionStatus.Connected)
      case .busy:
          print("Replicator in busy state")
          handler(PeerConnectionStatus.Busy)
      case .offline:
          print("Replicator in offline state")
      case .stopped:
          print("Completed syncing documents")
          handler(PeerConnectionStatus.Error)

      }

      if s.progress.completed == s.progress.total {
          print("All documents synced")
      }
      else {
          print("Documents \(s.progress.total - s.progress.completed) still pending sync")
      }
  })
  return pushPullReplListenerForUserDb
// end::replicator-register-for-events[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  fileprivate var _allowlistedUsers:[[String:String]] = []
  // tag::listener-initialize[]
  fileprivate var _thisListener:URLEndpointListener?
  fileprivate var thisDB:Database?

    // tag::listener-config-db[]
    let listenerConfig =
      URLEndpointListenerConfiguration(database: thisDB!) <i class="conum" data-value="61"></i><b>(61)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    /* optionally */ let wsPort: UInt16 = 55991
    /* optionally */ let wssPort: UInt16 = 55990
    listenerConfig.port =  wssPort <i class="conum" data-value="62"></i><b>(62)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    listenerConfig.networkInterface = "10.1.1.10"  <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    listenerConfig.enableDeltaSync = true <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-tls-enable[]
     // tag::listener-config-tls-id-anon[]
    // Set the credentials the server presents the client
    // Use an anonymous self-signed cert
    listenerConfig.tlsIdentity = nil <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure how the client is to be authenticated
    // Here, use Basic Authentication
    listenerConfig.authenticator =
      ListenerPasswordAuthenticator(authenticator: {
        (validUser, validPassword) -&gt; Bool in
          if (self._allowlistedUsers.contains {
                $0 == validPassword &amp;&amp; $1 == validUser
              }) {
              return true
              }
            return false
          }) <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-client-auth-pwd[]

    // tag::listener-start[]
    // Initialize the listener
    _thisListener = URLEndpointListener(config: listenerConfig) <i class="conum" data-value="68"></i><b>(68)</b>
    guard let thisListener = _thisListener else {
      throw ListenerError.NotInitialized
      // ... take appropriate actions
    }
    // Start the listener
    try thisListener.start() <i class="conum" data-value="69"></i><b>(69)</b>

    // end::listener-start[]
// end::listener-initialize[]
  }
}


// BEGIN Additonal listener options



// tag::listener-get-network-interfaces[]
import SystemConfiguration
// . . .

  #if os(macOS)
  for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
      // do something with this `interface`
  }
  #endif
// . . .

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
let config =
  URLEndpointListenerConfiguration(database: self.oDB)
let listener = URLEndpointListener(config: config)
try listener.start()

print("urls: \(listener.urls)")

// end::listener-get-url-list[]


    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-full-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="70"></i><b>(70)</b>

    // end::listener-config-tls-full-enable[]
    // tag::listener-config-tls-disable[]
    listenerConfig.disableTLS  = true <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    guard let pathToCert =
      Bundle.main.path(forResource: "cert", ofType: "p12")
    else { /* process error */ return }

    guard let localCertificate =
      try? NSData(contentsOfFile: pathToCert) as Data
    else { /* process error */ return } <i class="conum" data-value="72"></i><b>(72)</b>

    let thisIdentity =
      try TLSIdentity.importIdentity(withData: localCertificate,
                                    password: "123",
                                    label: thisSecId) <i class="conum" data-value="73"></i><b>(73)</b>

    // end::listener-config-tls-id-caCert[]
    // tag::listener-config-tls-id-SelfSigned[]
    let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="74"></i><b>(74)</b>

    let thisIdentity =
      try TLSIdentity.createIdentity(forServer: true, /* isServer */
            attributes: attrs,
            expiration: Date().addingTimeInterval(86400),
            label: "Server-Cert-Label") <i class="conum" data-value="75"></i><b>(75)</b>

    // end::listener-config-tls-id-SelfSigned[]
    // tag::listener-config-tls-id-full-set[]
    // Set the credentials the server presents the client
    listenerConfig.tlsIdentity = thisIdentity    <i class="conum" data-value="76"></i><b>(76)</b>

    // end::listener-config-tls-id-full-set[]
    // end::listener-config-tls-id-full[]
    // tag::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-root[]
    // Authenticate using Cert Authority

    // cert is a pre-populated object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="77"></i><b>(77)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="78"></i><b>(78)</b> <i class="conum" data-value="79"></i><b>(79)</b>

    // end::listener-config-client-auth-root[]
    // end::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-lambda[]
    // tag::listener-config-client-auth-self-signed[]
    // Authenticate self-signed cert using application logic

    // cert is a user-supplied object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="80"></i><b>(80)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init { <i class="conum" data-value="81"></i><b>(81)</b>
      (certs) -&gt; Bool in
        var certs:SecCertificate
        var certCommonName:CFString?
        let status=SecCertificateCopyCommonName(certs[0], &amp;certCommonName)
        if (self._allowedCommonNames.contains(["name": certCommonName! as String])) {
            return true
        }
        return false
    } <i class="conum" data-value="82"></i><b>(82)</b>

    // end::listener-config-client-auth-self-signed[]
    // end::listener-config-client-auth-lambda[]
// END Additonal listener options





// tag::old-listener-config-tls-id-nil[]
listenerConfig.tlsIdentity = nil

// end::old-listener-config-tls-id-nil[]
// tag::old-listener-config-delta-sync[]
listenerConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]
// tag::listener-status-check[]
let totalConnections = thisListener.status.connectionCount
let activeConnections = thisListener.status.activeConnectionCount

// end::listener-status-check[]
// tag::listener-stop[]
        thisListener.stop()

// end::listener-stop[]
// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
// tag::old-listener-config-client-auth-self-signed[]
listenerConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}
// end::old-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
config.port = tls ? wssPort : wsPort
config.disableTLS = !tls
config.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // tag::p2p-act-rep-func[]
    let validUser = "syncuser"
    let validPassword = "sync9455"
    let cert:SecCertificate?
    let passivePeerEndpoint = "10.1.1.12:8920"
    let passivePeerPort = "8920"
    let passiveDbName = "userdb"
    var actDb:Database?
    var thisReplicator:Replicator?
    var replicatorListener:ListenerToken?


    // tag::p2p-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="83"></i><b>(83)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    config.replicatorType = .pushAndPull

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = false; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    config.continuous = true

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="85"></i><b>(85)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="86"></i><b>(86)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: "Our Username", password: "Our Password")
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    config.conflictResolver = ( /* define resolver function */); <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-conflict[]
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    thisReplicator = Replicator.init( config: config) <i class="conum" data-value="88"></i><b>(88)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // Optionally add a change listener
    // Retain token for use in deletion
    let pushPullReplListener:ListenerToken? = thisReplicator?.addChangeListener({ (change) in <i class="conum" data-value="89"></i><b>(89)</b>
      if change.status.activity == .stopped {
          print("Replication stopped")
      }
      else {
      // tag::p2p-act-rep-status[]
          print("Replicator is currently ", thisReplicator?.status.activity)
      }
    })

    // end::p2p-act-rep-status[]
    // end::p2p-act-rep-add-change-listener[]

    // tag::p2p-act-rep-start[]
        // Run the replicator using the config settings
        thisReplicator?.start()  <i class="conum" data-value="90"></i><b>(90)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]


    // end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener

    thisReplicator?.removeChangeListener(withToken: pushPullReplListener)
    // Stop the replicator
    thisReplicator?.stop()

// end::p2p-act-rep-stop[]
}


// BEGIN Additional p2p-avt-rep options
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="91"></i><b>(91)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    config.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="93"></i><b>(93)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: validUser, password: validPassword)
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-tlsid-tlsidentity-with-label[]
      // Check if Id exists in keychain and if so, use that Id
      if let thisIdentity =
        (try? TLSIdentity.identity(withLabel: "doco-sync-server")) ?? nil { <i class="conum" data-value="94"></i><b>(94)</b>
          print("An identity with label : doco-sync-server already exists in keychain")
          thisAuthenticator = ClientCertificateAuthenticator(identity: thisIdentity)  <i class="conum" data-value="95"></i><b>(95)</b>
          config.authenticator = thisAuthenticator
          }

      // end::p2p-tlsid-check-keychain[]
    // end::p2p-tlsid-tlsidentity-with-label[]
// END Additional p2p-avt-rep options




// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
    // tag::old-p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-tlsid-check-keychain[]
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        do {
            if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
                print("An identity with label : doco-sync-server already exists in keychain")
                return thisIdentity
                }
        } catch
          {return nil}
        // end::p2p-tlsid-check-keychain[]
        thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
        config.thisAuthenticator
    // end::old-p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert

// tag::p2p-tlsid-delete-id-from-keychain[]

try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);

// end::p2p-tlsid-delete-id-from-keychain[]


// end::p2p-tlsid-manage-func[]
// tag::old-p2p-act-rep-config-self-cert[]
// acceptOnlySelfSignedServerCertificate = true -- accept Slf-Signed Certs
config.disableTLS = false
config.acceptOnlySelfSignedServerCertificate = true

// end::old-p2p-act-rep-config-self-cert[]

// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]

  // Get bundled resource and read into localcert
  guard let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer")
    else { /* process error */ }
  guard let localCertificate:NSData =
               NSData(contentsOfFile: pathToCert)
    else { /* process error */ }

  // Create certificate
  // using its DER representation as a CFData
  guard let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
    else { /* process error */ }

  // Add `pinnedCert` and `acceptOnlySelfSignedServerCertificate=false` to `ReplicatorConfiguration`
  config.acceptOnlySelfSignedServerCertificate = false
  config.pinnedServerCertificate = pinnedCert
  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}

    // optionally  listenerConfig.tlsIdentity = TLSIdentity(withIdentity:serverSelfCert-id)


        // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="96"></i><b>(96)</b>

    // end::old-listener-config-client-root-ca[]

    // For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
class MyClass {
    var database: Database?
    var replicator: Replicator? <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database!, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator?.start()
    }
}

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]

&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

    // tag::sgw-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="97"></i><b>(97)</b>

    // end::sgw-act-rep-initialize[]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Use keychain identity in config</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/swift/examples/code_snippets/SampleCodeTest.swift">//
//  SampleCodeTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import CouchbaseLiteSwift
import MultipeerConnectivity
import CoreML


class SampleCodeTest {

    var database: Database!
    var db: Database!

    var replicator: Replicator!

    // MARK: Database

    func dontTestNewDatabase() throws {
        // tag::new-database[]
        do {
            self.database = try Database(name: "my-database")
        } catch {
            print(error)
        }
        // end::new-database[]

        // tag::close-database[]
        do {
            try userDb.close()
        }

        // end::close-database[]


    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseEncryption() throws {
        // tag::database-encryption[]
        let config = DatabaseConfiguration()
        config.encryptionKey = EncryptionKey.password("secretpassword")
        self.database = try Database(name: "my-database", config: config)
        // end::database-encryption[]
    }
    #endif

    func dontTestLogging() throws {
        // tag::logging[]
        Database.setLogLevel(.verbose, domain: .replicator)
        Database.setLogLevel(.verbose, domain: .query)
        // end::logging[]
    }

    func dontTestConsoleLogging() throws {
        // tag::console-logging[]
        Database.log.console.domains = .all <i class="conum" data-value="1"></i><b>(1)</b>
        Database.log.console.level = .verbose <i class="conum" data-value="2"></i><b>(2)</b>

        // end::console-logging[]
        // tag::console-logging-db[]

        Database.log.console.domains = .database

        // end::console-logging-db[]
    }

    func dontTestFileLogging() throws {
        // tag::file-logging[]
        let tempFolder = NSTemporaryDirectory().appending("cbllog")
        let config = LogFileConfiguration(directory: tempFolder) <i class="conum" data-value="3"></i><b>(3)</b>
        config.usePlainText = true <i class="conum" data-value="4"></i><b>(4)</b>
        config.maxSize = 1024 <i class="conum" data-value="5"></i><b>(5)</b>
        Database.log.file.config = config <i class="conum" data-value="6"></i><b>(6)</b>
        Database.log.file.level = .info <i class="conum" data-value="7"></i><b>(7)</b>
        // end::file-logging[]
    }

    func dontTestEnableCustomLogging() throws {
        // tag::set-custom-logging[]
        Database.log.custom = LogTestLogger(.warning) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    func dontTestLoadingPrebuilt() throws {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For iOS you need to get the path from the main bundle.
        let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
        if !Database.exists(withName: "travel-sample") {
            do {
                try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
            } catch {
                fatalError("Could not load pre-built database")
            }
        }
        // end::prebuilt-database[]
    }

    // MARK: Document

    func dontTestInitializer() throws {
        database = self.db

        // tag::initializer[]
        let newTask = MutableDocument()
            .setString("task", forKey: "type")
            .setString("todo", forKey: "owner")
            .setDate(Date(), forKey: "createdAt")
        try database.saveDocument(newTask)
        // end::initializer[]
    }

    func dontTestMutability() throws {
        database = self.db

        // tag::update-document[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument)
        // end::update-document[]
    }

    func dontTestTypedAcessors() throws {
        let newTask = Document()

        // tag::date-getter[]
        newTask.setValue(Date(), forKey: "createdAt")
        let date = newTask.date(forKey: "createdAt")
        // end::date-getter[]

        // tag::to-dictionary[]
        newTask.toDictionary() <i class="conum" data-value="9"></i><b>(9)</b>

        // end::to-dictionary[]

        // tag::to-json[]
        newTask.toJSON() <i class="conum" data-value="10"></i><b>(10)</b>

        // end::to-json[]

        print("\(date!)")
    }

    func dontTestBatchOperations() throws {
        // tag::batch[]
        do {
            try database.inBatch {
                for i in 0...10 {
                    let doc = MutableDocument()
                    doc.setValue("user", forKey: "type")
                    doc.setValue("user \(i)", forKey: "name")
                    doc.setBoolean(false, forKey: "admin")
                    try database.saveDocument(doc)
                    print("saved user document \(doc.string(forKey: "name")!)")
                }
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::batch[]
    }

    func dontTestChangeListener() throws {
        database = self.db

        // tag::document-listener[]
        database.addDocumentChangeListener(withID: "user.john") { (change) in
            if let document = self.database.document(withID: change.documentID) {
                print("Status :: \(document.string(forKey: "verified_account")!)")
            }
        }
        // end::document-listener[]
    }

    func dontTestDocumentExpiration() throws {
        database = self.db

        // tag::document-expiration[]
        // Purge the document one day from now
        let ttl = Calendar.current.date(byAdding: .day, value: 1, to: Date())
        try database.setDocumentExpiration(withID: "doc123", expiration: ttl)

        // Reset expiration
        try db.setDocumentExpiration(withID: "doc1", expiration: nil)

        // Query documents that will be expired in less than five minutes
        let fiveMinutesFromNow = Date(timeIntervalSinceNow: 60 * 5).timeIntervalSince1970
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(
                Meta.expiration.lessThan(
                    Expression.double(fiveMinutesFromNow)
                )
            )
        // end::document-expiration[]

    }

    func dontTestBlob() throws {
    #if TARGET_OS_IPHONE
        database = self.db
        let newTask = MutableDocument()
        var image: UIImage!

        // tag::blob[]
        let appleImage = UIImage(named: "avatar.jpg")!
        let imageData = UIImageJPEGRepresentation(appleImage, 1)!

        let blob = Blob(contentType: "image/jpeg", data: imageData)
        newTask.setBlob(blob, forKey: "avatar")
        try database.saveDocument(newTask)

        if let taskBlob = newTask.blob(forKey: "image") {
            image = UIImage(data: taskBlob.content!)
        }
        // end::blob[]

        print("\(image)")
    #endif
    }

    func dontTest1xAttachment() throws {
        database = self.db
        let document = MutableDocument()

        // tag::1x-attachment[]
        let attachments = document.dictionary(forKey: "_attachments")
        let avatar = attachments?.blob(forKey: "avatar")
        let content = avatar?.content
        // end::1x-attachment[]

        print("\(content!)")
    }

    // MARK: Query

    func dontTestIndexing() throws {
        database = self.db

        // tag::query-index[]
        let index = IndexBuilder.valueIndex(items:
            ValueIndexItem.expression(Expression.property("type")),
            ValueIndexItem.expression(Expression.property("name")))
        try database.createIndex(index, withName: "TypeNameIndex")
        // end::query-index[]
    }

    func dontTestSelectMeta() throws {
        database = self.db

        // tag::query-select-meta[]
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-meta[]
    }


    func dontTestSelectProps() throws {
        database = self.db

        // tag::query-select-props[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("type"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))

        do {
            for result in try query.execute() {
                print("document id :: \(result.string(forKey: "id")!)")
                print("document name :: \(result.string(forKey: "name")!)")
            }
        } catch {
            print(error)
        }
        // end::query-select-props[]
    }

    func dontTestSelectAll() throws {
        database = self.db

        // tag::query-select-all[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
        // end::query-select-all[]

        // tag::live-query[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        let token = query.addChangeListener { (change) in <i class="conum" data-value="11"></i><b>(11)</b>
            for result in change.results! {
                print(result.keys)
                /* Update UI */
            }
        }

        // Start live query.
        query.execute(); <i class="conum" data-value="12"></i><b>(12)</b>
        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(withToken: token) <i class="conum" data-value="13"></i><b>(13)</b>

        // end::stop-live-query[]

        print("\(query)")
    }

    func dontTestWhere() throws {
        database = self.db

        // tag::query-where[]
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                if let dict = result.dictionary(forKey: "travel-sample") {
                    print("document name :: \(dict.string(forKey: "name")!)")
                }
            }
        } catch {
            print(error)
        }
        // end::query-where[]
    }

    func dontTestQueryDeletedDocuments() throws {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(db))
            .where(Meta.isDeleted)
        // end::query-deleted-documents[]
    }

    func dontTestCollectionOperatorContains() throws {
        database = self.db

        // tag::query-collection-operator-contains[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))
                .and(ArrayFunction.contains(Expression.property("public_likes"), value: Expression.string("Armani Langworth")))
        )

        do {
             for result in try query.execute() {
                print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
            }
        }
        // end::query-collection-operator-contains[]
    }

    func dontTestCollectionOperatorIn() throws {
        database = self.db

        // tag::query-collection-operator-in[]
        let values = [
            Expression.property("first"),
            Expression.property("last"),
            Expression.property("username")
            ]

        QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.string("Armani").in(values))
        // end::query-collection-operator-in[]
    }


    func dontTestLikeOperator() throws {
        database = self.db

        // tag::query-like-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("royal engineers museum")))
            )
            .limit(Expression.int(10))

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
        // end::query-like-operator[]
    }

    func dontTestWildCardMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestWildCardCharacterMatch() throws {
        database = self.db

        // tag::query-like-operator-wildcard-character-match[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").like(Expression.string("eng____r")))
            )
            .limit(Expression.int(10))
        // end::query-like-operator-wildcard-character-match[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestRegexMatch() throws {
        database = self.db

        // tag::query-regex-operator[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("landmark"))
                .and(Expression.property("name").regex(Expression.string("\\bEng.*e\\b"))) <i class="conum" data-value="14"></i><b>(14)</b>
            )
            .limit(Expression.int(10))
        // end::query-regex-operator[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestJoin() throws {
        database = self.db

        // tag::query-join[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
            .from(
                DataSource.database(database!).as("airline")
            )
            .join(
                Join.join(DataSource.database(database!).as("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX")))
        )
        // end::query-join[]

        do {
            for result in try query.execute() {
                print("name property :: \(result.string(forKey: "name")!)")
            }
        }
    }

    func dontTestGroupBy() throws {
        database = self.db

        // tag::query-groupby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.all())),
                SelectResult.property("country"),
                SelectResult.property("tz"))
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
            ).groupBy(
                Expression.property("country"),
                Expression.property("tz")
        )

        do {
            for result in try query.execute() {
                print("There are \(result.int(forKey: "$1")) airports on the \(result.string(forKey: "tz")!) timezone located in \(result.string(forKey: "country")!) and above 300 ft")
            }
        }
        // end::query-groupby[]
    }

    func dontTestOrderBy() throws {
        database = self.db

        // tag::query-orderby[]
        let query = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("title"))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("title").ascending())
            .limit(Expression.int(10))
        // end::query-orderby[]

        print("\(query)")
    }

    func dontTestExplain() throws {
      database = self.db
      // tag::query-explain-all[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("university")))
          .groupBy(Expression.property("country"))
          .orderBy(Ordering.property("name").ascending())  <i class="conum" data-value="15"></i><b>(15)</b>

      print(try thisQuery.explain()) <i class="conum" data-value="16"></i><b>(16)</b>
      // end::query-explain-all[]

      // tag::query-explain-like[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("%hotel%")) <i class="conum" data-value="17"></i><b>(17)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain())

      // end::query-explain-like[]

      // tag::query-explain-nopfx[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="18"></i><b>(18)</b>
            .and(Expression.property("name").like(Expression.string("%royal%"))));

      print(try thisQuery.explain());

      // end::query-explain-nopfx[]

      // tag::query-explain-function[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Function.lower(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="19"></i><b>(19)</b>

      print(try thisQuery.explain());

      // end::query-explain-function[]

      // tag::query-explain-nofunction[]
      let thisQuery = QueryBuilder
          .select(SelectResult.all())
          .from(DataSource.database(database))
          .where(
            Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="20"></i><b>(20)</b>

      print(try thisQuery.explain());

      // end::query-explain-nofunction[]

    }


    func dontTestCreateFullTextIndex() throws {
        database = self.db

        // tag::fts-index[]
        // Insert documents
        let tasks = ["buy groceries", "play chess", "book travels", "buy museum tickets"]
        for task in tasks {
            let doc = MutableDocument()
            doc.setString("task", forKey: "type")
            doc.setString(task, forKey: "name")
            try database.saveDocument(doc)
        }

        // Create index
        do {
            let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("name")).ignoreAccents(false)
            try database.createIndex(index, withName: "nameFTSIndex")
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-index[]
    }

    func dontTestFullTextSearch() throws {
        database = self.db

        // tag::fts-query[]
        let whereClause = FullTextExpression.index("nameFTSIndex").match("'buy'")
        let query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)

        do {
            for result in try query.execute() {
                print("document id \(result.string(at: 0)!)")
            }
        } catch let error {
            print(error.localizedDescription)
        }
        // end::fts-query[]
    }


    func dontTestToJson-ArrayObject() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-array[]




        // end::tojson-array[]
    }



    func dontTestGetBlobAsJSONstring() throws {
        db = self.db

        // tag::tojson-getblobasstring[]

        let thisdoc = db.document(withID: "thisdoc-id")!.toDictionary();
        let thisBlob =  thisdoc["avatar"] as! Blob

        if Blob.isBlob(properties: thisBlob.properties) {
          var blobtype = thisBlob.properties["content_type"]
          var bloblength = thisBlob.properties["length"]
        }
        // end::tojson-getblobasstring[]
    }


    func dontTestToJson-Dictionary() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-dictionary[]


        // end::tojson-dictionary[]
    }


    func dontTestToJson-Document() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-document[]


        // end::tojson-document[]
    }


    func dontTestToJson-Result() throws {
        database = self.db
        // demonstrate use of JSON string
        // tag::tojson-result[]
        let ourJSON =  "{{\"id\": \"hotel-ted\"},{\"name\": \"Hotel Ted\"},{\"city\": \"Paris\"},{\"type\": \"hotel\"}}"
        let ourDoc = try MutableDocument(id: "doc", json: ourJSON)
        try database.saveDocument(ourDoc)

        let query = QueryBuilder
                      .select(SelectResult.all)
                      .from(DataSource.database(database)))
                      .where(Expression.property("id").equalTo(Expression.string("hotel-ted"))))

        for (_,result) in try! query.execute().enumerated() {
          if let thisJSON = result.toJSON().toJSONObj() as? [String:Any] {
              // ... process document properties as required e.g.
              let docid = thisJSON["id"]
              let name = thisJSON["name"]
              let city = thisJSON["city"]
              let type = thisJSON["type"]
              //
          }

        // end::tojson-result[]
    }







    // MARK: Replication

    /* The `tag::replication[]` example is inlined in swift.adoc */

    func dontTestEnableReplicatorLogging() throws {
        // tag::replication-logging[]
        // Replicator
        Database.setLogLevel(.verbose, domain: .replicator)
        // Network
        Database.setLogLevel(.verbose, domain: .network)
        // end::replication-logging[]
    }

    func dontTestReplicationBasicAuthentication() throws {
        // tag::basic-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = BasicAuthenticator(username: "john", password: "pass")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::basic-authentication[]
    }

    func dontTestReplicationSessionAuthentication() throws {
        // tag::session-authentication[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database, target: target)
        config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::session-authentication[]
    }

    func dontTestReplicatorStatus() throws {
        // tag::replication-status[]
        self.replicator.addChangeListener { (change) in
            if change.status.activity == .stopped {
                print("Replication stopped")
            }
        }
        // end::replication-status[]
    }

//  BEGIN PendingDocuments IB -- 11/Feb/21 --
    func dontTestReplicationPendingDocs() throws {
      // tag::replication-pendingdocuments[]

      let url = URL(string: "ws://localhost:4984/mydatabase")!
      let target = URLEndpoint(url: url)

      let config = ReplicatorConfiguration(database: database, target: target)
      config.replicatorType = .push

      // tag::replication-push-pendingdocumentids[]
      self.replicator = Replicator(config: config)
      let mydocids:Set = self.replicator.pendingDocumentIds() <i class="conum" data-value="21"></i><b>(21)</b>

      // end::replication-push-pendingdocumentids[]
      if(!mydocids.isEmpty) {
        print("There are \(mydocids.count) documents pending")

        self.replicator.addChangeListener { (change) in
          print("Replicator activity level is \(change.status.activity.toString())")
          // iterate and report-on previously
          // retrieved pending docids 'list'
          for thisId in mydocids.sorted() {
            // tag::replication-push-isdocumentpending[]
            if(!self.replicator.isDocumentPending(thisid)) { <i class="conum" data-value="22"></i><b>(22)</b>
              print("Doc ID \(thisId) now pushed")
            }
            // end::replication-push-isdocumentpending[]
          }
        }

        self.replicator.start()
        // end::replication-pendingdocuments[]
    }

//  END test PendingDocuments IB -- 11/Feb/21 --


    func dontTestReplicatorDocumentEvent() throws {
        // tag::add-document-replication-listener[]
        let token = self.replicator.addDocumentReplicationListener { (replication) in
            print("Replication type :: \(replication.isPush ? "Push" : "Pull")")
            for document in replication.documents {
                if (document.error == nil) {
                    print("Doc ID :: \(document.id)")
                    if (document.flags.contains(.deleted)) {
                        print("Successfully replicated a deleted document")
                    }
                } else {
                    // There was an error
                }
            }
        }

        self.replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        self.replicator.removeChangeListener(withToken: token)
        // end::remove-document-replication-listener[]
    }

    func dontTestReplicationCustomHeader() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-custom-header[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.headers = ["CustomHeaderName": "Value"]
        // end::replication-custom-header[]
    }

    func dontTestReplicationChannels() throws {
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        // tag::replication-channels[]
        let config = ReplicatorConfiguration(database: database, target: target)
        config.channels = ["channel_name"]
        // end::replication-channels[]
    }

    func dontTestHandlingReplicationError() throws {
        // tag::replication-error-handling[]
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }
        // end::replication-error-handling[]
    }

    func dontTestReplicationResetCheckpoint() throws {
        // tag::replication-reset-checkpoint[]
        if (resetCheckpointRequired_Example) {
          self.replicator.start(reset: true)  <i class="conum" data-value="23"></i><b>(23)</b>
        else
          self.replicator.start()
        }

        // end::replication-reset-checkpoint[]
    }

    func dontTestReplicationPushFilter() throws {
        // tag::replication-push-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pushFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (document.string(forKey: "type") == "draft") {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-push-filter[]
    }

    func dontTestReplicationPullFilter() throws {
        // tag::replication-pull-filter[]
        let url = URL(string: "ws://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pullFilter = { (document, flags) in <i class="conum" data-value="1"></i><b>(1)</b>
            if (flags.contains(.deleted)) {
                return false
            }
            return true
        }

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-pull-filter[]
    }

//  Added 2/Feb/21 - Ian Bridge
//  Changed for 3.0.0 - Ian Bridge 3/Mar/21
    func testCustomRetryConfig() {
        // tag::replication-retry-config[]
        let target =
          URLEndpoint(url: URL(string: "ws://foo.couchbase.com/db")!)

        let config =  ReplicatorConfiguration(database: database, target: targetDatabase)
        config.type = .pushAndPull
        config.continuous = true
        // tag::replication-set-heartbeat[]
        config.heartbeat = 150 <i class="conum" data-value="24"></i><b>(24)</b>

        // end::replication-set-heartbeat[]
        // tag::replication-set-maxattempts[]
        config.maxattempts = 20 <i class="conum" data-value="25"></i><b>(25)</b>

        // end::replication-set-maxattempts[]
        // tag::replication-set-maxattemptwaittime[]
        config.maxattemptwaittime = 600 <i class="conum" data-value="26"></i><b>(26)</b>
        repl = Replicator(config: config)

        // end::replication-set-maxattemptwaittime[]

        // end::replication-retry-config[]
    }

    #if COUCHBASE_ENTERPRISE
    func dontTestDatabaseReplica() throws {
        let database2 = try self.openDB(name: "db2")

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Swift Community. */
        // tag::database-replica[]
        let targetDatabase = DatabaseEndpoint(database: database2)
        let config = ReplicatorConfiguration(database: database, target: targetDatabase)
        config.replicatorType = .push

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::database-replica[]

        try database2.delete()
    }
    #endif

    func dontTestCertificatePinning() throws {

        // tag::certificate-pinning[]
        let certURL = Bundle.main.url(forResource: "cert", withExtension: "cer")!
        let data = try! Data(contentsOf: certURL)
        let certificate = SecCertificateCreateWithData(nil, data as CFData)

        let url = URL(string: "wss://localhost:4985/db")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.pinnedServerCertificate = certificate
        // end::certificate-pinning[]

        print("\(config)")
    }

    func dontTestGettingStarted() throws {
        // tag::getting-started[]
        // Get the database (and create it if it doesn’t exist).
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // Create a new document (i.e. a record) in the database.
        let mutableDoc = MutableDocument()
            .setFloat(2.0, forKey: "version")
            .setString("SDK", forKey: "type")

        // Save it to the database.
        do {
            try database.saveDocument(mutableDoc)
        } catch {
            fatalError("Error saving document")
        }

        // Update a document.
        if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
            mutableDoc.setString("Swift", forKey: "language")
            do {
                try database.saveDocument(mutableDoc)

                let document = database.document(withID: mutableDoc.id)!
                // Log the document ID (generated by the database)
                // and properties
                print("Document ID :: \(document.id)")
                print("Learning \(document.string(forKey: "language")!)")
            } catch {
                fatalError("Error updating document")
            }
        }

        // Create a query to fetch documents of type SDK.
        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }

        // Create replicators to push and pull changes to and from the cloud.
        let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/getting-started-db")!)
        let replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
        replConfig.replicatorType = .pushAndPull

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

        // Create replicator (make sure to add an instance or static variable named replicator)
        self.replicator = Replicator(config: replConfig)

        // Listen to replicator change events.
        self.replicator.addChangeListener { (change) in
            if let error = change.status.error as NSError? {
                print("Error code :: \(error.code)")
            }
        }

        // Start replication.
        self.replicator.start()
        // end::getting-started[]
    }

    func dontTestPredictiveModel() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::register-model[]
        let model = ImageClassifierModel()
        Database.prediction.registerModel(model, withName: "ImageClassifier")
        // end::register-model[]

        // tag::predictive-query-value-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input)

        let index = IndexBuilder.valueIndex(items: ValueIndexItem.expression(prediction.property("label")))
        try database.createIndex(index, withName: "value-index-image-classifier")
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel(withName: "ImageClassifier")
        // end::unregister-model[]
    }

    func dontTestPredictiveIndex() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query-predictive-index[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])

        let index = IndexBuilder.predictiveIndex(model: "ImageClassifier", input: input)
        try database.createIndex(index, withName: "predictive-index-image-classifier")
        // end::predictive-query-predictive-index[]
    }

    func dontTestPredictiveQuery() throws {
        let database: Database
        do {
            database = try Database(name: "mydb")
        } catch {
            fatalError("Error opening database")
        }

        // tag::predictive-query[]
        let input = Expression.dictionary(["photo": Expression.property("photo")])
        let prediction = PredictiveModel.predict(model: "ImageClassifier", input: input) <i class="conum" data-value="1"></i><b>(1)</b>

        let query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(
                    prediction.property("probablity")
                        .greaterThanOrEqualTo(Expression.double(0.8))
                )
            )

        // Run the query.
        do {
            let result = try query.execute()
            print("Number of rows :: \(result.allResults().count)")
        } catch {
            fatalError("Error running the query")
        }
        // end::predictive-query[]
    }

    func dontTestCoreMLPredictiveModel() throws {
        // tag::coreml-predictive-model[]
        // Load MLModel from `ImageClassifier.mlmodel`
        let modelURL = Bundle.main.url(forResource: "ImageClassifier", withExtension: "mlmodel")!
        let compiledModelURL = try MLModel.compileModel(at: modelURL)
        let model = try MLModel(contentsOf: compiledModelURL)
        let predictiveModel = CoreMLPredictiveModel(mlModel: model)

        // Register model
        Database.prediction.registerModel(predictiveModel, withName: "ImageClassifier")
        // end::coreml-predictive-model[]
    }

    func dontTestReplicatorConflictResolver() throws {
        // tag::replication-conflict-resolver[]
        let url = URL(string: "wss://localhost:4984/mydatabase")!
        let target = URLEndpoint(url: url)

        let config = ReplicatorConfiguration(database: database, target: target)
        config.conflictResolver = LocalWinConflictResolver()

        self.replicator = Replicator(config: config)
        self.replicator.start()
        // end::replication-conflict-resolver[]
    }

    func dontTestSaveWithConflictHandler() throws {
        // tag::update-document-with-conflict-handler[]
        guard let document = database.document(withID: "xyz") else { return }
        let mutableDocument = document.toMutable()
        mutableDocument.setString("apples", forKey: "name")
        try database.saveDocument(mutableDocument, conflictHandler: { (new, current) -&gt; Bool in
            let currentDict = current!.toDictionary()
            let newDict = new.toDictionary()
            let result = newDict.merging(currentDict, uniquingKeysWith: { (first, _) in first })
            new.setData(result)
            return true
        })
        // end::update-document-with-conflict-handler[]

    }

    // helper
    func isValidCredentials(_ u: String, password: String) -&gt; Bool { return true }

    func dontTestInitListener() throws {
        let db: Database!

        // tag::init-urllistener[]
        let config = URLEndpointListenerConfiguration(database: db)
        config.tlsIdentity = nil; // Use with anonymous self signed cert
        config.authenticator = ListenerPasswordAuthenticator(authenticator:
            { (username, password) -&gt; Bool in
                return self.isValidCredentials(username, password: password)
        })

        // end::init-urllistener[]
    }

    func dontTestListenerStart() throws {
        let listener: URLEndpointListener

        // tag::start-urllistener[]
        try listener.start()

        // end::start-urllistener[]
    }

    func dontTestListenerStop() throws {
        let listener: URLEndpointListener
        // tag::stop-urllistener[]
        listener.stop()

        // end::stop-urllistener[]
    }

    func dontTestCreateSelfSignedCert() throws {
        // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
        // Example-6
        // tag::create-self-signed-cert[]
        // tag::listener-config-tls-id-SelfSigned[]
        let attrs = [certAttrCommonName: "Couchbase Inc"]
        let identity =
          try TLSIdentity.createIdentity(forServer: true,
                attributes: attrs,
                expiration: Date().addingTimeInterval(86400),
                label: "Server-Cert-Label")
        // end::listener-config-tls-id-SelfSigned[]
        // end::create-self-signed-cert[]
        print("\(identity.expiration)") // to avoid warning
    }
}


// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class myMLModel {
    static func predictImage(data: Data) -&gt; [String : AnyObject] {}
}

class ImageClassifierModel: PredictiveModel {
    func predict(input: DictionaryObject) -&gt; DictionaryObject? {
        guard let blob = input.blob(forKey: "photo") else {
            return nil
        }

        let imageData = blob.content!
        // `myMLModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        let modelOutput = myMLModel.predictImage(data: imageData)

        let output = MutableDictionaryObject(data: modelOutput)
        return output <i class="conum" data-value="1"></i><b>(1)</b>
    }
}
// end::predictive-model[]

// tag::custom-logging[]
fileprivate class LogTestLogger: Logger {

    // set the log level
    var level: LogLevel = .none

    func log(level: LogLevel, domain: LogDomain, message: String) {
        // handle the message, for example piping it to
        // a third party framework
    }

}
// end::custom-logging[]

// tag::local-win-conflict-resolver[]
class LocalWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.localDocument
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
class RemoteWinConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        return conflict.remoteDocument
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
class MergeConflictResolver: ConflictResolverProtocol {
    func resolve(conflict: Conflict) -&gt; Document? {
        let localDict = conflict.localDocument!.toDictionary()
        let remoteDict = conflict.remoteDocument!.toDictionary()
        let result = localDict.merging(remoteDict) { (current, new) -&gt; Any in
            return current // return current value in case of duplicate keys
        }
        return MutableDocument(id: conflict.documentID, data: result)
    }
}
// end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class ActivePeer: MessageEndpointDelegate {

    init() throws {
        let id = ""

        // tag::message-endpoint[]
        let database = try Database(name: "dbname")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

        // Create the replicator object.
        let replicator = Replicator(config: config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
        let connection = ActivePeerConnection() /* implements MessageEndpointConnection */
        return connection
    }
    // end::create-connection[]

}

class ActivePeerConnection: MessageEndpointConnection {

    var replicatorConnection: ReplicatorConnection?

    init() {}

    func disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::active-peer-open[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = message.toData()
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::active-peer-send[]

    func receive(data: Data) {
        // tag::active-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::active-peer-receive[]
    }

    // tag::active-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::active-peer-close[]

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
class PassivePeerConnection: NSObject, MessageEndpointConnection {

    var messageEndpointListener: MessageEndpointListener?
    var replicatorConnection: ReplicatorConnection?

    override init() {
        super.init()
    }

    func startListener() {
        // tag::listener[]
        let database = try! Database(name: "mydb")
        let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
        messageEndpointListener = MessageEndpointListener(config: config)
        // end::listener[]
    }

    func stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    func acceptConnection() {
        // tag::advertizer-accept[]
        let connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection: connection)
        // end::advertizer-accept[]
    }

    func disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(error: nil)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        replicatorConnection = connection
        completion(true, nil)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
        var data = Data()
        data.append(message.toData())
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion(true, nil)
    }
    // end::passive-peer-send[]

    func receive(data: Data) {
        // tag::passive-peer-receive[]
        let message = Message.fromData(data)
        replicatorConnection?.receive(message: message)
        // end::passive-peer-receive[]
    }

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    func close(error: Error?, completion: @escaping () -&gt; Void) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion()
    }
    // end::passive-peer-close[]
}


// BEGIN URLENDPOINTLISTENER SAMPLES

//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
        let config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.port = tls ? wssPort : wsPort
        config.disableTLS = !tls
        config.authenticator = auth

        return try listen(config: config)
    }

    @discardableResult
    func listen(config: URLEndpointListenerConfiguration) throws -&gt; URLEndpointListener {
        self.listener = URLEndpointListener.init(config: config)

        // Start:
        try self.listener!.start()

        return self.listener!
    }

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
        }
    }

    func cleanUpIdentities() throws {
        self.ignoreException {
            try URLEndpointListener.deleteAnonymousIdentities()
        }
    }

    func replicator(db: Database, continuous: Bool, target: Endpoint, serverCert: SecCertificate?) -&gt; Replicator {
        let config = ReplicatorConfiguration(database: db, target: target)
        config.replicatorType = .pushAndPull
        config.continuous = continuous
        config.pinnedServerCertificate = serverCert
        return Replicator(config: config)
    }

    /// Two replicators, replicates docs to the self.listener; validates connection status
    func validateMultipleReplicationsTo() throws {
        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")
        let count = self.listener!.config.database.count

        // open DBs
        try deleteDB(name: "db1")
        try deleteDB(name: "db2")
        let db1 = try openDB(name: "db1")
        let db2 = try openDB(name: "db2")

        // For keeping the replication long enough to validate connection status, we will use blob
        let imageData = try dataFromResource(name: "image", ofType: "jpg")

        // DB#1
        let doc1 = createDocument()
        let blob1 = Blob(contentType: "image/jpg", data: imageData)
        doc1.setBlob(blob1, forKey: "blob")
        try db1.saveDocument(doc1)

        // DB#2
        let doc2 = createDocument()
        let blob2 = Blob(contentType: "image/jpg", data: imageData)
        doc2.setBlob(blob2, forKey: "blob")
        try db2.saveDocument(doc2)

        let repl1 = replicator(db: db1,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])
        let repl2 = replicator(db: db2,
                               continuous: false,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        var maxConnectionCount: UInt64 = 0, maxActiveCount: UInt64 = 0
        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .busy {
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount);
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount);
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db1" {
                    exp1.fulfill()
                } else {
                    exp2.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        // check both replicators access listener at same time
        XCTAssertEqual(maxConnectionCount, 2);
        XCTAssertEqual(maxActiveCount, 2);

        // all data are transferred to/from
        XCTAssertEqual(self.listener!.config.database.count, count + 2);
        XCTAssertEqual(db1.count, count + 1/* db2 doc*/);
        XCTAssertEqual(db2.count, count + 1/* db1 doc*/);

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db1.close()
        try db2.close()
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // Anonymous Identity:
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

        // User Identity:
// tag::p2psync-act-tlsid-create[]
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
// end::p2psync-act-tlsid-create[]
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
    }

    func testPasswordAuthenticator() throws {
        // Listener:
        let listenerAuth = ListenerPasswordAuthenticator.init {
            (username, password) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: listenerAuth)

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Success:
        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth)

        // Cleanup:
        try stopListen()
    }

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)

// tag::p2psync-act-tlsid-delete[]
        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
// end::p2psync-act-tlsid-delete[]

        // Create client identity:
// tag::p2psync-act-tlsid-import[]
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)
// end::p2psync-act-tlsid-import[]

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .selfSignedCert, serverCert: nil)
        }

        // Cleanup
        try stopListen()
    }

    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: .caCert, serverCert: serverCert)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: .caCert, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }

    func testMultipleListenersOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        let listener1 = URLEndpointListener(config: config)
        let listener2 = URLEndpointListener(config: config)

        try listener1.start()
        try listener2.start()

        try generateDocument(withID: "doc-1")
        self.run(target: listener1.localURLEndpoint,
                 type: .pushAndPull,
                 continuous: false,
                 auth: nil,
                 serverCert: listener1.tlsIdentity!.certs[0])

        // since listener1 and listener2 are using same certificates, one listener only needs stop.
        listener2.stop()
        try stopListener(listener: listener1)
        XCTAssertEqual(self.oDB.count, 1)
    }

    func testReplicatorAndListenerOnSameDatabase() throws {
        if !self.keyChainAccessAllowed { return }

        let exp1 = expectation(description: "replicator#1 stop")
        let exp2 = expectation(description: "replicator#2 stop")

        // listener
        let doc = createDocument()
        try self.oDB.saveDocument(doc)
        try listen()

        // Replicator#1 (otherDB -&gt; DB#1)
        let doc1 = createDocument()
        try self.db.saveDocument(doc1)
        let target = DatabaseEndpoint(database: self.db)
        let repl1 = replicator(db: self.oDB, continuous: true, target: target, serverCert: nil)

        // Replicator#2 (DB#2 -&gt; Listener(otherDB))
        try deleteDB(name: "db2")
        let db2 = try openDB(name: "db2")
        let doc2 = createDocument()
        try db2.saveDocument(doc2)
        let repl2 = replicator(db: db2,
                               continuous: true,
                               target: self.listener!.localURLEndpoint,
                               serverCert: self.listener!.tlsIdentity!.certs[0])

        let changeListener = { (change: ReplicatorChange) in
            if change.status.activity == .idle &amp;&amp;
                change.status.progress.completed == change.status.progress.total {
                if self.oDB.count == 3 &amp;&amp; self.db.count == 3 &amp;&amp; db2.count == 3 {
                    change.replicator.stop()
                }
            }

            if change.status.activity == .stopped {
                if change.replicator.config.database.name == "db2" {
                    exp2.fulfill()
                } else {
                    exp1.fulfill()
                }
            }

        }
        let token1 = repl1.addChangeListener(changeListener)
        let token2 = repl2.addChangeListener(changeListener)

        repl1.start()
        repl2.start()
        wait(for: [exp1, exp2], timeout: 5.0)

        XCTAssertEqual(self.oDB.count, 3)
        XCTAssertEqual(self.db.count, 3)
        XCTAssertEqual(db2.count, 3)

        repl1.removeChangeListener(withToken: token1)
        repl2.removeChangeListener(withToken: token2)

        try db2.close()
        try stopListen()
    }

    func testCloseWithActiveListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        // Close database should also stop the listener:
        try self.oDB.close()

        XCTAssertNil(self.listener!.port)
        XCTAssertNil(self.listener!.urls)

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-1008
    func _testEmptyNetworkInterface() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        for (i, url) in self.listener!.urls!.enumerated() {
            // separate db instance!
            let db = try Database(name: "db-\(i)")
            let doc = createDocument()
            doc.setString(url.absoluteString, forKey: "url")
            try db.saveDocument(doc)

            // separate replicator instance
            let target = URLEndpoint(url: url)
            let rConfig = ReplicatorConfiguration(database: db, target: target)
            rConfig.pinnedServerCertificate = self.listener?.tlsIdentity!.certs[0]
            run(config: rConfig, expectedError: nil)

            // remove the db
            try db.delete()
        }

        XCTAssertEqual(self.oDB.count, UInt64(self.listener!.urls!.count))

        let q = QueryBuilder.select([SelectResult.all()]).from(DataSource.database(self.oDB))
        let rs = try q.execute()
        var result = [URL]()
        for res in rs.allResults() {
            let dict = res.dictionary(at: 0)
            result.append(URL(string: dict!.string(forKey: "url")!)!)
        }

        XCTAssertEqual(result, self.listener!.urls)
        try stopListen()

        // validate 0.0.0.0 meta-address should return same empty response.
        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.networkInterface = "0.0.0.0"
        try listen(config: config)
        XCTAssertEqual(self.listener!.urls!, result)
        try stopListen()
    }

    func testMultipleReplicatorsToListener() throws {
        if !self.keyChainAccessAllowed { return }

        try listen()

        let doc = createDocument()
        doc.setString("Tiger", forKey: "species")
        try self.oDB.saveDocument(doc)

        try validateMultipleReplicationsTo()

        try stopListen()
    }

    // TODO: https://issues.couchbase.com/browse/CBL-954
    func _testReadOnlyListener() throws {
        if !self.keyChainAccessAllowed { return }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.readOnly = true
        try listen(config: config)

        self.run(target: self.listener!.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, serverCert: self.listener!.tlsIdentity!.certs[0],
                 expectedError: CBLErrorHTTPForbidden)
    }
}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}

// END URLENDPOINTLISTENER SAMPLES


//
//  QueryResultSets.swift
//  sampleQueryResults
//
//  Created by Ian Bridge on 28/07/2021.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

//import CoreML


class Query {

    var this_hotel:Hotel = Hotel()

    let dbName = "hotel"
    //    let dbName = "hotel"
    var db = try! Database(name: "hotel")
    var hotels = [String:Any]()
    var thisDocsProperties = [String:Any]()
    var jsonbit = [String:Any]()

    func dontTestQueryAll() throws {





    //        seedHotel()

    // QUERY RESULT SET HANDLING EXAMPLES
    // tag::query-syntax-all[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database( db))

    // end::query-syntax-all[]

    // tag::query-access-all[]

        do {

            for row in try! listQuery.execute() {

                let thisDocsProps =
                    row.dictionary(at: 0)?.toDictionary() <i class="conum" data-value="27"></i><b>(27)</b>

                let docid = thisDocsProps!["id"] as! String

                let name = thisDocsProps!["name"] as! String

                let type = thisDocsProps!["type"] as! String

                let city = thisDocsProps!["city"] as! String

                let hotel = row.dictionary(at: 0)?.toDictionary()  <i class="conum" data-value="28"></i><b>(28)</b>
                let hotelId = hotel!["id"] as! String
                hotels[hotelId] = hotel
            } // end for

        } //end do-block

    // end::query-access-all[]

    // tag::query-access-json[]

    // In this example the Hotel class is defined using Codable
    //
    // class Hotel : Codable {
    //   var id : String = "undefined"
    //   var type : String = "hotel"
    //   var name : String = "undefined"
    //   var city : String = "undefined"
    //   var country : String = "undefined"
    //   var description : String? = ""
    //   var text : String? = ""
    //   ... other class content
    // }


        do {
            var results = try! listQuery.execute()
            for row in  results {

                // get the result into a JSON String
                let jsonString = row.toJSON() <i class="conum" data-value="29"></i><b>(29)</b>

                let thisJsonObj:Dictionary =
                    try! (JSONSerialization.jsonObject(
                            with: jsonString.data(using: .utf8)!,
                                                  options: .allowFragments)
                            as? [String: Any])! <i class="conum" data-value="30"></i><b>(30)</b>

                // Use Json Object to populate Native object
                // Use Codable class to unpack JSON data to native object
                let this_hotel:Hotel =
                    (try JSONDecoder().decode(
                        Hotel.self,
                        from: jsonString.data(using: .utf8)!
                        )
                    ) <i class="conum" data-value="31"></i><b>(31)</b>

                // ALTERNATIVELY unpack in steps
                this_hotel.id = thisJsonObj["id"] as! String
                this_hotel.name = thisJsonObj["name"] as! String
                this_hotel.type = thisJsonObj["type"] as! String
                this_hotel.city = thisJsonObj["city"] as! String
                hotels[this_hotel.id] = this_hotel


            } // end for

            // end::query-access-json[]

        } catch let err {
            print(err.localizedDescription)

        } // end do



    } // end func dontTestQueryAll



    func dontTestQueryProps () throws {
        // tag::query-syntax-props[]
        let db = try! Database(name: "hotel")
        var hotels = [String:Any]()
        var hotel:Hotel = Hotel.init()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"),
                    SelectResult.expression(Expression.property("id")),
                    SelectResult.expression(Expression.property("name")),
                    SelectResult.expression(Expression.property("city")),
                    SelectResult.expression(Expression.property("type")))
                    .from(DataSource.database(db))

        // end::query-syntax-props[]

        // tag::query-access-props[]
        for (_, result) in try! listQuery.execute().enumerated() {


            let thisDoc = result.toDictionary() as? [String:Any]  <i class="conum" data-value="32"></i><b>(32)</b>
                // Store dictionary data in hotel object and save in arry
            hotel.id = thisDoc!["id"] as! String
            hotel.name = thisDoc!["name"] as! String
            hotel.city = thisDoc!["city"] as! String
            hotel.type = thisDoc!["type"] as! String
            hotels[hotel.id] = hotel

            // Use result content directly
            let docid = result.string(forKey: "metaId")
            let hotelId = result.string(forKey: "id")
            let name = result.string(forKey: "name")
            let city = result.string(forKey: "city")
            let type = result.string(forKey: "type")

            // ... process document properties as required
            print("Result properties are: ", docid, hotelId,name, city, type)
          } // end for

// end::query-access-props[]
    }// end func

//
    func dontTestQueryCount () throws {

    // tag::query-syntax-count-only[]
        let db = try! Database(name: "hotel")
        do {
            let listQuery = QueryBuilder
                .select(SelectResult.expression(Function.count(Expression.all())).as("mycount"))
                .from (DataSource.database(db)).groupBy(Expression.property("type"))

                // end::query-syntax-count-only[]


            // tag::query-access-count-only[]

            for result in try! listQuery.execute() {
                let dict = result.toDictionary() as? [String: Int]
                let thiscount = dict!["mycount"]! <i class="conum" data-value="33"></i><b>(33)</b>
                print("There are ", thiscount, " rows")

                // Alternatively
                print ( result["mycount"] )

            } // end for

        } // end do
    } // end function

// end::query-access-count-only[]

//
    func dontTestQueryId () throws {

        // tag::query-syntax-id[]
        let db = try! Database(name: "hotel")
        let listQuery = QueryBuilder.select(SelectResult.expression(Meta.id).as("metaId"))
                    .from(DataSource.database(db))

        // end::query-syntax-id[]


        // tag::query-access-id[]
        for (_, result) in try! listQuery.execute().enumerated() {

            print(result.toDictionary())
            print("Document Id is -- ", result["metaId"].string!)

            let thisDocsId = result["metaId"].string! <i class="conum" data-value="34"></i><b>(34)</b>

            // Now you can get the document using the ID
            var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

            let hotelId = thisDoc["id"] as! String

            let name = thisDoc["name"] as! String

            let city = thisDoc["city"] as! String

            let type = thisDoc["type"] as! String

            // ... process document properties as required
            print("Result properties are: ", hotelId,name, city, type)


        } // end for

// end::query-access-id[]
    } // end function dontTestQueryId

//
    func query_pagination () throws {

        //tag::query-syntax-pagination[]
        let thisOffset = 0;
        let thisLimit = 20;
        //
        let listQuery = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(db))
                .limit(Expression.int(thisLimit),
                  offset: Expression.int(thisOffset))

        // end::query-syntax-pagination[]

    } // end function
//
//


    func seedHotel () {

        try! db.delete()

        db = try! Database(name: "hotel")

        let key = ["id","name","type","city", "country","description"]
        let val = [
                    ["1000","Hotel Ted","hotel","Paris", "France","Very good and central"],
                    ["1001","Hotel Fred","hotel","London", "England","Very good and central"],
                    ["1002","Hotel Du Ville","hotel","Casablanca", "Morocco","Very good and central"],
                    ["1003","Hotel Ouzo","hotel","Athens", "Greece","Very good and central"]
                ]
        let maxrecs=val.count-1
        for i in 0 ... maxrecs {

            let hotel:MutableDocument = MutableDocument(id: val[0][i])

            for x in 0 ... key.count-1 {
                hotel.setString(val[i][x], forKey: key[x])
            }

            try! db.saveDocument(hotel)


        }

    }

//
// N1QL QUERY EXAMPLES
//

    func dontTestQueryN1QL() throws {


    // tag::query-syntax-n1ql[]
        let db = try! Database(name: "hotel")

        let listQuery =  db.createQuery( query:
            "SELECT META().id AS thisId FROM _ WHERE type = 'hotel'" <i class="conum" data-value="35"></i><b>(35)</b>
        )

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QL


    func dontTestQueryN1QLparams() throws {

    // tag::query-syntax-n1ql-params[]
        let db = try! Database(name: "hotel")

        let listQuery =
            db.createQuery( query:
                   "SELECT META().id AS thisId FROM _ WHERE type = $type" <i class="conum" data-value="36"></i><b>(36)</b>
                )

        listQuery.parameters =
            Parameters().setString("hotel", forName: "type") <i class="conum" data-value="37"></i><b>(37)</b>

        let results: ResultSet = try listQuery.execute()

    // end::query-syntax-n1ql-params[]

        if (results.allResults().count&gt;0) {
            try! dontTestProcessResults(results: results)
        }

    } // dontTestQueryN1QLparams()


    func dontTestProcessResults(results: ResultSet) throws {
        // tag::query-access-n1ql[]
        // tag::query-process-results[]

        do {

            for row in results {

                print(row["thisId"].string!)

                let thisDocsId = row["thisId"].string!

                // Now you can get the document using the ID
                var thisDoc = db.document(withID: thisDocsId)!.toDictionary()

                let hotelId = thisDoc["id"] as! String

                let name = thisDoc["name"] as! String

                let city = thisDoc["city"] as! String

                let type = thisDoc["type"] as! String

                // ... process document properties as required
                print("Result properties are: ", hotelId,name, city, type)

            } // end for
            // end::query-access-n1ql[]
            // end::query-process-results[]

        } //end do-block

    } // end dontTestProcessResults

} // end class






//  JSON API SNIPPETS


    func dontTestJSONdocument() {
        // tag::query-get-all[]
        let db = try! Database(name: "hotel")
        let dbnew = try! Database(name: "newhotels")
        var hotels = [String:Any]()

        let listQuery = QueryBuilder
            .select(SelectResult.expression(Meta.id).as("metaId"))
            .from(DataSource.database(db))


        for row in try! listQuery.execute() {
        // end::query-get-all[]

        // tag::tojson-document[]
            var thisId = row.string(forKey: "metaId")! as String

            var thisJSONstring = try! db.document(withID: thisId)!.toJSON() <i class="conum" data-value="38"></i><b>(38)</b>

            print("JSON String = ", thisJSONstring as! String)

            let hotelFromJSON:MutableDocument = <i class="conum" data-value="39"></i><b>(39)</b>
                    try! MutableDocument(id: thisId as? String, json: thisJSONstring)

            try! dbnew.saveDocument(hotelFromJSON)

            let newhotel = dbnew.document(withID: thisId)

            let keys = newhotel!.keys
            for key in keys { <i class="conum" data-value="40"></i><b>(40)</b>
                print(key, newhotel!.value(forKey: key) as! String)
            }

            // end::tojson-document[]

        /*
        // tag::tojson-document-output[]
             JSON String =  {"description":"Very good and central","id":"1000","country":"France","name":"Hotel Ted","type":"hotel","city":"Paris"}
             type hotel
             id 1000
             country France
             city Paris
             description Very good and central
             name Hotel Ted
        // end::tojson-document-output[]
         */
        } // end  query for loop


        // tag::tojson-array[]

        let thisJSONstring = """
            [{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
            \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
            {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
            \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
            \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]
            """
        let myArray:MutableArrayObject =
            try! MutableArrayObject.init(json: thisJSONstring) <i class="conum" data-value="41"></i><b>(41)</b>

        for i in 0...myArray.count-1 {

            print(i+1, myArray.dictionary(at: i)!.string(forKey: "name")!)

            var docid = myArray.dictionary(at: i)!.string(forKey: "id")

            var newdoc:MutableDocument = <i class="conum" data-value="42"></i><b>(42)</b>
                try! MutableDocument(id: docid,
                         data: (myArray.dictionary(at: i)?.toDictionary())! )

            try! dbnew.saveDocument(newdoc)

        }

        let extendedDoc = dbnew.document(withID: "1002")
        let features =
            extendedDoc!.array(forKey: "features")?.toArray() <i class="conum" data-value="43"></i><b>(43)</b>
        for i in 0...features!.count-1 {
            print(features![i])
        }

        print( extendedDoc!.array(
                forKey: "features")?.toJSON() as! String) <i class="conum" data-value="44"></i><b>(44)</b>

        // end::tojson-array[]

        /*
        // tag::tojson-array-output[]

         1 Hotel Ted
         2 Hotel Fred
         3 Hotel Ned

         Cable TV
         Toaster
         Microwave

         ["Cable TV","Toaster","Microwave"]
         // end::tojson-array-output[]
        */


        // tag::tojson-dictionary[]

        var aJSONstring = """
            {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
            \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\"}
            """

        let myDict:MutableDictionaryObject =
            try! MutableDictionaryObject(json: aJSONstring) <i class="conum" data-value="45"></i><b>(45)</b>
        print(myDict)

        let name = myDict.string(forKey: "name")
        print("Details for: ", name!)

        for key in myDict {

            print(key, myDict.value(forKey: key) as! String)

        }


        // end::tojson-dictionary[]

        /*
        // tag::tojson-dictionary-output[]

         Details for:  Hotel Ned
         description Undefined description for Hotel Ned
         id 1002
         name Hotel Ned
         country Australia
         type hotel
         city Balmain

         // end::tojson-dictionary-output[]
        */
    public func JsonApiBlob() throws {
        // tag::tojson-blob[]
      // Get a document
        let thisDoc = db.document(withID: "1000")?.toMutable() <i class="conum" data-value="46"></i><b>(46)</b>

        // Get the image and add as a blob to the document
        let contentType = "image/jpg";
        let ourImage = UIImage(named: "couchbaseimage.png")!
        let imageData = ourImage.jpegData(compressionQuality: 1)!
        thisDoc?.setBlob(
            Blob(contentType: contentType, data: imageData), forKey: "avatar") <i class="conum" data-value="47"></i><b>(47)</b>

       let theBlobAsJSONstringFails =
              thisDoc?.blob(forKey: "avatar")!.toJSON();

        // Save blob as part of doc or alternatively as a blob

        try! db.saveDocument(thisDoc!);
        try! db.saveBlob(
                blob: Blob(contentType: contentType, data: imageData)); <i class="conum" data-value="48"></i><b>(48)</b>

        // Retrieve saved blob as a JSON, reconstitue and check still blob
        let sameDoc = db.document(withID: "1000")
        let sameBlob = sameDoc?.blob(forKey: "avatar")
        let theBlobAsJSONstring = sameBlob!.toJSON(); <i class="conum" data-value="49"></i><b>(49)</b>

        for (key, value) in sameDoc!.toDictionary() {
             print( "Data -- {0) = {1}", key, value);
        }

        if(Blob.isBlob(properties: sameBlob!.properties)) <i class="conum" data-value="50"></i><b>(50)</b>
        {
            print(theBlobAsJSONstring);
        }

        // end::tojson-blob[]


    }

//    } // end func testjson

//        } // end query loop

    } // end jsonapi func


}

    extension String {

        func toJSONObj() -&gt; Any {

            let d1 = self.data(using: .utf8)

            return try! JSONSerialization.jsonObject(
                with: d1!, options:[])
        }
    }



//
//  URLEndpontListenerTest.swift
//  CouchbaseLite
//
//  Copyright (c) 2020 Couchbase, Inc. All rights reserved.
//
//  Licensed under the Couchbase License Agreement (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//  https://info.couchbase.com/rs/302-GJY-034/images/2017-10-30_License_Agreement.pdf
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

// tag::listener[]

// tag::listener-simple[]
val config =
  URLEndpointListenerConfiguration(database) <i class="conum" data-value="51"></i><b>(51)</b>

config.setAuthenticator(
    ListenerPasswordAuthenticator {
      username, password -&gt;
        "valid.user" == username &amp;&amp;
        ("valid.password.string" == String(password))
    }
) <i class="conum" data-value="52"></i><b>(52)</b>

val listener =
  URLEndpointListener(config) <i class="conum" data-value="53"></i><b>(53)</b>

listener.start()  <i class="conum" data-value="54"></i><b>(54)</b>

// end::listener-simple[]



// tag::replicator-simple[]

let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
let targetEndpoint = URLEndpoint(url: tgtUrl) //  <i class="conum" data-value="55"></i><b>(55)</b>

var thisConfig = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="56"></i><b>(56)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="57"></i><b>(57)</b>

let thisAuthenticator = BasicAuthenticator(username: "valid.user", password: "valid.password.string")
thisConfig.authenticator = thisAuthenticator <i class="conum" data-value="58"></i><b>(58)</b>

this.replicator = new Replicator(config); <i class="conum" data-value="59"></i><b>(59)</b>

this.replicator.start(); <i class="conum" data-value="60"></i><b>(60)</b>

// end::replicator-simple[]



import XCTest
@testable import CouchbaseLiteSwift

@available(macOS 10.12, iOS 10.0, *)
class URLEndpontListenerTest: ReplicatorTest {
    let wsPort: UInt16 = 4984
    let wssPort: UInt16 = 4985
    let serverCertLabel = "CBL-Server-Cert"
    let clientCertLabel = "CBL-Client-Cert"

    var listener: URLEndpointListener?

    @discardableResult
    func listen() throws -&gt; URLEndpointListener {
        return try listen(tls: true, auth: nil)
    }

    @discardableResult
    func listen(tls: Bool) throws -&gt; URLEndpointListener {
        return try! listen(tls: tls, auth: nil)
    }

    @discardableResult
    // tag::xctListener-start-func[]
    func listen(tls: Bool, auth: ListenerAuthenticator?) throws -&gt; URLEndpointListener {
        // Stop:
        if let listener = self.listener {
            listener.stop()
        }

        // Listener:
    // tag::xctListener-start[]
    // tag::xctListener-config[]
    //  ... fragment preceded by other user code, including
    //  ... Couchbase Lite Database initialization that returns `thisDB`

    guard let db = thisDB else {
      throw print("DatabaseNotInitialized")
      // ... take appropriate actions
    }
    var listener: URLEndpointListener?
    let config = URLEndpointListenerConfiguration.init(database: db)
    config.port = tls ? wssPort : wsPort
    config.disableTLS = !tls
    config.authenticator = auth
    self.listener = URLEndpointListener.init(config: config)
//  ... fragment followed by other user code
    // end::xctListener-config[]

        // Start:
        try self.listener!.start()
    // end::xctListener-start[]

        return self.listener!
    }
    // end::xctListener-start-func[]

    func stopListen() throws {
        if let listener = self.listener {
            try stopListener(listener: listener)
        }
    }

    func stopListener(listener: URLEndpointListener) throws {
    // tag::xctListener-stop-func[]
    var listener: URLEndpointListener?
        let identity = listener.tlsIdentity
        listener.stop()
        if let id = identity {
            try id.deleteFromKeyChain()
    // end::xctListener-stop-func[]
        }
    }

    func cleanUpIdentities() throws {
// tag::xctListener-delete-anon-ids[]
        try URLEndpointListener.deleteAnonymousIdentities()
// end::xctListener-delete-anon-ids[]
    }

    override func setUp() {
        super.setUp()
        try! cleanUpIdentities()
    }

    override func tearDown() {
        try! stopListen()
        try! cleanUpIdentities()
        super.tearDown()
    }

    func testTLSIdentity() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Disabled TLS:
        var config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.disableTLS = true
        var listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// tag::xctListener-auth-tls-tlsidentity-anon[]
        // Anonymous Identity:

        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        listener = URLEndpointListener.init(config: config)
        XCTAssertNil(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)

// end::xctListener-auth-tls-tlsidentity-anon[]

// tag::xctListener-auth-tls-tlsidentity-ca[]
        // User Identity:
        try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);
        let attrs = [certAttrCommonName: "CBL-Server"]
        let identity = try TLSIdentity.createIdentity(forServer: true,
                                                      attributes: attrs,
                                                      expiration: nil,
                                                      label: serverCertLabel)
        config = URLEndpointListenerConfiguration.init(database: self.oDB)
        config.tlsIdentity = identity
        listener = URLEndpointListener.init(config: config)
        var(listener.tlsIdentity)

        try listener.start()
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssert(identity === listener.tlsIdentity!)
        try stopListener(listener: listener)
        XCTAssertNil(listener.tlsIdentity)
// end::xctListener-auth-tls-tlsidentity-ca[]
    }

    func testPasswordAuthenticator() throws {
// tag::xctListener-auth-basic-pwd-full[]
        // Listener:
// tag::xctListener-auth-basic-pwd[]
        let thisAuth = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
            return (username as NSString).isEqual(to: "daniel") &amp;&amp;
                   (password as NSString).isEqual(to: "123")
        }
        let listener = try listen(tls: false, auth: thisAuth)

        auth = BasicAuthenticator.init(username: "daniel", password: "123")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull,    continuous: false,
                 auth: auth)
// end::xctListener-auth-basic-pwd[]

        // Replicator - No Authenticator:
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: nil, expectedError: CBLErrorHTTPAuthRequired)

        // Replicator - Wrong Credentials:
        var auth = BasicAuthenticator.init(username: "daniel", password: "456")
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                 auth: auth, expectedError: CBLErrorHTTPAuthRequired)


        // Cleanup:
        try stopListen()
    }
// end::xctListener-auth-basic-pwd-full[]

    func testClientCertAuthenticatorWithClosure() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
            XCTAssertEqual(certs.count, 1)
            var commongName: CFString?
            let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
            XCTAssertEqual(status, errSecSuccess)
            XCTAssertNotNil(commongName)
            XCTAssertEqual((commongName! as String), "daniel")
            return true
        }
        let listener = try listen(tls: true, auth: listenerAuth)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let attrs = [certAttrCommonName: "daniel"]
        let identity = try TLSIdentity.createIdentity(forServer: false, attributes: attrs, expiration: nil, label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]
        self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testClientCertAuthenticatorWithRootCerts() throws {
        if !self.keyChainAccessAllowed {
            return
        }

// tag::xctListener-auth-tls-CCA-Root-full[]
// tag::xctListener-auth-tls-CCA-Root[]
        // Root Cert:
        let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
        let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

        // Listener:
        let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
        let listener = try listen(tls: true, auth: listenerAuth)
// end::xctListener-auth-tls-CCA-Root[]

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)

        // Create client identity:
        let clientCertData = try dataFromResource(name: "identity/client", ofType: "p12")
        let identity = try TLSIdentity.importIdentity(withData: clientCertData, password: "123", label: clientCertLabel)

        // Replicator:
        let auth = ClientCertificateAuthenticator.init(identity: identity)
        let serverCert = listener.tlsIdentity!.certs[0]

        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false, auth: auth, serverCert: serverCert)
// end::xctListener-auth-tls-CCA-Root-full[]
        }

        // Cleanup:
        try TLSIdentity.deleteIdentity(withLabel: clientCertLabel)
        try stopListen()
    }

    func testServerCertVerificationModeSelfSignedCert() throws {
        if !self.keyChainAccessAllowed {
            return
        }
// tag::xctListener-auth-tls-self-signed-full[]
// tag::xctListener-auth-tls-self-signed[]
        // Listener:
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)


        // Replicator - Success:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: true, serverCert: nil)
        }
// end::xctListener-auth-tls-self-signed[]
        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
// end::xctListener-auth-tls-self-signed-full[]
    }

// tag::xctListener-auth-tls-ca-cert-full[]
    func testServerCertVerificationModeCACert() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        // Listener:
// tag::xctListener-auth-tls-ca-cert[]
        let listener = try listen(tls: true)
        XCTAssertNotNil(listener.tlsIdentity)
        XCTAssertEqual(listener.tlsIdentity!.certs.count, 1)

        // Replicator - Success:
        self.ignoreException {
            let serverCert = listener.tlsIdentity!.certs[0]
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: serverCert)
        }
// end::xctListener-auth-tls-ca-cert[]

        // Replicator - TLS Error:
        self.ignoreException {
            self.run(target: listener.localURLEndpoint, type: .pushAndPull, continuous: false,
                     serverCertVerifyMode: false, serverCert: nil, expectedError: CBLErrorTLSCertUnknownRoot)
        }

        // Cleanup
        try stopListen()
    }

    func testPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.port, wsPort)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testEmptyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.port)

        // Start:
        try self.listener!.start()
        XCTAssertNotEqual(self.listener!.port, 0)

        try stopListen()
        XCTAssertNil(self.listener!.port)
    }

    func testBusyPort() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        try listen()

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = self.listener!.port
        let listener2 = URLEndpointListener(config: config)

        expectError(domain: NSPOSIXErrorDomain, code: Int(EADDRINUSE)) {
            try listener2.start()
        }
    }

    func testURLs() throws {
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        self.listener = URLEndpointListener(config: config)
        XCTAssertNil(self.listener!.urls)

        // Start:
        try self.listener!.start()
        XCTAssert(self.listener!.urls?.count != 0)

        try stopListen()
        XCTAssertNil(self.listener!.urls)
    }

    func testConnectionStatus() throws {
// tag::xctListener-status-check-full[]
        if !self.keyChainAccessAllowed {
            return
        }

        let config = URLEndpointListenerConfiguration(database: self.oDB)
        config.port = wsPort
        config.disableTLS = true
        self.listener = URLEndpointListener(config: config)
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        // Start:
        try self.listener!.start()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)

        try generateDocument(withID: "doc-1")
        let rConfig = self.config(target: self.listener!.localURLEndpoint,
                                 type: .pushAndPull, continuous: false, auth: nil,
                                 serverCertVerifyMode: false, serverCert: nil)
        var maxConnectionCount: UInt64 = 0, maxActiveCount:UInt64 = 0
        run(config: rConfig, reset: false, expectedError: nil) { (replicator) in
            replicator.addChangeListener { (change) in
                maxConnectionCount = max(self.listener!.status.connectionCount, maxConnectionCount)
                maxActiveCount = max(self.listener!.status.activeConnectionCount, maxActiveCount)
            }
        }
        XCTAssertEqual(maxConnectionCount, 1)
        XCTAssertEqual(maxActiveCount, 1)
        XCTAssertEqual(self.oDB.count, 1)

        try stopListen()
        XCTAssertEqual(self.listener!.status.connectionCount, 0)
        XCTAssertEqual(self.listener!.status.activeConnectionCount, 0)
    }
// end::xctListener-status-check-full[]

}

@available(macOS 10.12, iOS 10.0, *)
extension URLEndpointListener {
    var localURL: URL {
        assert(self.port != nil &amp;&amp; self.port! &gt; UInt16(0))
        var comps = URLComponents()
        comps.scheme = self.config.disableTLS ? "ws" : "wss"
        comps.host = "localhost"
        comps.port = Int(self.port!)
        comps.path = "/\(self.config.database.name)"
        return comps.url!
    }

    var localURLEndpoint: URLEndpoint {
        return URLEndpoint.init(url: self.localURL)
    }
}
// end::start-replication[]

// tag::xctListener-auth-password-basic[]
listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
  (username, password) -&gt; Bool in
    (["password" : password, "name":username])
    if (self._allowListedUsers.contains(["password" : password, "name":username])) {
        return true
    }
    return false
}
// end::xctListener-auth-password-basic[]

// tag::xctListener-auth-cert-roots[]
let rootCertData = try dataFromResource(name: "identity/client-ca", ofType: "der")
let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
let listenerAuth = ListenerCertificateAuthenticator.init(rootCerts: [rootCert])
let listener = try listen(tls: true, auth: listenerAuth)// end::xctListener-auth-cert-roots[]

// tag::xctListener-auth-cert-auth[]
let listenerAuth = ListenerCertificateAuthenticator.init { (certs) -&gt; Bool in
    XCTAssertEqual(certs.count, 1)
    var commongName: CFString?
    let status = SecCertificateCopyCommonName(certs[0], &amp;commongName)
    XCTAssertEqual(status, errSecSuccess)
    XCTAssertNotNil(commongName)
    XCTAssertEqual((commongName! as String), "daniel")
    return true
}
// end::xctListener-auth-cert-auth[]

// tag::xctListener-config-basic-auth[]
let listenerConfig = URLEndpointListenerConfiguration(database: db)
listenerConfig.disableTLS  = true // Use with anonymous self signed cert
listenerConfig.enableDeltaSync = true
listenerConfig.tlsIdentity = nil

listenerConfig.authenticator = ListenerPasswordAuthenticator.init {
            (validUser, validPassword) -&gt; Bool in
    if (self._whitelistedUsers.contains(["password" : validPassword, "name":validUser])) {
        return true
    }
    return false
        }

_thisListener = URLEndpointListener(config: listenerConfig)
// end::xctListener-config-basic-auth[]





// tag::replication-start-func[]
    func startP2PReplicationWithUserDatabaseToRemotePeer(_ peer:PeerHost, handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void) throws{
        print("\(#function) with ws://\(peer)/\(kUserDBName)")
        guard let userDb = thisDB else {
          throw print("DatabaseNotInitialized")
          // ... take appropriate actions
        }
        guard let user = self.currentUserCredentials?.user, let password = self.currentUserCredentials?.password else {
          throw print("UserCredentialsNotProvided")
          // ... take appropriate actions
        }

// tag::replicator-start-func-config-init[]
        var replicatorForUserDb = _replicatorsToPeers[peer]

        if replicatorForUserDb == nil {
            // Start replicator to connect to the URLListenerEndpoint
            guard let targetUrl = URL(string: "ws://\(peer)/\(kUserDBName)") else {
                throw print("URLInvalid")
                // ... take appropriate actions
            }


            let config = ReplicatorConfiguration.init(database: userDb, target: URLEndpoint.init(url:targetUrl)) <i class="conum" data-value="1"></i><b>(1)</b>
// end::replicator-start-func-config-init[]

// tag::replicator-start-func-config-more[]

            config.replicatorType = .pushAndPull <i class="conum" data-value="2"></i><b>(2)</b>
            config.continuous =  true <i class="conum" data-value="3"></i><b>(3)</b>

// end::replicator-start-func-config-more[]

// tag::replicator-start-func-config-auth[]

            config.acceptOnlySelfSignedServerCertificate = true
            let authenticator = BasicAuthenticator(username: validUser, password: validPassword)
            config.authenticator = authenticator
// end::replicator-start-func-config-auth[]

// tag::replicator-start-func-repl-init[]
replicatorForUserDb = Replicator.init(config: config)
_replicatorsToPeers[peer] = replicatorForUserDb
// end::replicator-start-func-repl-init[]
          }


// tag::replicator-start-func-repl-start[]
if let pushPullReplListenerForUserDb = registerForEventsForReplicator(replicatorForUserDb,handler:handler) {
    _replicatorListenersToPeers[peer] = pushPullReplListenerForUserDb

}
replicatorForUserDb?.start()
handler(PeerConnectionStatus.Connecting)
// end::replicator-start-func-repl-start[]

      }
// end::replication-start-func[]


// tag::replicator-register-for-events[]
fileprivate func registerForEventsForReplicator(_ replicator:Replicator?,
  handler:@escaping(_ status:PeerConnectionStatus)-&gt;Void )-&gt;ListenerToken? {
    let pushPullReplListenerForUserDb = replicator?.addChangeListener({ (change) in

      let s = change.status
      if s.error != nil {
          handler(PeerConnectionStatus.Error)
          return
      }

      switch s.activity {
      case .connecting:
          print("Replicator Connecting to Peer")
          handler(PeerConnectionStatus.Connecting)
      case .idle:
          print("Replicator in Idle state")
          handler(PeerConnectionStatus.Connected)
      case .busy:
          print("Replicator in busy state")
          handler(PeerConnectionStatus.Busy)
      case .offline:
          print("Replicator in offline state")
      case .stopped:
          print("Completed syncing documents")
          handler(PeerConnectionStatus.Error)

      }

      if s.progress.completed == s.progress.total {
          print("All documents synced")
      }
      else {
          print("Documents \(s.progress.total - s.progress.completed) still pending sync")
      }
  })
  return pushPullReplListenerForUserDb
// end::replicator-register-for-events[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  fileprivate var _allowlistedUsers:[[String:String]] = []
  // tag::listener-initialize[]
  fileprivate var _thisListener:URLEndpointListener?
  fileprivate var thisDB:Database?

    // tag::listener-config-db[]
    let listenerConfig =
      URLEndpointListenerConfiguration(database: thisDB!) <i class="conum" data-value="61"></i><b>(61)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    /* optionally */ let wsPort: UInt16 = 55991
    /* optionally */ let wssPort: UInt16 = 55990
    listenerConfig.port =  wssPort <i class="conum" data-value="62"></i><b>(62)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    listenerConfig.networkInterface = "10.1.1.10"  <i class="conum" data-value="63"></i><b>(63)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    listenerConfig.enableDeltaSync = true <i class="conum" data-value="64"></i><b>(64)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="65"></i><b>(65)</b>

    // end::listener-config-tls-enable[]
     // tag::listener-config-tls-id-anon[]
    // Set the credentials the server presents the client
    // Use an anonymous self-signed cert
    listenerConfig.tlsIdentity = nil <i class="conum" data-value="66"></i><b>(66)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure how the client is to be authenticated
    // Here, use Basic Authentication
    listenerConfig.authenticator =
      ListenerPasswordAuthenticator(authenticator: {
        (validUser, validPassword) -&gt; Bool in
          if (self._allowlistedUsers.contains {
                $0 == validPassword &amp;&amp; $1 == validUser
              }) {
              return true
              }
            return false
          }) <i class="conum" data-value="67"></i><b>(67)</b>

    // end::listener-config-client-auth-pwd[]

    // tag::listener-start[]
    // Initialize the listener
    _thisListener = URLEndpointListener(config: listenerConfig) <i class="conum" data-value="68"></i><b>(68)</b>
    guard let thisListener = _thisListener else {
      throw ListenerError.NotInitialized
      // ... take appropriate actions
    }
    // Start the listener
    try thisListener.start() <i class="conum" data-value="69"></i><b>(69)</b>

    // end::listener-start[]
// end::listener-initialize[]
  }
}


// BEGIN Additonal listener options



// tag::listener-get-network-interfaces[]
import SystemConfiguration
// . . .

  #if os(macOS)
  for interface in SCNetworkInterfaceCopyAll() as! [SCNetworkInterface] {
      // do something with this `interface`
  }
  #endif
// . . .

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
let config =
  URLEndpointListenerConfiguration(database: self.oDB)
let listener = URLEndpointListener(config: config)
try listener.start()

print("urls: \(listener.urls)")

// end::listener-get-url-list[]


    // tag::listener-config-tls-full[]
    // tag::listener-config-tls-full-enable[]
    listenerConfig.disableTLS  = false <i class="conum" data-value="70"></i><b>(70)</b>

    // end::listener-config-tls-full-enable[]
    // tag::listener-config-tls-disable[]
    listenerConfig.disableTLS  = true <i class="conum" data-value="71"></i><b>(71)</b>

    // end::listener-config-tls-disable[]

    // tag::listener-config-tls-id-full[]
    // tag::listener-config-tls-id-caCert[]
    guard let pathToCert =
      Bundle.main.path(forResource: "cert", ofType: "p12")
    else { /* process error */ return }

    guard let localCertificate =
      try? NSData(contentsOfFile: pathToCert) as Data
    else { /* process error */ return } <i class="conum" data-value="72"></i><b>(72)</b>

    let thisIdentity =
      try TLSIdentity.importIdentity(withData: localCertificate,
                                    password: "123",
                                    label: thisSecId) <i class="conum" data-value="73"></i><b>(73)</b>

    // end::listener-config-tls-id-caCert[]
    // tag::listener-config-tls-id-SelfSigned[]
    let attrs = [certAttrCommonName: "Couchbase Inc"] <i class="conum" data-value="74"></i><b>(74)</b>

    let thisIdentity =
      try TLSIdentity.createIdentity(forServer: true, /* isServer */
            attributes: attrs,
            expiration: Date().addingTimeInterval(86400),
            label: "Server-Cert-Label") <i class="conum" data-value="75"></i><b>(75)</b>

    // end::listener-config-tls-id-SelfSigned[]
    // tag::listener-config-tls-id-full-set[]
    // Set the credentials the server presents the client
    listenerConfig.tlsIdentity = thisIdentity    <i class="conum" data-value="76"></i><b>(76)</b>

    // end::listener-config-tls-id-full-set[]
    // end::listener-config-tls-id-full[]
    // tag::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-root[]
    // Authenticate using Cert Authority

    // cert is a pre-populated object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="77"></i><b>(77)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)! //

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert]) <i class="conum" data-value="78"></i><b>(78)</b> <i class="conum" data-value="79"></i><b>(79)</b>

    // end::listener-config-client-auth-root[]
    // end::listener-config-client-root-ca[]
    // tag::listener-config-client-auth-lambda[]
    // tag::listener-config-client-auth-self-signed[]
    // Authenticate self-signed cert using application logic

    // cert is a user-supplied object of type:SecCertificate representing a certificate
    let rootCertData = SecCertificateCopyData(cert) as Data <i class="conum" data-value="80"></i><b>(80)</b>
    let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!

    listenerConfig.authenticator = ListenerCertificateAuthenticator.init { <i class="conum" data-value="81"></i><b>(81)</b>
      (certs) -&gt; Bool in
        var certs:SecCertificate
        var certCommonName:CFString?
        let status=SecCertificateCopyCommonName(certs[0], &amp;certCommonName)
        if (self._allowedCommonNames.contains(["name": certCommonName! as String])) {
            return true
        }
        return false
    } <i class="conum" data-value="82"></i><b>(82)</b>

    // end::listener-config-client-auth-self-signed[]
    // end::listener-config-client-auth-lambda[]
// END Additonal listener options





// tag::old-listener-config-tls-id-nil[]
listenerConfig.tlsIdentity = nil

// end::old-listener-config-tls-id-nil[]
// tag::old-listener-config-delta-sync[]
listenerConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]
// tag::listener-status-check[]
let totalConnections = thisListener.status.connectionCount
let activeConnections = thisListener.status.activeConnectionCount

// end::listener-status-check[]
// tag::listener-stop[]
        thisListener.stop()

// end::listener-stop[]
// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  listenerConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
// tag::old-listener-config-client-auth-self-signed[]
listenerConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedUsers.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}
// end::old-listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}
// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
config.port = tls ? wssPort : wsPort
config.disableTLS = !tls
config.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>
// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // tag::p2p-act-rep-func[]
    let validUser = "syncuser"
    let validPassword = "sync9455"
    let cert:SecCertificate?
    let passivePeerEndpoint = "10.1.1.12:8920"
    let passivePeerPort = "8920"
    let passiveDbName = "userdb"
    var actDb:Database?
    var thisReplicator:Replicator?
    var replicatorListener:ListenerToken?


    // tag::p2p-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="83"></i><b>(83)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    config.replicatorType = .pushAndPull

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = false; <i class="conum" data-value="84"></i><b>(84)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    config.continuous = true

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="85"></i><b>(85)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Security <i class="conum" data-value="86"></i><b>(86)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: "Our Username", password: "Our Password")
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    config.conflictResolver = ( /* define resolver function */); <i class="conum" data-value="87"></i><b>(87)</b>

    // end::p2p-act-rep-config-conflict[]
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    thisReplicator = Replicator.init( config: config) <i class="conum" data-value="88"></i><b>(88)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // Optionally add a change listener
    // Retain token for use in deletion
    let pushPullReplListener:ListenerToken? = thisReplicator?.addChangeListener({ (change) in <i class="conum" data-value="89"></i><b>(89)</b>
      if change.status.activity == .stopped {
          print("Replication stopped")
      }
      else {
      // tag::p2p-act-rep-status[]
          print("Replicator is currently ", thisReplicator?.status.activity)
      }
    })

    // end::p2p-act-rep-status[]
    // end::p2p-act-rep-add-change-listener[]

    // tag::p2p-act-rep-start[]
        // Run the replicator using the config settings
        thisReplicator?.start()  <i class="conum" data-value="90"></i><b>(90)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]


    // end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener

    thisReplicator?.removeChangeListener(withToken: pushPullReplListener)
    // Stop the replicator
    thisReplicator?.stop()

// end::p2p-act-rep-stop[]
}


// BEGIN Additional p2p-avt-rep options
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    config.acceptOnlySelfSignedServerCertificate = false <i class="conum" data-value="91"></i><b>(91)</b>

    // end::p2p-act-rep-config-cacert[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Security -- only accept self-signed certs
    config.acceptOnlySelfSignedServerCertificate = true; <i class="conum" data-value="92"></i><b>(92)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    config.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]
    // Configure Client Security <i class="conum" data-value="93"></i><b>(93)</b>
    // tag::p2p-act-rep-auth[]
    //  Set Authentication Mode
    let thisAuthenticator = BasicAuthenticator(username: validUser, password: validPassword)
    config.authenticator = thisAuthenticator

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]

    // tag::p2p-tlsid-tlsidentity-with-label[]
      // Check if Id exists in keychain and if so, use that Id
      if let thisIdentity =
        (try? TLSIdentity.identity(withLabel: "doco-sync-server")) ?? nil { <i class="conum" data-value="94"></i><b>(94)</b>
          print("An identity with label : doco-sync-server already exists in keychain")
          thisAuthenticator = ClientCertificateAuthenticator(identity: thisIdentity)  <i class="conum" data-value="95"></i><b>(95)</b>
          config.authenticator = thisAuthenticator
          }

      // end::p2p-tlsid-check-keychain[]
    // end::p2p-tlsid-tlsidentity-with-label[]
// END Additional p2p-avt-rep options




// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright © 2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
    // tag::old-p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-tlsid-check-keychain[]
        // USE KEYCHAIN IDENTITY IF EXISTS
        // Check if Id exists in keychain. If so use that Id
        do {
            if let thisIdentity = try TLSIdentity.identity(withLabel: "doco-sync-server") {
                print("An identity with label : doco-sync-server already exists in keychain")
                return thisIdentity
                }
        } catch
          {return nil}
        // end::p2p-tlsid-check-keychain[]
        thisAuthenticator.ClientCertificateAuthenticator(identity: thisIdentity )
        config.thisAuthenticator
    // end::old-p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert

// tag::p2p-tlsid-delete-id-from-keychain[]

try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);

// end::p2p-tlsid-delete-id-from-keychain[]


// end::p2p-tlsid-manage-func[]
// tag::old-p2p-act-rep-config-self-cert[]
// acceptOnlySelfSignedServerCertificate = true -- accept Slf-Signed Certs
config.disableTLS = false
config.acceptOnlySelfSignedServerCertificate = true

// end::old-p2p-act-rep-config-self-cert[]

// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]

  // Get bundled resource and read into localcert
  guard let pathToCert = Bundle.main.path(forResource: "listener-pinned-cert", ofType: "cer")
    else { /* process error */ }
  guard let localCertificate:NSData =
               NSData(contentsOfFile: pathToCert)
    else { /* process error */ }

  // Create certificate
  // using its DER representation as a CFData
  guard let pinnedCert = SecCertificateCreateWithData(nil, localCertificate)
    else { /* process error */ }

  // Add `pinnedCert` and `acceptOnlySelfSignedServerCertificate=false` to `ReplicatorConfiguration`
  config.acceptOnlySelfSignedServerCertificate = false
  config.pinnedServerCertificate = pinnedCert
  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}

    // optionally  listenerConfig.tlsIdentity = TLSIdentity(withIdentity:serverSelfCert-id)


        // tag::old-listener-config-client-root-ca[]
    // Configure the client authenticator to validate using ROOT CA <i class="conum" data-value="96"></i><b>(96)</b>

    // end::old-listener-config-client-root-ca[]

    // For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
class MyClass {
    var database: Database?
    var replicator: Replicator? <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database!, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator?.start()
    }
}

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]

&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

    // tag::sgw-act-rep-initialize[]
    let tgtUrl = URL(string: "wss://10.1.1.12:8092/travel-sample")!
    let targetEndpoint = URLEndpoint(url: tgtUrl)
    var config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint) <i class="conum" data-value="97"></i><b>(97)</b>

    // end::sgw-act-rep-initialize[]</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delete-tls-identity"><a class="anchor" href="#delete-tls-identity"></a>Delete TLS Identity</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/swift/examples/code_snippets/SampleCodeTest.swift">
try TLSIdentity.deleteIdentity(withLabel: serverCertLabel);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer Data Sync</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API References</a>
.</p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
 <a href="https://docs.couchbase.com/tutorials/index.html">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="page unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content-2"><a class="anchor" href="#related-content-2"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id="-4"><a class="anchor" href="#-4"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-5"><a class="anchor" href="#-5"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer Data Sync</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API References</a>
.</p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-6"><a class="anchor" href="#-6"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
 <a href="https://docs.couchbase.com/tutorials/index.html">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="page unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>© 2021 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script id="site-script" src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../../../_/js/vendor/fontawesome.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
